/**
 * App version: 3.7 19/07/22
 * SDK version: 4.8.3
 * CLI version: 2.14.2
 * 
 * Generated: Thu, 21 Nov 2024 06:13:40 GMT
 */

var APP_accelerator_home_ui = (function () {
  'use strict';

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const settings$2 = {};
  const subscribers$2 = {};
  const initSettings$2 = (appSettings, platformSettings) => {
    settings$2['app'] = appSettings;
    settings$2['platform'] = platformSettings;
    settings$2['user'] = {};
  };
  const publish$2 = (key, value) => {
    subscribers$2[key] && subscribers$2[key].forEach(subscriber => subscriber(value));
  };
  const dotGrab$4 = function () {
    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    if (obj === null) return undefined;
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' && obj !== null ? Object.keys(obj).length ? obj : undefined : obj;
  };
  var Settings$2 = {
    get(type, key) {
      let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      const val = dotGrab$4(settings$2[type], key);
      return val !== undefined ? val : fallback;
    },
    has(type, key) {
      return !!this.get(type, key);
    },
    set(key, value) {
      settings$2['user'][key] = value;
      publish$2(key, value);
    },
    subscribe(key, callback) {
      subscribers$2[key] = subscribers$2[key] || [];
      subscribers$2[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers$2[key] && subscribers$2[key].findIndex(cb => cb === callback);
        index > -1 && subscribers$2[key].splice(index, 1);
      } else {
        if (key in subscribers$2) {
          subscribers$2[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers$2)) {
        delete subscribers$2[key];
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const prepLog = (type, args) => {
    const colors = {
      Info: 'green',
      Debug: 'gray',
      Warn: 'orange',
      Error: 'red'
    };
    args = Array.from(args);
    return ['%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type), 'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px', args];
  };
  var Log = {
    info() {
      Settings$2.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments));
    },
    debug() {
      Settings$2.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments));
    },
    error() {
      Settings$2.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments));
    },
    warn() {
      Settings$2.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments));
    }
  };

  var executeAsPromise = (function (method) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let result;
    if (method && typeof method === 'function') {
      try {
        result = method.apply(context, args);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }

    // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
    if (result !== null && typeof result === 'object' && result.then && typeof result.then === 'function') {
      return result;
    }
    // otherwise make it into a promise
    else {
      return new Promise((resolve, reject) => {
        if (result instanceof Error) {
          reject(result);
        } else {
          resolve(result);
        }
      });
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let sendMetric = (type, event, params) => {
    Log.info('Sending metric', type, event, params);
  };
  const initMetrics = config => {
    sendMetric = config.sendMetric;
  };

  // available metric per category
  const metrics$1 = {
    app: ['launch', 'loaded', 'ready', 'close'],
    page: ['view', 'leave'],
    user: ['click', 'input'],
    media: ['abort', 'canplay', 'ended', 'pause', 'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange', 'waiting', 'seeking', 'seeked']
  };

  // error metric function (added to each category)
  const errorMetric = function (type, message, code, visible) {
    let params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    params = {
      params,
      ...{
        message,
        code,
        visible
      }
    };
    sendMetric(type, 'error', params);
  };
  const Metric = function (type, events) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return events.reduce((obj, event) => {
      obj[event] = function (name) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        params = {
          ...options,
          ...(name ? {
            name
          } : {}),
          ...params
        };
        sendMetric(type, event, params);
      };
      return obj;
    }, {
      error(message, code, params) {
        errorMetric(type, message, code, params);
      },
      event(name, params) {
        sendMetric(type, name, params);
      }
    });
  };
  const Metrics$4 = types => {
    return Object.keys(types).reduce((obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media' ? obj[type] = url => Metric(type, types[type], {
        url
      }) : obj[type] = Metric(type, types[type]);
      return obj;
    }, {
      error: errorMetric,
      event: sendMetric
    });
  };
  var Metrics$5 = Metrics$4(metrics$1);

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var events$2 = {
    abort: 'Abort',
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    durationchange: 'DurationChange',
    emptied: 'Emptied',
    encrypted: 'Encrypted',
    ended: 'Ended',
    error: 'Error',
    interruptbegin: 'InterruptBegin',
    interruptend: 'InterruptEnd',
    loadeddata: 'LoadedData',
    loadedmetadata: 'LoadedMetadata',
    loadstart: 'LoadStart',
    pause: 'Pause',
    play: 'Play',
    playing: 'Playing',
    progress: 'Progress',
    ratechange: 'Ratechange',
    seeked: 'Seeked',
    seeking: 'Seeking',
    stalled: 'Stalled',
    // suspend: 'Suspend', // this one is called a looooot for some videos
    timeupdate: 'TimeUpdate',
    volumechange: 'VolumeChange',
    waiting: 'Waiting'
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoSetupMixin = (function (sourceObject) {
    let setup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
    let ready = false;
    const doSetup = () => {
      if (ready === false) {
        setup();
        ready = true;
      }
    };
    return Object.keys(sourceObject).reduce((obj, key) => {
      if (typeof sourceObject[key] === 'function') {
        obj[key] = function () {
          doSetup();
          return sourceObject[key].apply(sourceObject, arguments);
        };
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
        obj.__defineGetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
        });
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
        obj.__defineSetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(sourceObject, arguments);
        });
      } else {
        obj[key] = sourceObject[key];
      }
      return obj;
    }, {});
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let timeout$1 = null;
  var easeExecution = (cb, delay) => {
    clearTimeout(timeout$1);
    timeout$1 = setTimeout(() => {
      cb();
    }, delay);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let basePath;
  let proxyUrl;
  const initUtils = config => {
    basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'));
    if (config.proxyUrl) {
      proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
    }
  };
  var Utils = {
    asset(relPath) {
      return basePath + relPath;
    },
    proxyUrl(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url;
    },
    makeQueryString() {
      return makeQueryString(...arguments);
    },
    // since imageworkers don't work without protocol
    ensureUrlWithProtocol() {
      return ensureUrlWithProtocol(...arguments);
    }
  };
  const ensureUrlWithProtocol = url => {
    if (/^\/\//.test(url)) {
      return window.location.protocol + url;
    }
    if (!/^(?:https?:)/i.test(url)) {
      return window.location.origin + url;
    }
    return url;
  };
  const makeFullStaticPath = function () {
    let pathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // ensure path has traling slash
    path = path.charAt(path.length - 1) !== '/' ? path + '/' : path;

    // if path is URL, we assume it's already the full static path, so we just return it
    if (/^(?:https?:)?(?:\/\/)/.test(path)) {
      return path;
    }
    if (path.charAt(0) === '/') {
      return path;
    } else {
      // cleanup the pathname (i.e. remove possible index.html)
      pathname = cleanUpPathName(pathname);

      // remove possible leading dot from path
      path = path.charAt(0) === '.' ? path.substr(1) : path;
      // ensure path has leading slash
      path = path.charAt(0) !== '/' ? '/' + path : path;
      return pathname + path;
    }
  };
  const cleanUpPathName = pathname => {
    if (pathname.slice(-1) === '/') return pathname.slice(0, -1);
    const parts = pathname.split('/');
    if (parts[parts.length - 1].indexOf('.') > -1) parts.pop();
    return parts.join('/');
  };
  const makeQueryString = function (url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'url';
    // add operator as an option
    options.operator = 'metrological'; // Todo: make this configurable (via url?)
    // add type (= url or qr) as an option, with url as the value
    options[type] = url;
    return Object.keys(options).map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key]);
    }).join('&');
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initProfile = config => {
    config.getInfo;
    config.setInfo;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var lng$1 = window.lng;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const events$1 = ['timeupdate', 'error', 'ended', 'loadeddata', 'canplay', 'play', 'playing', 'pause', 'loadstart', 'seeking', 'seeked', 'encrypted'];
  let mediaUrl$1 = url => url;
  const initMediaPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl$1 = config.mediaUrl;
    }
  };
  class Mediaplayer extends lng$1.Component {
    _construct() {
      this._skipRenderToTexture = false;
      this._metrics = null;
      this._textureMode = Settings$2.get('platform', 'textureMode') || false;
      Log.info('Texture mode: ' + this._textureMode);
      console.warn(["The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'VideoPlayer'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer'].join('\n\n'));
    }
    static _template() {
      return {
        Video: {
          VideoWrap: {
            VideoTexture: {
              visible: false,
              pivot: 0.5,
              texture: {
                type: lng$1.textures.StaticTexture,
                options: {}
              }
            }
          }
        }
      };
    }
    set skipRenderToTexture(v) {
      this._skipRenderToTexture = v;
    }
    get textureMode() {
      return this._textureMode;
    }
    get videoView() {
      return this.tag('Video');
    }
    _init() {
      //re-use videotag if already there
      const videoEls = document.getElementsByTagName('video');
      if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];else {
        this.videoEl = document.createElement('video');
        this.videoEl.setAttribute('id', 'video-player');
        this.videoEl.style.position = 'absolute';
        this.videoEl.style.zIndex = '1';
        this.videoEl.style.display = 'none';
        this.videoEl.setAttribute('width', '100%');
        this.videoEl.setAttribute('height', '100%');
        this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible';
        document.body.appendChild(this.videoEl);
      }
      if (this.textureMode && !this._skipRenderToTexture) {
        this._createVideoTexture();
      }
      this.eventHandlers = [];
    }
    _registerListeners() {
      events$1.forEach(event => {
        const handler = e => {
          if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
            this._metrics[event]({
              currentTime: this.videoEl.currentTime
            });
          }
          this.fire(event, {
            videoElement: this.videoEl,
            event: e
          });
        };
        this.eventHandlers.push(handler);
        this.videoEl.addEventListener(event, handler);
      });
    }
    _deregisterListeners() {
      Log.info('Deregistering event listeners MediaPlayer');
      events$1.forEach((event, index) => {
        this.videoEl.removeEventListener(event, this.eventHandlers[index]);
      });
      this.eventHandlers = [];
    }
    _attach() {
      this._registerListeners();
    }
    _detach() {
      this._deregisterListeners();
      this.close();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
    }
    _startUpdatingVideoTexture() {
      if (this.textureMode && !this._skipRenderToTexture) {
        const stage = this.stage;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage.gl;
              const currentTime = new Date().getTime();

              // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
              // We'll fallback to fixed 30fps in this case.
              const frameCount = this.videoEl.webkitDecodedFrameCount;
              const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoTextureView.visible = true;
                  this.videoTexture.options.w = this.videoEl.videoWidth;
                  this.videoTexture.options.h = this.videoEl.videoHeight;
                  const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                  const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoTextureView.scaleY = 1;
                  } else {
                    this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoTextureView.scaleX = 1;
                  }
                } catch (e) {
                  Log.error('texImage2d video', e);
                  this._stopUpdatingVideoTexture();
                  this.videoTextureView.visible = false;
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage.on('frameStart', this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
    }
    _stopUpdatingVideoTexture() {
      if (this.textureMode) {
        const stage = this.stage;
        stage.removeListener('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoTextureView.visible = false;
        if (this.videoTexture.options.source) {
          const gl = stage.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
    }
    updateSettings() {
      let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // The Component that 'consumes' the media player.
      this._consumer = settings.consumer;
      if (this._consumer && this._consumer.getMediaplayerSettings) {
        // Allow consumer to add settings.
        settings = Object.assign(settings, this._consumer.getMediaplayerSettings());
      }
      if (!lng$1.Utils.equalValues(this._stream, settings.stream)) {
        if (settings.stream && settings.stream.keySystem) {
          navigator.requestMediaKeySystemAccess(settings.stream.keySystem.id, settings.stream.keySystem.config).then(keySystemAccess => {
            return keySystemAccess.createMediaKeys();
          }).then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys);
          }).then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src);
          }).catch(() => {
            console.error('Failed to set up MediaKeys');
          });
        } else if (settings.stream && settings.stream.src) {
          // This is here to be backwards compatible, will be removed
          // in future sdk release
          if (Settings$2.get('app', 'hls')) {
            if (!window.Hls) {
              window.Hls = class Hls {
                static isSupported() {
                  console.warn('hls-light not included');
                  return false;
                }
              };
            }
            if (window.Hls.isSupported()) {
              if (!this._hls) this._hls = new window.Hls({
                liveDurationInfinity: true
              });
              this._hls.loadSource(settings.stream.src);
              this._hls.attachMedia(this.videoEl);
              this.videoEl.style.display = 'block';
            }
          } else {
            this.open(settings.stream.src);
          }
        } else {
          this.close();
        }
        this._stream = settings.stream;
      }
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPos);
    }
    _setHide(hide) {
      if (this.textureMode) {
        this.tag('Video').setSmooth('alpha', hide ? 0 : 1);
      } else {
        this.videoEl.style.visibility = hide ? 'hidden' : 'visible';
      }
    }
    open(url) {
      let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        hide: false,
        videoPosition: null
      };
      // prep the media url to play depending on platform (mediaPlayerplugin)
      url = mediaUrl$1(url);
      this._metrics = Metrics$5.media(url);
      Log.info('Playing stream', url);
      if (this.application.noVideo) {
        Log.info('noVideo option set, so ignoring: ' + url);
        return;
      }
      // close the video when opening same url as current (effectively reloading)
      if (this.videoEl.getAttribute('src') === url) {
        this.close();
      }
      this.videoEl.setAttribute('src', url);

      // force hide, then force show (in next tick!)
      // (fixes comcast playback rollover issue)
      this.videoEl.style.visibility = 'hidden';
      this.videoEl.style.display = 'none';
      setTimeout(() => {
        this.videoEl.style.display = 'block';
        this.videoEl.style.visibility = 'visible';
      });
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080]);
    }
    close() {
      // We need to pause first in order to stop sound.
      this.videoEl.pause();
      this.videoEl.removeAttribute('src');

      // force load to reset everything without errors
      this.videoEl.load();
      this._clearSrc();
      this.videoEl.style.display = 'none';
    }
    playPause() {
      if (this.isPlaying()) {
        this.doPause();
      } else {
        this.doPlay();
      }
    }
    get muted() {
      return this.videoEl.muted;
    }
    set muted(v) {
      this.videoEl.muted = v;
    }
    get loop() {
      return this.videoEl.loop;
    }
    set loop(v) {
      this.videoEl.loop = v;
    }
    isPlaying() {
      return this._getState() === 'Playing';
    }
    doPlay() {
      this.videoEl.play();
    }
    doPause() {
      this.videoEl.pause();
    }
    reload() {
      var url = this.videoEl.getAttribute('src');
      this.close();
      this.videoEl.src = url;
    }
    getPosition() {
      return Promise.resolve(this.videoEl.currentTime);
    }
    setPosition(pos) {
      this.videoEl.currentTime = pos;
    }
    getDuration() {
      return Promise.resolve(this.videoEl.duration);
    }
    seek(time) {
      let absolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (absolute) {
        this.videoEl.currentTime = time;
      } else {
        this.videoEl.currentTime += time;
      }
    }
    get videoTextureView() {
      return this.tag('Video').tag('VideoTexture');
    }
    get videoTexture() {
      return this.videoTextureView.texture;
    }
    _setVideoArea(videoPos) {
      if (lng$1.Utils.equalValues(this._videoPos, videoPos)) {
        return;
      }
      this._videoPos = videoPos;
      if (this.textureMode) {
        this.videoTextureView.patch({
          smooth: {
            x: videoPos[0],
            y: videoPos[1],
            w: videoPos[2] - videoPos[0],
            h: videoPos[3] - videoPos[1]
          }
        });
      } else {
        const precision = this.stage.getRenderPrecision();
        this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px';
        this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px';
        this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px';
        this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px';
      }
    }
    _fireConsumer(event, args) {
      if (this._consumer) {
        this._consumer.fire(event, args);
      }
    }
    _equalInitData(buf1, buf2) {
      if (!buf1 || !buf2) return false;
      if (buf1.byteLength != buf2.byteLength) return false;
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false;
      return true;
    }
    error(args) {
      this._fireConsumer('$mediaplayerError', args);
      this._setState('');
      return '';
    }
    loadeddata(args) {
      this._fireConsumer('$mediaplayerLoadedData', args);
    }
    play(args) {
      this._fireConsumer('$mediaplayerPlay', args);
    }
    playing(args) {
      this._fireConsumer('$mediaplayerPlaying', args);
      this._setState('Playing');
    }
    canplay(args) {
      this.videoEl.play();
      this._fireConsumer('$mediaplayerStart', args);
    }
    loadstart(args) {
      this._fireConsumer('$mediaplayerLoad', args);
    }
    seeked() {
      this._fireConsumer('$mediaplayerSeeked', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    seeking() {
      this._fireConsumer('$mediaplayerSeeking', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    durationchange(args) {
      this._fireConsumer('$mediaplayerDurationChange', args);
    }
    encrypted(args) {
      const video = args.videoElement;
      const event = args.event;
      // FIXME: Double encrypted events need to be properly filtered by Gstreamer
      if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
        this._previousInitData = event.initData;
        this._fireConsumer('$mediaplayerEncrypted', args);
      }
    }
    static _states() {
      return [class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture();
        }
        $exit() {
          this._stopUpdatingVideoTexture();
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1
          });
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args);
          this._setState('');
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args);
          this._setState('Playing.Paused');
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {});
          this._setState('');
        }
        static _states() {
          return [class Paused extends this {}];
        }
      }];
    }
  }

  class localCookie {
    constructor(e) {
      return e = e || {}, this.forceCookies = e.forceCookies || !1, !0 === this._checkIfLocalStorageWorks() && !0 !== e.forceCookies ? {
        getItem: this._getItemLocalStorage,
        setItem: this._setItemLocalStorage,
        removeItem: this._removeItemLocalStorage,
        clear: this._clearLocalStorage,
        keys: this._getLocalStorageKeys
      } : {
        getItem: this._getItemCookie,
        setItem: this._setItemCookie,
        removeItem: this._removeItemCookie,
        clear: this._clearCookies,
        keys: this._getCookieKeys
      };
    }
    _checkIfLocalStorageWorks() {
      if ("undefined" == typeof localStorage) return !1;
      try {
        return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), !0);
      } catch (e) {
        return !1;
      }
    }
    _getItemLocalStorage(e) {
      return window.localStorage.getItem(e);
    }
    _setItemLocalStorage(e, t) {
      return window.localStorage.setItem(e, t);
    }
    _removeItemLocalStorage(e) {
      return window.localStorage.removeItem(e);
    }
    _clearLocalStorage() {
      return window.localStorage.clear();
    }
    _getLocalStorageKeys() {
      return Object.keys(window.localStorage);
    }
    _getItemCookie(e) {
      var t = document.cookie.match(RegExp("(?:^|;\\s*)" + function (e) {
        return e.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
      }(e) + "=([^;]*)"));
      return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
    }
    _setItemCookie(e, t) {
      var o = new Date(),
        r = new Date(o.getTime() + 15768e7);
      document.cookie = "".concat(e, "=").concat(t, "; expires=").concat(r.toUTCString(), ";");
    }
    _removeItemCookie(e) {
      document.cookie = "".concat(e, "=;Max-Age=-99999999;");
    }
    _clearCookies() {
      document.cookie.split(";").forEach(e => {
        document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
      });
    }
    _getCookieKeys() {
      return document.cookie.split(";").map(e => e.split("=")[0]);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let namespace;
  let lc;
  const initStorage = () => {
    namespace = Settings$2.get('platform', 'id');
    // todo: pass options (for example to force the use of cookies)
    lc = new localCookie();
  };
  const namespacedKey = key => namespace ? [namespace, key].join('.') : key;
  var Storage$1 = {
    get(key) {
      try {
        return JSON.parse(lc.getItem(namespacedKey(key)));
      } catch (e) {
        return null;
      }
    },
    set(key, value) {
      try {
        lc.setItem(namespacedKey(key), JSON.stringify(value));
        return true;
      } catch (e) {
        return false;
      }
    },
    remove(key) {
      lc.removeItem(namespacedKey(key));
    },
    clear() {
      if (namespace) {
        lc.keys().forEach(key => {
          // remove the item if in the namespace
          key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null;
        });
      } else {
        lc.clear();
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
  const isWildcard = /^[!*$]$/;
  const hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
  const isNamedGroup = /^\/:/;

  /**
   * Test if a route is part regular expressed
   * and replace it for a simple character
   * @param route
   * @returns {*}
   */
  const stripRegex = function (route) {
    let char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'R';
    // if route is part regular expressed we replace
    // the regular expression for a character to
    // simplify floor calculation and backtracking
    if (hasRegex.test(route)) {
      route = route.replace(hasRegex, char);
    }
    return route;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Create a local request register
   * @param flags
   * @returns {Map<any, any>}
   */
  const createRegister = flags => {
    const reg = new Map()
    // store user defined and router
    // defined flags in register
    ;
    [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
      reg.set(key, flags[key]);
    });
    return reg;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Request {
    constructor() {
      let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      let navArgs = arguments.length > 1 ? arguments[1] : undefined;
      let storeCaller = arguments.length > 2 ? arguments[2] : undefined;
      /**
       * Hash we navigate to
       * @type {string}
       * @private
       */
      this._hash = hash;

      /**
       * Do we store previous hash in history
       * @type {boolean}
       * @private
       */
      this._storeCaller = storeCaller;

      /**
       * Request and navigate data
       * @type {Map}
       * @private
       */
      this._register = new Map();

      /**
       * Flag if the instance is created due to
       * this request
       * @type {boolean}
       * @private
       */
      this._isCreated = false;

      /**
       * Flag if the instance is shared between
       * previous and current request
       * @type {boolean}
       * @private
       */
      this._isSharedInstance = false;

      /**
       * Flag if the request has been cancelled
       * @type {boolean}
       * @private
       */
      this._cancelled = false;

      /**
       * if instance is shared between requests we copy state object
       * from instance before the new request overrides state
       * @type {null}
       * @private
       */
      this._copiedHistoryState = null;

      // if there are arguments attached to navigate()
      // we store them in new request
      if (isObject(navArgs)) {
        this._register = createRegister(navArgs);
      } else if (isBoolean(navArgs)) {
        // if second navigate() argument is explicitly
        // set to false we prevent the calling page
        // from ending up in history
        this._storeCaller = navArgs;
      }
      // @todo: remove because we can simply check
      // ._storeCaller property
      this._register.set(symbols.store, this._storeCaller);
    }
    cancel() {
      Log.debug('[router]:', "cancelled ".concat(this._hash));
      this._cancelled = true;
    }
    get url() {
      return this._hash;
    }
    get register() {
      return this._register;
    }
    get hash() {
      return this._hash;
    }
    set hash(args) {
      this._hash = args;
    }
    get route() {
      return this._route;
    }
    set route(args) {
      this._route = args;
    }
    get provider() {
      return this._provider;
    }
    set provider(args) {
      this._provider = args;
    }
    get providerType() {
      return this._providerType;
    }
    set providerType(args) {
      this._providerType = args;
    }
    set page(args) {
      this._page = args;
    }
    get page() {
      return this._page;
    }
    set isCreated(args) {
      this._isCreated = args;
    }
    get isCreated() {
      return this._isCreated;
    }
    get isSharedInstance() {
      return this._isSharedInstance;
    }
    set isSharedInstance(args) {
      this._isSharedInstance = args;
    }
    get isCancelled() {
      return this._cancelled;
    }
    set copiedHistoryState(v) {
      this._copiedHistoryState = v;
    }
    get copiedHistoryState() {
      return this._copiedHistoryState;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Route {
    constructor() {
      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // keep backwards compatible
      let type = ['on', 'before', 'after'].reduce((acc, type) => {
        return isFunction(config[type]) ? type : acc;
      }, undefined);
      this._cfg = config;
      if (type) {
        this._provider = {
          type,
          request: config[type]
        };
      }
    }
    get path() {
      return this._cfg.path;
    }
    get component() {
      return this._cfg.component;
    }
    get options() {
      return this._cfg.options;
    }
    get widgets() {
      return this._cfg.widgets;
    }
    get cache() {
      return this._cfg.cache;
    }
    get hook() {
      return this._cfg.hook;
    }
    get beforeNavigate() {
      return this._cfg.beforeNavigate;
    }
    get provider() {
      return this._provider;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple route length calculation
   * @param route {string}
   * @returns {number} - floor
   */
  const getFloor = route => {
    return stripRegex(route).split('/').length;
  };

  /**
   * return all stored routes that live on the same floor
   * @param floor
   * @returns {Array}
   */
  const getRoutesByFloor = floor => {
    const matches = [];
    // simple filter of level candidates
    for (let [route] of routes$1.entries()) {
      if (getFloor(route) === floor) {
        matches.push(route);
      }
    }
    return matches;
  };

  /**
   * return a matching route by provided hash
   * hash: home/browse/12 will match:
   * route: home/browse/:categoryId
   * @param hash {string}
   * @returns {boolean|{}} - route
   */
  const getRouteByHash = hash => {
    // @todo: clean up on handleHash
    hash = hash.replace(/^#/, '');
    const getUrlParts = /(\/?:?[^/]+)/g;
    // grab possible candidates from stored routes
    const candidates = getRoutesByFloor(getFloor(hash));
    // break hash down in chunks
    const hashParts = hash.match(getUrlParts) || [];

    // to simplify the route matching and prevent look around
    // in our getUrlParts regex we get the regex part from
    // route candidate and store them so that we can reference
    // them when we perform the actual regex against hash
    let regexStore = [];
    let matches = candidates.filter(route => {
      let isMatching = true;
      // replace regex in route with lookup id => @@{storeId}@@
      if (hasRegex.test(route)) {
        const regMatches = route.match(hasRegex);
        if (regMatches && regMatches.length) {
          route = regMatches.reduce((fullRoute, regex) => {
            const lookupId = regexStore.length;
            fullRoute = fullRoute.replace(regex, "@@".concat(lookupId, "@@"));
            regexStore.push(regex.substring(1, regex.length - 1));
            return fullRoute;
          }, route);
        }
      }
      const routeParts = route.match(getUrlParts) || [];
      for (let i = 0, j = routeParts.length; i < j; i++) {
        const routePart = routeParts[i];
        const hashPart = hashParts[i];

        // Since we support catch-all and regex driven name groups
        // we first test for regex lookup id and see if the regex
        // matches the value from the hash
        if (hasLookupId.test(routePart)) {
          const routeMatches = hasLookupId.exec(routePart);
          const storeId = routeMatches[1];
          const routeRegex = regexStore[storeId];

          // split regex and modifiers so we can use both
          // to create a new RegExp
          // eslint-disable-next-line
          const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
          if (regMatches && regMatches.length) {
            const expression = regMatches[1];
            const modifiers = regMatches[2];
            const regex = new RegExp("^/".concat(expression, "$"), modifiers);
            if (!regex.test(hashPart)) {
              isMatching = false;
            }
          }
        } else if (isNamedGroup.test(routePart)) {
          // we kindly skip namedGroups because this is dynamic
          // we only need to the static and regex drive parts
          continue;
        } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
          isMatching = false;
        }
      }
      return isMatching;
    });
    if (matches.length) {
      if (matches.indexOf(hash) !== -1) {
        const match = matches[matches.indexOf(hash)];
        return routes$1.get(match);
      } else {
        // we give prio to static routes over dynamic
        matches = matches.sort(a => {
          return isNamedGroup.test(a) ? -1 : 1;
        });
        // would be strange if this fails
        // but still we test
        if (routeExists(matches[0])) {
          return routes$1.get(matches[0]);
        }
      }
    }
    return false;
  };
  const getValuesFromHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // replace the regex definition from the route because
    // we already did the matching part
    path = stripRegex(path, '');
    const getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
    const hashParts = hash.match(getUrlParts) || [];
    const routeParts = path.match(getUrlParts) || [];
    const getNamedGroup = /^\/:([\w-]+)\/?/;
    return routeParts.reduce((storage, value, index) => {
      const match = getNamedGroup.exec(value);
      if (match && match.length) {
        storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')));
      }
      return storage;
    }, new Map());
  };
  const getOption = (stack, prop) => {
    // eslint-disable-next-line
    if (stack && stack.hasOwnProperty(prop)) {
      return stack[prop];
    }
    // we explicitly return undefined since we're testing
    // for explicit test values
  };

  /**
   * create and return new Route instance
   * @param config
   */
  const createRoute = config => {
    // we need to provide a bit of additional logic
    // for the bootComponent
    if (config.path === '$') {
      let options = {
        preventStorage: true
      };
      if (isObject(config.options)) {
        options = {
          ...config.options,
          ...options
        };
      }
      config.options = options;
      // if configured add reference to bootRequest
      // as router after provider
      if (bootRequest) {
        config.after = bootRequest;
      }
    }
    return new Route(config);
  };

  /**
   * Create a new Router request object
   * @param url
   * @param args
   * @param store
   * @returns {*}
   */
  const createRequest = (url, args, store) => {
    return new Request(url, args, store);
  };
  const getHashByName = obj => {
    if (!obj.to && !obj.name) {
      return false;
    }
    const route = getRouteByName(obj.to || obj.name);
    const hasDynamicGroup = /\/:([\w-]+)\/?/;
    let hash = route;

    // if route contains dynamic group
    // we replace them with the provided params
    if (hasDynamicGroup.test(route)) {
      if (obj.params) {
        const keys = Object.keys(obj.params);
        hash = keys.reduce((acc, key) => {
          return acc.replace(":".concat(key), obj.params[key]);
        }, route);
      }
      if (obj.query) {
        return "".concat(hash).concat(objectToQueryString(obj.query));
      }
    }
    return hash;
  };
  const getRouteByName = name => {
    for (let [path, route] of routes$1.entries()) {
      if (route.name === name) {
        return path;
      }
    }
    return false;
  };
  const keepActivePageAlive = (route, request) => {
    if (isString(route)) {
      const routes = getRoutes();
      if (routes.has(route)) {
        route = routes.get(route);
      } else {
        return false;
      }
    }
    const register = request.register;
    const routeOptions = route.options;
    if (register.has('keepAlive')) {
      return register.get('keepAlive');
    } else if (routeOptions && routeOptions.keepAlive) {
      return routeOptions.keepAlive;
    }
    return false;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var emit$4 = (function (page) {
    let events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!isArray(events)) {
      events = [events];
    }
    events.forEach(e => {
      const event = "_on".concat(ucfirst(e));
      if (isFunction(page[event])) {
        page[event](params);
      }
    });
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let activeWidget = null;
  const getReferences = () => {
    if (!widgetsHost) {
      return;
    }
    return widgetsHost.get().reduce((storage, widget) => {
      const key = widget.ref.toLowerCase();
      storage[key] = widget;
      return storage;
    }, {});
  };

  /**
   * update the visibility of the available widgets
   * for the current page / route
   * @param page
   */
  const updateWidgets = (widgets, page) => {
    // force lowercase lookup
    const configured = (widgets || []).map(ref => ref.toLowerCase());
    widgetsHost.forEach(widget => {
      widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
      if (widget.visible) {
        emit$4(widget, ['activated'], page);
      }
    });
    if (app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
      app._setState('');
    }
  };
  const getWidgetByName = name => {
    name = ucfirst(name);
    return widgetsHost.getByRef(name) || false;
  };

  /**
   * delegate app focus to a on-screen widget
   * @param name - {string}
   */
  const focusWidget = name => {
    const widget = getWidgetByName(name);
    if (widget) {
      setActiveWidget(widget);

      // if app is already in 'Widgets' state we can assume that
      // focus has been delegated from one widget to another so
      // we need to set the new widget reference and trigger a
      // new focus calculation of Lightning's focuspath
      if (app.state === 'Widgets') {
        app.reload(activeWidget);
      } else {
        app._setState('Widgets', [activeWidget]);
      }
    }
  };
  const restoreFocus = () => {
    activeWidget = null;
    app._setState('');
  };
  const getActiveWidget = () => {
    return activeWidget;
  };
  const setActiveWidget = instance => {
    activeWidget = instance;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const createComponent = (stage, type) => {
    return stage.c({
      type,
      visible: false,
      widgets: getReferences()
    });
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple flat array that holds the visited hashes + state Object
   * so the router can navigate back to them
   * @type {Array}
   */
  let history = [];
  const updateHistory = request => {
    const hash = getActiveHash();
    if (!hash) {
      return;
    }

    // navigate storage flag
    const register = request.register;
    const forceNavigateStore = register.get(symbols.store);

    // test preventStorage on route configuration
    const activeRoute = getRouteByHash(hash);
    const preventStorage = getOption(activeRoute.options, 'preventStorage');

    // we give prio to navigate storage flag
    let store = isBoolean(forceNavigateStore) ? forceNavigateStore : !preventStorage;
    if (store) {
      const toStore = hash.replace(/^\//, '');
      const location = locationInHistory(toStore);
      const stateObject = getStateObject(getActivePage(), request);
      const routerConfig = getRouterConfig();

      // store hash if it's not a part of history or flag for
      // storage of same hash is true
      if (location === -1 || routerConfig.get('storeSameHash')) {
        history.push({
          hash: toStore,
          state: stateObject
        });
      } else {
        // if we visit the same route we want to sync history
        const prev = history.splice(location, 1)[0];
        history.push({
          hash: prev.hash,
          state: stateObject
        });
      }
    }
  };
  const locationInHistory = hash => {
    for (let i = 0; i < history.length; i++) {
      if (history[i].hash === hash) {
        return i;
      }
    }
    return -1;
  };
  const getHistoryState = hash => {
    let state = null;
    if (history.length) {
      // if no hash is provided we get the last
      // pushed history record
      if (!hash) {
        const record = history[history.length - 1];
        // could be null
        state = record.state;
      } else {
        if (locationInHistory(hash) !== -1) {
          const record = history[locationInHistory(hash)];
          state = record.state;
        }
      }
    }
    return state;
  };
  const replaceHistoryState = function () {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let hash = arguments.length > 1 ? arguments[1] : undefined;
    if (!history.length) {
      return;
    }
    const location = hash ? locationInHistory(hash) : history.length - 1;
    if (location !== -1 && isObject(state)) {
      history[location].state = state;
    }
  };
  const getStateObject = (page, request) => {
    // if the new request shared instance with the
    // previous request we used the copied state object
    if (request.isSharedInstance) {
      if (request.copiedHistoryState) {
        return request.copiedHistoryState;
      }
    } else if (page && isFunction(page.historyState)) {
      return page.historyState();
    }
    return null;
  };
  const getHistory = () => {
    return history.slice(0);
  };
  const setHistory = function () {
    let arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (isArray(arr)) {
      history = arr;
    }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  var cjs = deepmerge_1;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let warned = false;
  const deprecated = function () {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (force === true || warned === false) {
      console.warn(["The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'Language'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language'].join('\n\n'));
    }
    warned = true;
  };
  class Locale {
    constructor() {
      this.__enabled = false;
    }

    /**
     * Loads translation object from external json file.
     *
     * @param {String} path Path to resource.
     * @return {Promise}
     */
    async load(path) {
      if (!this.__enabled) {
        return;
      }
      await fetch(path).then(resp => resp.json()).then(resp => {
        this.loadFromObject(resp);
      });
    }

    /**
     * Sets language used by module.
     *
     * @param {String} lang
     */
    setLanguage(lang) {
      deprecated();
      this.__enabled = true;
      this.language = lang;
    }

    /**
     * Returns reference to translation object for current language.
     *
     * @return {Object}
     */
    get tr() {
      deprecated(true);
      return this.__trObj[this.language];
    }

    /**
     * Loads translation object from existing object (binds existing object).
     *
     * @param {Object} trObj
     */
    loadFromObject(trObj) {
      deprecated();
      const fallbackLanguage = 'en';
      if (Object.keys(trObj).indexOf(this.language) === -1) {
        Log.warn('No translations found for: ' + this.language);
        if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
          Log.warn('Using fallback language: ' + fallbackLanguage);
          this.language = fallbackLanguage;
        } else {
          const error = 'No translations found for fallback language: ' + fallbackLanguage;
          Log.error(error);
          throw Error(error);
        }
      }
      this.__trObj = trObj;
      for (const lang of Object.values(this.__trObj)) {
        for (const str of Object.keys(lang)) {
          lang[str] = new LocalizedString(lang[str]);
        }
      }
    }
  }

  /**
   * Extended string class used for localization.
   */
  class LocalizedString extends String {
    /**
     * Returns formatted LocalizedString.
     * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
     *
     * E.g.:
     * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
     * A and B and A
     *
     * @param  {...any} args List of arguments for placeholders.
     */
    format() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const sub = args.reduce((string, arg, index) => string.split("{".concat(index, "}")).join(arg), this);
      return new LocalizedString(sub);
    }
  }
  var Locale$1 = new Locale();

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VersionLabel extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xbb0078ac,
        h: 40,
        w: 100,
        x: w => w - 50,
        y: h => h - 50,
        mount: 1,
        Text: {
          w: w => w,
          h: h => h,
          y: 5,
          x: 20,
          text: {
            fontSize: 22,
            lineHeight: 26
          }
        }
      };
    }
    _firstActive() {
      this.tag('Text').text = "APP - v".concat(this.version, "\nSDK - v").concat(this.sdkVersion);
      this.tag('Text').loadTexture();
      this.w = this.tag('Text').renderWidth + 40;
      this.h = this.tag('Text').renderHeight + 5;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FpsIndicator extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xffffffff,
        texture: lng$1.Tools.getRoundRect(80, 80, 40),
        h: 80,
        w: 80,
        x: 100,
        y: 100,
        mount: 1,
        Background: {
          x: 3,
          y: 3,
          texture: lng$1.Tools.getRoundRect(72, 72, 36),
          color: 0xff008000
        },
        Counter: {
          w: w => w,
          h: h => h,
          y: 10,
          text: {
            fontSize: 32,
            textAlign: 'center'
          }
        },
        Text: {
          w: w => w,
          h: h => h,
          y: 48,
          text: {
            fontSize: 15,
            textAlign: 'center',
            text: 'FPS'
          }
        }
      };
    }
    _setup() {
      this.config = {
        ...{
          log: false,
          interval: 500,
          threshold: 1
        },
        ...Settings$2.get('platform', 'showFps')
      };
      this.fps = 0;
      this.lastFps = this.fps - this.config.threshold;
      const fpsCalculator = () => {
        this.fps = ~~(1 / this.stage.dt);
      };
      this.stage.on('frameStart', fpsCalculator);
      this.stage.off('framestart', fpsCalculator);
      this.interval = setInterval(this.showFps.bind(this), this.config.interval);
    }
    _firstActive() {
      this.showFps();
    }
    _detach() {
      clearInterval(this.interval);
    }
    showFps() {
      if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return;
      this.lastFps = this.fps;
      // green
      let bgColor = 0xff008000;
      // orange
      if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500;
      // red
      else if (this.fps <= 20) bgColor = 0xffff0000;
      this.tag('Background').setSmooth('color', bgColor);
      this.tag('Counter').text = "".concat(this.fps);
      this.config.log && Log.info('FPS', this.fps);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let meta = {};
  let translations = {};
  let language$2 = null;
  let dictionary = null;
  const initLanguage = function (file) {
    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new Promise((resolve, reject) => {
      fetch(file).then(response => response.json()).then(json => {
        setTranslations(json);
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function' ? language.then(lang => setLanguage(lang).then(resolve).catch(reject)).catch(e => {
          Log.error(e);
          reject(e);
        }) : setLanguage(language).then(resolve).catch(reject);
      }).catch(() => {
        const error = 'Language file ' + file + ' not found';
        Log.error(error);
        reject(error);
      });
    });
  };
  const setTranslations = obj => {
    if ('meta' in obj) {
      meta = {
        ...obj.meta
      };
      delete obj.meta;
    }
    translations = obj;
  };
  const getLanguage = () => {
    return language$2;
  };
  const setLanguage = lng => {
    language$2 = null;
    dictionary = null;
    return new Promise((resolve, reject) => {
      if (lng in translations) {
        language$2 = lng;
      } else {
        if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
          language$2 = meta.map[lng];
        } else if ('default' in meta && meta.default in translations) {
          const error = 'Translations for Language ' + language$2 + ' not found. Using default language ' + meta.default;
          Log.warn(error);
          language$2 = meta.default;
        } else {
          const error = 'Translations for Language ' + language$2 + ' not found.';
          Log.error(error);
          reject(error);
        }
      }
      if (language$2) {
        Log.info('Setting language to', language$2);
        const translationsObj = translations[language$2];
        if (typeof translationsObj === 'object') {
          dictionary = translationsObj;
          resolve();
        } else if (typeof translationsObj === 'string') {
          const url = Utils.asset(translationsObj);
          fetch(url).then(response => response.json()).then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language$2] = json;
            dictionary = json;
            resolve();
          }).catch(e => {
            const error = 'Error while fetching ' + url;
            Log.error(error, e);
            reject(error);
          });
        }
      }
    });
  };
  var Language$1 = {
    translate(key) {
      let replacements = [...arguments].slice(1);

      // no replacements so just translated string
      if (replacements.length === 0) {
        return dictionary && dictionary[key] || key;
      } else {
        if (replacements.length === 1 && typeof replacements[0] === 'object') {
          replacements = replacements.pop();
        }
        return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements).reduce((text, replacementKey) => {
          return text.replace(new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'), replacements[replacementKey]);
        }, dictionary && dictionary[key] || key);
      }
    },
    translations(obj) {
      setTranslations(obj);
    },
    set(language) {
      return setLanguage(language);
    },
    get() {
      return getLanguage();
    },
    available() {
      const languageKeys = Object.keys(translations);
      return languageKeys.map(key => ({
        code: key,
        name: meta.names && meta.names[key] || key
      }));
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const registry = {
    eventListeners: [],
    timeouts: [],
    intervals: [],
    targets: []
  };
  var Registry = {
    // Timeouts
    setTimeout(cb, timeout) {
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }
      const timeoutId = setTimeout(() => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        cb.apply(null, params);
      }, timeout, params);
      Log.info('Set Timeout', 'ID: ' + timeoutId);
      registry.timeouts.push(timeoutId);
      return timeoutId;
    },
    clearTimeout(timeoutId) {
      if (registry.timeouts.indexOf(timeoutId) > -1) {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        Log.info('Clear Timeout', 'ID: ' + timeoutId);
        clearTimeout(timeoutId);
      } else {
        Log.error('Clear Timeout', 'ID ' + timeoutId + ' not found');
      }
    },
    clearTimeouts() {
      registry.timeouts.forEach(timeoutId => {
        this.clearTimeout(timeoutId);
      });
    },
    // Intervals
    setInterval(cb, interval) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        params[_key2 - 2] = arguments[_key2];
      }
      const intervalId = setInterval(() => {
        registry.intervals.filter(id => id !== intervalId);
        cb.apply(null, params);
      }, interval, params);
      Log.info('Set Interval', 'ID: ' + intervalId);
      registry.intervals.push(intervalId);
      return intervalId;
    },
    clearInterval(intervalId) {
      if (registry.intervals.indexOf(intervalId) > -1) {
        registry.intervals = registry.intervals.filter(id => id !== intervalId);
        Log.info('Clear Interval', 'ID: ' + intervalId);
        clearInterval(intervalId);
      } else {
        Log.error('Clear Interval', 'ID ' + intervalId + ' not found');
      }
    },
    clearIntervals() {
      registry.intervals.forEach(intervalId => {
        this.clearInterval(intervalId);
      });
    },
    // Event listeners
    addEventListener(target, event, handler) {
      target.addEventListener(event, handler);
      const targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
      registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
      registry.eventListeners[targetIndex][event].push(handler);
      Log.info('Add eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
    },
    removeEventListener(target, event, handler) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
        registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter(fn => fn !== handler);
        Log.info('Remove eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
        target.removeEventListener(event, handler);
      } else {
        Log.error('Remove eventListener', 'Not found', 'Target', target, 'Event: ' + event, 'Handler', handler.toString());
      }
    },
    // if `event` is omitted, removes all registered event listeners for target
    // if `target` is also omitted, removes all registered event listeners
    removeEventListeners(target, event) {
      if (target && event) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          registry.eventListeners[targetIndex][event].forEach(handler => {
            this.removeEventListener(target, event, handler);
          });
        }
      } else if (target) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
            this.removeEventListeners(target, _event);
          });
        }
      } else {
        Object.keys(registry.eventListeners).forEach(targetIndex => {
          this.removeEventListeners(registry.targets[targetIndex]);
        });
      }
    },
    // Clear everything (to be called upon app close for proper cleanup)
    clear() {
      this.clearTimeouts();
      this.clearIntervals();
      this.removeEventListeners();
      registry.eventListeners = [];
      registry.timeouts = [];
      registry.intervals = [];
      registry.targets = [];
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const isObject$1 = v => {
    return typeof v === 'object' && v !== null;
  };
  const isString$1 = v => {
    return typeof v === 'string';
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let colors = {
    white: '#ffffff',
    black: '#000000',
    red: '#ff0000',
    green: '#00ff00',
    blue: '#0000ff',
    yellow: '#feff00',
    cyan: '#00feff',
    magenta: '#ff00ff'
  };
  const normalizedColors = {
    //store for normalized colors
  };
  const addColors = (colorsToAdd, value) => {
    if (isObject$1(colorsToAdd)) {
      // clean up normalizedColors if they exist in the to be added colors
      Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color));
      colors = Object.assign({}, colors, colorsToAdd);
    } else if (isString$1(colorsToAdd) && value) {
      cleanUpNormalizedColors(colorsToAdd);
      colors[colorsToAdd] = value;
    }
  };
  const cleanUpNormalizedColors = color => {
    for (let c in normalizedColors) {
      if (c.indexOf(color) > -1) {
        delete normalizedColors[c];
      }
    }
  };
  const initColors = file => {
    return new Promise((resolve, reject) => {
      if (typeof file === 'object') {
        addColors(file);
        return resolve();
      }
      fetch(file).then(response => response.json()).then(json => {
        addColors(json);
        return resolve();
      }).catch(() => {
        const error = 'Colors file ' + file + ' not found';
        Log.error(error);
        return reject(error);
      });
    });
  };

  var name$1 = "@lightningjs/sdk";
  var version$1 = "4.8.3";
  var license = "Apache-2.0";
  var scripts = {
  	postinstall: "node ./scripts/postinstall.js",
  	lint: "eslint '**/*.js'",
  	release: "npm publish --access public"
  };
  var husky = {
  	hooks: {
  		"pre-commit": "lint-staged"
  	}
  };
  var dependencies = {
  	"@babel/polyfill": "^7.11.5",
  	"@lightningjs/core": "*",
  	"@michieljs/execute-as-promise": "^1.0.0",
  	deepmerge: "^4.2.2",
  	localCookie: "github:WebPlatformForEmbedded/localCookie",
  	shelljs: "^0.8.5",
  	"url-polyfill": "^1.1.10",
  	"whatwg-fetch": "^3.0.0"
  };
  var devDependencies = {
  	"@babel/core": "^7.11.6",
  	"@babel/plugin-transform-parameters": "^7.10.5 ",
  	"@babel/plugin-transform-spread": "^7.11.0",
  	"@babel/preset-env": "^7.11.5",
  	"babel-eslint": "^10.1.0",
  	eslint: "^7.10.0",
  	"eslint-config-prettier": "^6.12.0",
  	"eslint-plugin-prettier": "^3.1.4",
  	husky: "^4.3.0",
  	"lint-staged": "^10.4.0",
  	prettier: "^1.19.1",
  	rollup: "^1.32.1",
  	"rollup-plugin-babel": "^4.4.0"
  };
  var repository = {
  	type: "git",
  	url: "git@github.com:rdkcentral/Lightning-SDK.git"
  };
  var bugs = {
  	url: "https://github.com/rdkcentral/Lightning-SDK/issues"
  };
  var packageInfo = {
  	name: name$1,
  	version: version$1,
  	license: license,
  	scripts: scripts,
  	"lint-staged": {
  	"*.js": [
  		"eslint --fix"
  	],
  	"src/startApp.js": [
  		"rollup -c ./rollup.config.js"
  	]
  },
  	husky: husky,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	repository: repository,
  	bugs: bugs
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let AppInstance;
  const defaultOptions$1 = {
    stage: {
      w: 1920,
      h: 1080,
      clearColor: 0x00000000,
      canvas2d: false
    },
    debug: false,
    defaultFontFace: 'RobotoRegular',
    keys: {
      8: 'Back',
      13: 'Enter',
      27: 'Menu',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      174: 'ChannelDown',
      175: 'ChannelUp',
      178: 'Stop',
      250: 'PlayPause',
      191: 'Search',
      // Use "/" for keyboard
      409: 'Search'
    }
  };
  const customFontFaces$1 = [];
  const fontLoader$1 = (fonts, store) => new Promise((resolve, reject) => {
    fonts.map(_ref => {
      let {
        family,
        url,
        urls,
        descriptors
      } = _ref;
      return () => {
        const src = urls ? urls.map(url => {
          return 'url(' + url + ')';
        }) : 'url(' + url + ')';
        const fontFace = new FontFace(family, src, descriptors || {});
        store.push(fontFace);
        Log.info('Loading font', family);
        document.fonts.add(fontFace);
        return fontFace.load();
      };
    }).reduce((promise, method) => {
      return promise.then(() => method());
    }, Promise.resolve(null)).then(resolve).catch(reject);
  });
  function Application (App, appData, platformSettings) {
    const {
      width,
      height
    } = platformSettings;
    if (width && height) {
      defaultOptions$1.stage['w'] = width;
      defaultOptions$1.stage['h'] = height;
      defaultOptions$1.stage['precision'] = width / 1920;
    }

    // support for 720p browser
    if (!width && !height && window.innerHeight === 720) {
      defaultOptions$1.stage['w'] = 1280;
      defaultOptions$1.stage['h'] = 720;
      defaultOptions$1.stage['precision'] = 1280 / 1920;
    }
    return class Application extends lng$1.Application {
      constructor(options) {
        const config = cjs(defaultOptions$1, options);
        // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
        if (options.stage.canvas) {
          config.stage.canvas = options.stage.canvas;
        }
        super(config);
        this.config = config;
      }
      static _template() {
        return {
          w: 1920,
          h: 1080
        };
      }
      _setup() {
        Promise.all([this.loadFonts(App.config && App.config.fonts || App.getFonts && App.getFonts() || []),
        // to be deprecated
        Locale$1.load(App.config && App.config.locale || App.getLocale && App.getLocale()), App.language && this.loadLanguage(App.language()), App.colors && this.loadColors(App.colors())]).then(() => {
          Metrics$5.app.loaded();
          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
          });
          this.childList.a(AppInstance);
          this._refocus();
          Log.info('App version', this.config.version);
          Log.info('SDK version', packageInfo.version);
          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: VersionLabel,
              version: this.config.version,
              sdkVersion: packageInfo.version,
              zIndex: 1
            });
          }
          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: FpsIndicator,
              zIndex: 1
            });
          }
          super._setup();
        }).catch(console.error);
      }
      _handleBack() {
        this.closeApp();
      }
      _handleExit() {
        this.closeApp();
      }
      closeApp() {
        Log.info('Signaling App Close');
        if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
          platformSettings.onClose(...arguments);
        } else {
          this.close();
        }
      }
      close() {
        Log.info('Closing App');
        Settings$2.clearSubscribers();
        Registry.clear();
        this.childList.remove(this.tag('App'));
        this.cleanupFonts();
        // force texture garbage collect
        this.stage.gc();
        this.destroy();
      }
      loadFonts(fonts) {
        return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function' ? platformSettings.fontLoader(fonts, customFontFaces$1) : fontLoader$1(fonts, customFontFaces$1);
      }
      cleanupFonts() {
        if ('delete' in document.fonts) {
          customFontFaces$1.forEach(fontFace => {
            Log.info('Removing font', fontFace.family);
            document.fonts.delete(fontFace);
          });
        } else {
          Log.info('No support for removing manually-added fonts');
        }
      }
      loadLanguage(config) {
        let file = Utils.asset('translations.json');
        let language = config;
        if (typeof language === 'object') {
          language = config.language || null;
          file = config.file || file;
        }
        return initLanguage(file, language);
      }
      loadColors(config) {
        let file = Utils.asset('colors.json');
        if (config && (typeof config === 'string' || typeof config === 'object')) {
          file = config;
        }
        return initColors(file);
      }
      set focus(v) {
        this._focussed = v;
        this._refocus();
      }
      _getFocused() {
        return this._focussed || this.tag('App');
      }
    };
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @type {Lightning.Application}
   */
  let application;

  /**
   * Actual instance of the app
   * @type {Lightning.Component}
   */
  let app;

  /**
   * Component that hosts all routed pages
   * @type {Lightning.Component}
   */
  let pagesHost;

  /**
   * @type {Lightning.Stage}
   */
  let stage;

  /**
   * Platform driven Router configuration
   * @type {Map<string>}
   */
  let routerConfig;

  /**
   * Component that hosts all attached widgets
   * @type {Lightning.Component}
   */
  let widgetsHost;

  /**
   * Hash we point the browser to when we boot the app
   * and there is no deep-link provided
   * @type {string|Function}
   */
  let rootHash;

  /**
   * Boot request will fire before app start
   * can be used to execute some global logic
   * and can be configured
   */
  let bootRequest;

  /**
   * Flag if we need to update the browser location hash.
   * Router can work without.
   * @type {boolean}
   */
  let updateHash = true;

  /**
   * Will be called before a route starts, can be overridden
   * via routes config
   * @param from - route we came from
   * @param to - route we navigate to
   * @returns {Promise<*>}
   */
  // eslint-disable-next-line
  let beforeEachRoute = async (from, to) => {
    return true;
  };

  /**
   *  * Will be called after a navigate successfully resolved,
   * can be overridden via routes config
   */
  let afterEachRoute = () => {};

  /**
   * All configured routes
   * @type {Map<string, object>}
   */
  let routes$1 = new Map();

  /**
   * Store all page components per route
   * @type {Map<string, object>}
   */
  let components = new Map();

  /**
   * Flag if router has been initialised
   * @type {boolean}
   */
  let initialised = false;

  /**
   * Current page being rendered on screen
   * @type {null}
   */
  let activePage = null;
  let activeHash;
  let activeRoute;

  /**
   *  During the process of a navigation request a new
   *  request can start, to prevent unwanted behaviour
   *  the navigate()-method stores the last accepted hash
   *  so we can invalidate any prior requests
   */
  let lastAcceptedHash;

  /**
   * With on()-data providing behaviour the Router forced the App
   * in a Loading state. When the data-provider resolves we want to
   * change the state back to where we came from
   */
  let previousState;
  const mixin = app => {
    // by default the Router Baseclass provides the component
    // reference in which we store our pages
    if (app.pages) {
      pagesHost = app.pages.childList;
    }
    // if the app is using widgets we grab refs
    // and hide all the widgets
    if (app.widgets && app.widgets.children) {
      widgetsHost = app.widgets.childList;
      // hide all widgets on boot
      widgetsHost.forEach(w => w.visible = false);
    }
    app._handleBack = e => {
      step(-1);
      e.preventDefault();
    };
  };
  const bootRouter = (config, instance) => {
    let {
      appInstance,
      routes
    } = config;

    // if instance is provided and it's and Lightning Component instance
    if (instance && isPage(instance)) {
      app = instance;
    }
    if (!app) {
      app = appInstance || AppInstance;
    }
    application = app.application;
    pagesHost = application.childList;
    stage = app.stage;
    routerConfig = getConfigMap();
    mixin(app);
    if (isArray(routes)) {
      setup(config);
    } else if (isFunction(routes)) {
      console.warn('[Router]: Calling Router.route() directly is deprecated.');
      console.warn('Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };
  const setup = config => {
    if (!initialised) {
      init$2(config);
    }
    config.routes.forEach(r => {
      const path = cleanHash(r.path);
      if (!routeExists(path)) {
        const route = createRoute(r);
        routes$1.set(path, route);
        // if route has a configured component property
        // we store it in a different map to simplify
        // the creating and destroying per route
        if (route.component) {
          let type = route.component;
          if (isComponentConstructor(type)) {
            if (!routerConfig.get('lazyCreate')) {
              type = createComponent(stage, type);
              pagesHost.a(type);
            }
          }
          components.set(path, type);
        }
      } else {
        console.error("".concat(path, " already exists in routes configuration"));
      }
    });
  };
  const init$2 = config => {
    rootHash = config.root;
    if (isFunction(config.boot)) {
      bootRequest = config.boot;
    }
    if (isBoolean(config.updateHash)) {
      updateHash = config.updateHash;
    }
    if (isFunction(config.beforeEachRoute)) {
      beforeEachRoute = config.beforeEachRoute;
    }
    if (isFunction(config.afterEachRoute)) {
      afterEachRoute = config.afterEachRoute;
    }
    if (config.bootComponent) {
      console.warn('[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes');
      console.warn('[Router]: setting { bootComponent } property will be deprecated in a future release');
      if (isPage(config.bootComponent)) {
        config.routes.push({
          path: '$',
          component: config.bootComponent,
          // we try to assign the bootRequest as after data-provider
          // so it will behave as any other component
          after: bootRequest || null,
          options: {
            preventStorage: true
          }
        });
      } else {
        console.error("[Router]: ".concat(config.bootComponent, " is not a valid boot component"));
      }
    }
    initialised = true;
  };
  const storeComponent = (route, type) => {
    if (components.has(route)) {
      components.set(route, type);
    }
  };
  const getComponent = route => {
    if (components.has(route)) {
      return components.get(route);
    }
    return null;
  };
  /**
   * Test if router needs to update browser location hash
   * @returns {boolean}
   */
  const mustUpdateLocationHash = () => {
    if (!routerConfig || !routerConfig.size) {
      return false;
    }
    // we need support to either turn change hash off
    // per platform or per app
    const updateConfig = routerConfig.get('updateHash');
    return !(isBoolean(updateConfig) && !updateConfig || isBoolean(updateHash) && !updateHash);
  };

  /**
   * Will be called when a new navigate() request has completed
   * and has not been expired due to it's async nature
   * @param request
   */
  const onRequestResolved = request => {
    const hash = request.hash;
    const route = request.route;
    const register = request.register;
    const page = request.page;

    // clean up history if modifier is set
    if (getOption(route.options, 'clearHistory')) {
      setHistory([]);
    } else if (hash && !isWildcard.test(route.path)) {
      updateHistory(request);
    }

    // we only update the stackLocation if a route
    // is not expired before it resolves
    storeComponent(route.path, page);
    if (request.isSharedInstance || !request.isCreated) {
      emit$4(page, 'changed');
    } else if (request.isCreated) {
      emit$4(page, 'mounted');
    }

    // only update widgets if we have a host
    if (widgetsHost) {
      updateWidgets(route.widgets, page);
    }

    // we want to clean up if there is an
    // active page that is not being shared
    // between current and previous route
    if (getActivePage() && !request.isSharedInstance) {
      cleanUp(activePage, request);
    }

    // provide history object to active page
    if (register.get(symbols.historyState) && isFunction(page.historyState)) {
      page.historyState(register.get(symbols.historyState));
    }
    setActivePage(page);
    activeHash = request.hash;
    activeRoute = route.path;

    // cleanup all cancelled requests
    for (let request of navigateQueue.values()) {
      if (request.isCancelled && request.hash) {
        navigateQueue.delete(request.hash);
      }
    }
    afterEachRoute(request);
    Log.info('[route]:', route.path);
    Log.info('[hash]:', hash);
  };
  const cleanUp = (page, request) => {
    const route = activeRoute;
    const register = request.register;
    const lazyDestroy = routerConfig.get('lazyDestroy');
    const destroyOnBack = routerConfig.get('destroyOnHistoryBack');
    const keepAlive = register.get('keepAlive');
    const isFromHistory = register.get(symbols.backtrack);
    let doCleanup = false;

    // if this request is executed due to a step back in history
    // and we have configured to destroy active page when we go back
    // in history or lazyDestory is enabled
    if (isFromHistory && (destroyOnBack || lazyDestroy)) {
      doCleanup = true;
    }

    // clean up if lazyDestroy is enabled and the keepAlive flag
    // in navigation register is false
    if (lazyDestroy && !keepAlive) {
      doCleanup = true;
    }

    // if the current and new request share the same route blueprint
    if (activeRoute === request.route.path) {
      doCleanup = true;
    }
    if (doCleanup) {
      // grab original class constructor if
      // statemachine routed else store constructor
      storeComponent(route, page._routedType || page.constructor);

      // actual remove of page from memory
      pagesHost.remove(page);

      // force texture gc() if configured
      // so we can cleanup textures in the same tick
      if (routerConfig.get('gcOnUnload')) {
        stage.gc();
      }
    } else {
      // If we're not removing the page we need to
      // reset it's properties
      page.patch({
        x: 0,
        y: 0,
        scale: 1,
        alpha: 1,
        visible: false
      });
    }
  };
  const getActiveHash = () => {
    return activeHash;
  };
  const setActivePage = page => {
    activePage = page;
  };
  const getActivePage = () => {
    return activePage;
  };
  const getActiveRoute = () => {
    return activeRoute;
  };
  const getLastHash = () => {
    return lastAcceptedHash;
  };
  const setLastHash = hash => {
    lastAcceptedHash = hash;
  };
  const getPreviousState = () => {
    return previousState;
  };
  const routeExists = key => {
    return routes$1.has(key);
  };
  const getRootHash = () => {
    return rootHash;
  };
  const getBootRequest = () => {
    return bootRequest;
  };
  const getRouterConfig = () => {
    return routerConfig;
  };
  const getRoutes = () => {
    return routes$1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const isFunction = v => {
    return typeof v === 'function';
  };
  const isObject = v => {
    return typeof v === 'object' && v !== null;
  };
  const isBoolean = v => {
    return typeof v === 'boolean';
  };
  const isPage = v => {
    if (v instanceof lng$1.Element || isComponentConstructor(v)) {
      return true;
    }
    return false;
  };
  const isComponentConstructor = type => {
    return type.prototype && 'isComponent' in type.prototype;
  };
  const isArray = v => {
    return Array.isArray(v);
  };
  const ucfirst = v => {
    return "".concat(v.charAt(0).toUpperCase()).concat(v.slice(1));
  };
  const isString = v => {
    return typeof v === 'string';
  };
  const isPromise = method => {
    let result;
    if (isFunction(method)) {
      try {
        result = method.apply(null);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    return isObject(result) && isFunction(result.then);
  };
  const cleanHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return hash.replace(/^#/, '').replace(/\/+$/, '');
  };
  const getConfigMap = () => {
    const routerSettings = Settings$2.get('platform', 'router');
    const isObj = isObject(routerSettings);
    return ['backtrack', 'gcOnUnload', 'destroyOnHistoryBack', 'lazyCreate', 'lazyDestroy', 'reuseInstance', 'autoRestoreRemote', 'numberNavigation', 'updateHash', 'storeSameHash'].reduce((config, key) => {
      config.set(key, isObj ? routerSettings[key] : Settings$2.get('platform', key));
      return config;
    }, new Map());
  };
  const getQueryStringParams = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActiveHash();
    const resumeHash = getResumeHash();
    if ((hash === '$' || !hash) && resumeHash) {
      if (isString(resumeHash)) {
        hash = resumeHash;
      }
    }
    let parse = '';
    const getQuery = /([?&].*)/;
    const matches = getQuery.exec(hash);
    const params = {};
    if (document.location && document.location.search) {
      parse = document.location.search;
    }
    if (matches && matches.length) {
      let hashParams = matches[1];
      if (parse) {
        // if location.search is not empty we
        // remove the leading ? to create a
        // valid string
        hashParams = hashParams.replace(/^\?/, '');
        // we parse hash params last so they we can always
        // override search params with hash params
        parse = "".concat(parse, "&").concat(hashParams);
      } else {
        parse = hashParams;
      }
    }
    if (parse) {
      const urlParams = new URLSearchParams(parse);
      for (const [key, value] of urlParams.entries()) {
        params[key] = value;
      }
      return params;
    } else {
      return false;
    }
  };
  const objectToQueryString = obj => {
    if (!isObject(obj)) {
      return '';
    }
    return '?' + Object.keys(obj).map(key => {
      return "".concat(key, "=").concat(obj[key]);
    }).join('&');
  };
  const symbols = {
    route: Symbol('route'),
    hash: Symbol('hash'),
    store: Symbol('store'),
    fromHistory: Symbol('fromHistory'),
    expires: Symbol('expires'),
    resume: Symbol('resume'),
    backtrack: Symbol('backtrack'),
    historyState: Symbol('historyState'),
    queryParams: Symbol('queryParams')
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const dataHooks = {
    on: request => {
      app.state || '';
      app._setState('Loading');
      return execProvider(request);
    },
    before: request => {
      return execProvider(request);
    },
    after: request => {
      try {
        execProvider(request, true);
      } catch (e) {
        // for now we fail silently
      }
      return Promise.resolve();
    }
  };
  const execProvider = (request, emitProvided) => {
    const route = request.route;
    const provider = route.provider;
    const expires = route.cache ? route.cache * 1000 : 0;
    const params = addPersistData(request);
    return provider.request(request.page, {
      ...params
    }).then(() => {
      request.page[symbols.expires] = Date.now() + expires;
      if (emitProvided) {
        emit$4(request.page, 'dataProvided');
      }
    }).catch(e => {
      request.page[symbols.expires] = Date.now();
      throw e;
    });
  };
  const addPersistData = _ref => {
    let {
      page,
      route,
      hash,
      register = new Map()
    } = _ref;
    const urlValues = getValuesFromHash(hash, route.path);
    const queryParams = getQueryStringParams(hash);
    const pageData = new Map([...urlValues, ...register]);
    const params = {};

    // make dynamic url data available to the page
    // as instance properties
    for (let [name, value] of pageData) {
      params[name] = value;
    }
    if (queryParams) {
      params[symbols.queryParams] = queryParams;
    }

    // check navigation register for persistent data
    if (register.size) {
      const obj = {};
      for (let [k, v] of register) {
        obj[k] = v;
      }
      page.persist = obj;
    }

    // make url data and persist data available
    // via params property
    page.params = params;
    emit$4(page, ['urlParams'], params);
    return params;
  };

  /**
   * Test if page passed cache-time
   * @param page
   * @returns {boolean}
   */
  const isPageExpired = page => {
    if (!page[symbols.expires]) {
      return false;
    }
    const expires = page[symbols.expires];
    const now = Date.now();
    return now >= expires;
  };
  const hasProvider = path => {
    if (routeExists(path)) {
      const record = routes$1.get(path);
      return !!record.provider;
    }
    return false;
  };
  const getProvider = route => {
    // @todo: fix, route already is passed in
    if (routeExists(route.path)) {
      const {
        provider
      } = routes$1.get(route.path);
      return {
        type: provider.type,
        provider: provider.request
      };
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const fade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        if (o) {
          o.visible = false;
        }
        resolve();
      });
    });
  };
  const crossFade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      if (o) {
        o.patch({
          smooth: {
            alpha: [0, {
              duration: 0.5,
              delay: 0.3
            }]
          }
        });
      }
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        resolve();
      });
    });
  };
  const moveOnAxes = (axis, direction, i, o) => {
    const bounds = axis === 'x' ? 1920 : 1080;
    return new Promise(resolve => {
      i.patch({
        ["".concat(axis)]: direction ? bounds * -1 : bounds,
        visible: true,
        smooth: {
          ["".concat(axis)]: [0, {
            duration: 0.4,
            delay: 0.2
          }]
        }
      });
      // out is optional
      if (o) {
        o.patch({
          ["".concat(axis)]: 0,
          smooth: {
            ["".concat(axis)]: [direction ? bounds : bounds * -1, {
              duration: 0.4,
              delay: 0.2
            }]
          }
        });
      }
      // resolve on y finish
      i.transition(axis).on('finish', () => {
        resolve();
      });
    });
  };
  const up = (i, o) => {
    return moveOnAxes('y', 0, i, o);
  };
  const down = (i, o) => {
    return moveOnAxes('y', 1, i, o);
  };
  const left = (i, o) => {
    return moveOnAxes('x', 0, i, o);
  };
  const right = (i, o) => {
    return moveOnAxes('x', 1, i, o);
  };
  var Transitions = {
    fade,
    crossFade,
    up,
    down,
    left,
    right
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * execute transition between new / old page and
   * toggle the defined widgets
   * @todo: platform override default transition
   * @param pageIn
   * @param pageOut
   */
  const executeTransition = function (pageIn) {
    let pageOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const transition = pageIn.pageTransition || pageIn.easing;
    const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
    const transitionsDisabled = getRouterConfig().get('disableTransitions');
    if (pageIn.easing) {
      console.warn('easing() method is deprecated and will be removed. Use pageTransition()');
    }

    // default behaviour is a visibility toggle
    if (!hasCustomTransitions || transitionsDisabled) {
      pageIn.visible = true;
      if (pageOut) {
        pageOut.visible = false;
      }
      return Promise.resolve();
    }
    if (transition) {
      let type;
      try {
        type = transition.call(pageIn, pageIn, pageOut);
      } catch (e) {
        type = 'crossFade';
      }
      if (isPromise(type)) {
        return type;
      }
      if (isString(type)) {
        const fn = Transitions[type];
        if (fn) {
          return fn(pageIn, pageOut);
        }
      }

      // keep backwards compatible for now
      if (pageIn.smoothIn) {
        // provide a smooth function that resolves itself
        // on transition finish
        const smooth = function (p, v) {
          let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return new Promise(resolve => {
            pageIn.visible = true;
            pageIn.setSmooth(p, v, args);
            pageIn.transition(p).on('finish', () => {
              resolve();
            });
          });
        };
        return pageIn.smoothIn({
          pageIn,
          smooth
        });
      }
    }
    return Transitions.crossFade(pageIn, pageOut);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * The actual loading of the component
   * */
  const load = async request => {
    let expired = false;
    try {
      request = await loader$4(request);
      if (request && !request.isCancelled) {
        // in case of on() providing we need to reset
        // app state;
        if (app.state === 'Loading') {
          if (getPreviousState() === 'Widgets') ; else {
            app._setState('');
          }
        }
        // Do page transition if instance
        // is not shared between the routes
        if (!request.isSharedInstance && !request.isCancelled) {
          await executeTransition(request.page, getActivePage());
        }
      } else {
        expired = true;
      }
      // on expired we only cleanup
      if (expired || request.isCancelled) {
        Log.debug('[router]:', "Rejected ".concat(request.hash, " because route to ").concat(getLastHash(), " started"));
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
      } else {
        onRequestResolved(request);
        // resolve promise
        return request.page;
      }
    } catch (request) {
      if (!request.route) {
        console.error(request);
      } else if (!expired) {
        // @todo: revisit
        const {
          route
        } = request;
        // clean up history if modifier is set
        if (getOption(route.options, 'clearHistory')) {
          setHistory([]);
        } else if (!isWildcard.test(route.path)) {
          updateHistory(request);
        }
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
        handleError(request);
      }
    }
  };
  const loader$4 = async request => {
    const route = request.route;
    const hash = request.hash;
    const register = request.register;

    // todo: grab from Route instance
    let type = getComponent(route.path);
    let isConstruct = isComponentConstructor(type);
    let provide = false;

    // if it's an instance bt we're not coming back from
    // history we test if we can re-use this instance
    if (!isConstruct && !register.get(symbols.backtrack)) {
      if (!mustReuse(route)) {
        type = type.constructor;
        isConstruct = true;
      }
    }

    // If page is Lightning Component instance
    if (!isConstruct) {
      request.page = type;
      // if we have have a data route for current page
      if (hasProvider(route.path)) {
        if (isPageExpired(type) || type[symbols.hash] !== hash) {
          provide = true;
        }
      }
      let currentRoute = getActivePage() && getActivePage()[symbols.route];
      // if the new route is equal to the current route it means that both
      // route share the Component instance and stack location / since this case
      // is conflicting with the way before() and after() loading works we flag it,
      // and check platform settings in we want to re-use instance
      if (route.path === currentRoute) {
        request.isSharedInstance = true;
        // since we're re-using the instance we must attach
        // historyState to the request to prevent it from
        // being overridden.
        if (isFunction(request.page.historyState)) {
          request.copiedHistoryState = request.page.historyState();
        }
      }
    } else {
      request.page = createComponent(stage, type);
      pagesHost.a(request.page);
      // test if need to request data provider
      if (hasProvider(route.path)) {
        provide = true;
      }
      request.isCreated = true;
    }

    // we store hash and route as properties on the page instance
    // that way we can easily calculate new behaviour on page reload
    request.page[symbols.hash] = hash;
    request.page[symbols.route] = route.path;
    try {
      if (provide) {
        // extract attached data-provider for route
        // we're processing
        const {
          type: loadType,
          provider
        } = getProvider(route);

        // update running request
        request.provider = provider;
        request.providerType = loadType;
        await dataHooks[loadType](request);

        // we early exit if the current request is expired
        if (hash !== getLastHash()) {
          return false;
        } else {
          if (request.providerType !== 'after') {
            emit$4(request.page, 'dataProvided');
          }
          // resolve promise
          return request;
        }
      } else {
        addPersistData(request);
        return request;
      }
    } catch (e) {
      request.error = e;
      return Promise.reject(request);
    }
  };
  const handleError = request => {
    if (request && request.error) {
      console.error(request.error);
    } else if (request) {
      Log.error(request);
    }
    if (request.page && routeExists('!')) {
      navigate('!', {
        request
      }, false);
    }
  };
  const mustReuse = route => {
    const opt = getOption(route.options, 'reuseInstance');
    const config = routerConfig.get('reuseInstance');

    // route always has final decision
    if (isBoolean(opt)) {
      return opt;
    }
    return !(isBoolean(config) && config === false);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class RoutedApp extends lng$1.Component {
    static _template() {
      return {
        Pages: {
          forceZIndexContext: true
        },
        /**
         * This is a default Loading page that will be made visible
         * during data-provider on() you CAN override in child-class
         */
        Loading: {
          rect: true,
          w: 1920,
          h: 1080,
          color: 0xff000000,
          visible: false,
          zIndex: 99,
          Label: {
            mount: 0.5,
            x: 960,
            y: 540,
            text: {
              text: 'Loading..'
            }
          }
        }
      };
    }
    static _states() {
      return [class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true;
        }
        $exit() {
          this.tag('Loading').visible = false;
        }
      }, class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget;

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus();
        }
        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget;
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget;
          this._refocus();
        }
        _handleKey() {
          const restoreFocus = routerConfig.get('autoRestoreRemote');
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!isBoolean(restoreFocus) || restoreFocus === true) {
            Router.focusPage();
          }
        }
      }];
    }

    /**
     * Return location where pages need to be stored
     */
    get pages() {
      return this.tag('Pages');
    }

    /**
     * Tell router where widgets are stored
     */
    get widgets() {
      return this.tag('Widgets');
    }

    /**
     * we MUST register _handleBack method so the Router
     * can override it
     * @private
     */
    _handleBack() {}

    /**
     * We MUST return Router.activePage() so the new Page
     * can listen to the remote-control.
     */
    _getFocused() {
      return Router.getActivePage();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
  rouThor ==[x]
   */
  let navigateQueue = new Map();
  let forcedHash = '';
  let resumeHash = '';

  /**
   * Start routing the app
   * @param config - route config object
   * @param instance - instance of the app
   */
  const startRouter = (config, instance) => {
    bootRouter(config, instance);
    registerListener$1();
    start();
  };

  // start translating url
  const start = () => {
    let hash = (getHash$1() || '').replace(/^#/, '');
    const bootKey = '$';
    const params = getQueryStringParams(hash);
    const bootRequest = getBootRequest();
    const rootHash = getRootHash();
    const isDirectLoad = hash.indexOf(bootKey) !== -1;

    // prevent direct reload of wildcard routes
    // expect bootComponent
    if (isWildcard.test(hash) && hash !== bootKey) {
      hash = '';
    }

    // store resume point for manual resume
    resumeHash = isDirectLoad ? rootHash : hash || rootHash;
    const ready = () => {
      if (!hash && rootHash) {
        if (isString(rootHash)) {
          navigate(rootHash);
        } else if (isFunction(rootHash)) {
          rootHash().then(res => {
            if (isObject(res)) {
              navigate(res.path, res.params);
            } else {
              navigate(res);
            }
          });
        }
      } else {
        queue(hash);
        handleHashChange().then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    };
    if (routeExists(bootKey)) {
      if (hash && !isDirectLoad) {
        if (!getRouteByHash(hash)) {
          navigate('*', {
            failedHash: hash
          });
          return;
        }
      }
      navigate(bootKey, {
        resume: resumeHash,
        reload: bootKey === hash
      }, false);
    } else if (isFunction(bootRequest)) {
      bootRequest(params).then(() => {
        ready();
      }).catch(e => {
        handleBootError(e);
      });
    } else {
      ready();
    }
  };
  const handleBootError = e => {
    if (routeExists('!')) {
      navigate('!', {
        request: {
          error: e
        }
      });
    } else {
      console.error(e);
    }
  };

  /**
   * start a new request
   * @param url
   * @param args
   * @param store
   */
  const navigate = function (url) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    if (isObject(url)) {
      url = getHashByName(url);
      if (!url) {
        return;
      }
    }
    let hash = getHash$1();
    if (!mustUpdateLocationHash() && forcedHash) {
      hash = forcedHash;
    }
    if (hash.replace(/^#/, '') !== url) {
      // push request in the queue
      queue(url, args, store);
      setHash(url);
      if (!mustUpdateLocationHash()) {
        forcedHash = url;
        handleHashChange(url).then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    } else if (args.reload) {
      // push request in the queue
      queue(url, args, store);
      handleHashChange(url).then(() => {
        app._refocus();
      }).catch(e => {
        console.error(e);
      });
    }
  };
  const queue = function (hash) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    hash = cleanHash(hash);
    if (!navigateQueue.has(hash)) {
      for (let request of navigateQueue.values()) {
        request.cancel();
      }
      const request = createRequest(hash, args, store);
      navigateQueue.set(decodeURIComponent(hash), request);
      return request;
    }
    return false;
  };

  /**
   * Handle change of hash
   * @param override
   * @returns {Promise<void>}
   */
  const handleHashChange = async override => {
    const hash = cleanHash(override || getHash$1());
    const queueId = decodeURIComponent(hash);
    let request = navigateQueue.get(queueId);

    // handle hash updated manually
    if (!request && !navigateQueue.size) {
      request = queue(hash);
    }
    const route = getRouteByHash(hash);
    if (!route) {
      if (routeExists('*')) {
        navigate('*', {
          failedHash: hash
        });
      } else {
        console.error("Unable to navigate to: ".concat(hash));
      }
      return;
    }

    // update current processed request
    request.hash = hash;
    request.route = route;
    let result = await beforeEachRoute(getActiveHash(), request);

    // test if a local hook is configured for the route
    if (result && route.beforeNavigate) {
      result = await route.beforeNavigate(getActiveHash(), request);
    }
    if (isBoolean(result)) {
      // only if resolve value is explicitly true
      // we continue the current route request
      if (result) {
        return resolveHashChange(request);
      }
    } else {
      // if navigation guard didn't return true
      // we cancel the current request
      request.cancel();
      navigateQueue.delete(queueId);
      if (isString(result)) {
        navigate(result);
      } else if (isObject(result)) {
        let store = true;
        if (isBoolean(result.store)) {
          store = result.store;
        }
        navigate(result.path, result.params, store);
      }
    }
  };

  /**
   * Continue processing the hash change if not blocked
   * by global or local hook
   * @param request - {}
   */
  const resolveHashChange = request => {
    const hash = request.hash;
    const route = request.route;
    const queueId = decodeURIComponent(hash);
    // store last requested hash so we can
    // prevent a route that resolved later
    // from displaying itself
    setLastHash(hash);
    if (route.path) {
      const component = getComponent(route.path);
      // if a hook is provided for the current route
      if (isFunction(route.hook)) {
        const urlParams = getValuesFromHash(hash, route.path);
        const params = {};
        for (const key of urlParams.keys()) {
          params[key] = urlParams.get(key);
        }
        route.hook(app, {
          ...params
        });
      }
      // if there is a component attached to the route
      if (component) {
        // force page to root state to prevent shared state issues
        const activePage = getActivePage();
        if (activePage) {
          const keepAlive = keepActivePageAlive(getActiveRoute(), request);
          if (activePage && route.path === getActiveRoute() && !keepAlive) {
            activePage._setState('');
          }
        }
        if (isPage(component)) {
          load(request).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        } else {
          // of the component is not a constructor
          // or a Component instance we can assume
          // that it's a dynamic import
          component().then(contents => {
            return contents.default;
          }).then(module => {
            storeComponent(route.path, module);
            return load(request);
          }).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        }
      } else {
        navigateQueue.delete(queueId);
      }
    }
  };

  /**
   * Directional step in history
   * @param level
   */
  const step = function () {
    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (!level || isNaN(level)) {
      return false;
    }
    const history = getHistory();
    // for now we only support negative numbers
    level = Math.abs(level);

    // we can't step back past the amount
    // of history entries
    if (level > history.length) {
      if (isFunction(app._handleAppClose)) {
        return app._handleAppClose();
      }
      return app.application.closeApp();
    } else if (history.length) {
      // for now we only support history back
      const route = history.splice(history.length - level, level)[0];
      // store changed history
      setHistory(history);
      return navigate(route.hash, {
        [symbols.backtrack]: true,
        [symbols.historyState]: route.state
      }, false);
    } else if (routerConfig.get('backtrack')) {
      const hashLastPart = /(\/:?[\w%\s-]+)$/;
      let hash = stripRegex(getHash$1());
      let floor = getFloor(hash);

      // test if we got deep-linked
      if (floor > 1) {
        while (floor--) {
          // strip of last part
          hash = hash.replace(hashLastPart, '');
          // if we have a configured route
          // we navigate to it
          if (getRouteByHash(hash)) {
            return navigate(hash, {
              [symbols.backtrack]: true
            }, false);
          }
        }
      }
    }
    return false;
  };

  /**
   * Resume Router's page loading process after
   * the BootComponent became visible;
   */
  const resume = () => {
    if (isString(resumeHash)) {
      navigate(resumeHash, false);
      resumeHash = '';
    } else if (isFunction(resumeHash)) {
      resumeHash().then(res => {
        resumeHash = '';
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    } else {
      console.warn('[Router]: resume() called but no hash found');
    }
  };

  /**
   * Force reload active hash
   */
  const reload = () => {
    if (!isNavigating()) {
      const hash = getActiveHash();
      navigate(hash, {
        reload: true
      }, false);
    }
  };

  /**
   * Query if the Router is still processing a Request
   * @returns {boolean}
   */
  const isNavigating = () => {
    if (navigateQueue.size) {
      let isProcessing = false;
      for (let request of navigateQueue.values()) {
        if (!request.isCancelled) {
          isProcessing = true;
        }
      }
      return isProcessing;
    }
    return false;
  };
  const getResumeHash = () => {
    return resumeHash;
  };

  /**
   * By default we return the location hash
   * @returns {string}
   */
  let getHash$1 = () => {
    return document.location.hash;
  };

  /**
   * Update location hash
   * @param url
   */
  let setHash = url => {
    document.location.hash = url;
  };

  /**
   * This can be called from the platform / bootstrapper to override
   * the default getting and setting of the hash
   * @param config
   */
  const initRouter = config => {
    if (config.getHash) {
      getHash$1 = config.getHash;
    }
    if (config.setHash) {
      setHash = config.setHash;
    }
  };

  /**
   * On hash change we start processing
   */
  const registerListener$1 = () => {
    Registry.addEventListener(window, 'hashchange', async () => {
      if (mustUpdateLocationHash()) {
        try {
          await handleHashChange();
        } catch (e) {
          console.error(e);
        }
      }
    });
  };

  /**
   * Navigate to root hash
   */
  const root = () => {
    const rootHash = getRootHash();
    if (isString(rootHash)) {
      navigate(rootHash);
    } else if (isFunction(rootHash)) {
      rootHash().then(res => {
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    }
  };

  // export API
  var Router = {
    startRouter,
    navigate,
    resume,
    step,
    go: step,
    back: step.bind(null, -1),
    activePage: getActivePage,
    getActivePage() {
      // warning
      return getActivePage();
    },
    getActiveRoute,
    getActiveHash,
    focusWidget,
    getActiveWidget,
    restoreFocus,
    isNavigating,
    getHistory,
    setHistory,
    getHistoryState,
    replaceHistoryState,
    getQueryStringParams,
    reload,
    symbols,
    App: RoutedApp,
    // keep backwards compatible
    focusPage: restoreFocus,
    root: root,
    /**
     * Deprecated api methods
     */
    setupRoutes() {
      console.warn('Router: setupRoutes is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    on() {
      console.warn('Router.on() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    before() {
      console.warn('Router.before() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    after() {
      console.warn('Router.after() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const defaultChannels = [{
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(),
      // started 5 minutes ago
      duration: 60 * 30,
      // 30 minutes
      ageRating: 0
    }
  }, {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(),
      // started 20 minutes ago
      duration: 60 * 45,
      // 45 minutes
      ageRating: 18
    }
  }, {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(),
      // started 10 minutes ago
      duration: 60 * 60,
      // 1 hour
      ageRating: 10
    }
  }];
  const channels = () => Settings$2.get('platform', 'tv', defaultChannels);
  const randomChannel = () => channels()[~~(channels.length * Math.random())];

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let currentChannel;
  const callbacks = {};
  const emit$3 = function (event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    callbacks[event] && callbacks[event].forEach(cb => {
      cb.apply(null, args);
    });
  };

  // local mock methods
  let methods = {
    getChannel() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        if (currentChannel) {
          const channel = {
            ...currentChannel
          };
          delete channel.program;
          resolve(channel);
        } else {
          reject('No channel found');
        }
      });
    },
    getProgram() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        currentChannel.program ? resolve(currentChannel.program) : reject('No program found');
      });
    },
    setChannel(number) {
      return new Promise((resolve, reject) => {
        if (number) {
          const newChannel = channels().find(c => c.number === number);
          if (newChannel) {
            currentChannel = newChannel;
            const channel = {
              ...currentChannel
            };
            delete channel.program;
            emit$3('channelChange', channel);
            resolve(channel);
          } else {
            reject('Channel not found');
          }
        } else {
          reject('No channel number supplied');
        }
      });
    }
  };
  const initTV = config => {
    methods = {};
    if (config.getChannel && typeof config.getChannel === 'function') {
      methods.getChannel = config.getChannel;
    }
    if (config.getProgram && typeof config.getProgram === 'function') {
      methods.getProgram = config.getProgram;
    }
    if (config.setChannel && typeof config.setChannel === 'function') {
      methods.setChannel = config.setChannel;
    }
    if (config.emit && typeof config.emit === 'function') {
      config.emit(emit$3);
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initPurchase = config => {
    if (config.billingUrl) config.billingUrl;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class PinInput extends lng$1.Component {
    static _template() {
      return {
        w: 120,
        h: 150,
        rect: true,
        color: 0xff949393,
        alpha: 0.5,
        shader: {
          type: lng$1.shaders.RoundedRectangle,
          radius: 10
        },
        Nr: {
          w: w => w,
          y: 24,
          text: {
            text: '',
            textColor: 0xff333333,
            fontSize: 80,
            textAlign: 'center',
            verticalAlign: 'middle'
          }
        }
      };
    }
    set index(v) {
      this.x = v * (120 + 24);
    }
    set nr(v) {
      this._timeout && clearTimeout(this._timeout);
      if (v) {
        this.setSmooth('alpha', 1);
      } else {
        this.setSmooth('alpha', 0.5);
      }
      this.tag('Nr').patch({
        text: {
          text: v && v.toString() || '',
          fontSize: v === '*' ? 120 : 80
        }
      });
      if (v && v !== '*') {
        this._timeout = setTimeout(() => {
          this._timeout = null;
          this.nr = '*';
        }, 750);
      }
    }
  }
  class PinDialog extends lng$1.Component {
    static _template() {
      return {
        zIndex: 1,
        w: w => w,
        h: h => h,
        rect: true,
        color: 0xdd000000,
        alpha: 0.000001,
        Dialog: {
          w: 648,
          h: 320,
          y: h => (h - 320) / 2,
          x: w => (w - 648) / 2,
          rect: true,
          color: 0xdd333333,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 10
          },
          Info: {
            y: 24,
            x: 48,
            text: {
              text: 'Please enter your PIN',
              fontSize: 32
            }
          },
          Msg: {
            y: 260,
            x: 48,
            text: {
              text: '',
              fontSize: 28,
              textColor: 0xffffffff
            }
          },
          Code: {
            x: 48,
            y: 96
          }
        }
      };
    }
    _init() {
      const children = [];
      for (let i = 0; i < 4; i++) {
        children.push({
          type: PinInput,
          index: i
        });
      }
      this.tag('Code').children = children;
    }
    get pin() {
      if (!this._pin) this._pin = '';
      return this._pin;
    }
    set pin(v) {
      if (v.length <= 4) {
        const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1);
        v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*');
        for (let i = 0; i < 4; i++) {
          this.tag('Code').children[i].nr = maskedPin[i] || '';
        }
        this._pin = v;
      }
    }
    get msg() {
      if (!this._msg) this._msg = '';
      return this._msg;
    }
    set msg(v) {
      this._timeout && clearTimeout(this._timeout);
      this._msg = v;
      if (this._msg) {
        this.tag('Msg').text = this._msg;
        this.tag('Info').setSmooth('alpha', 0.5);
        this.tag('Code').setSmooth('alpha', 0.5);
      } else {
        this.tag('Msg').text = '';
        this.tag('Info').setSmooth('alpha', 1);
        this.tag('Code').setSmooth('alpha', 1);
      }
      this._timeout = setTimeout(() => {
        this.msg = '';
      }, 2000);
    }
    _firstActive() {
      this.setSmooth('alpha', 1);
    }
    _handleKey(event) {
      if (this.msg) {
        this.msg = false;
      } else {
        const val = parseInt(event.key);
        if (val > -1) {
          this.pin += val;
        }
      }
    }
    _handleBack() {
      if (this.msg) {
        this.msg = false;
      } else {
        if (this.pin.length) {
          this.pin = this.pin.slice(0, this.pin.length - 1);
        } else {
          Pin.hide();
          this.resolve(false);
        }
      }
    }
    _handleEnter() {
      if (this.msg) {
        this.msg = false;
      } else {
        Pin.submit(this.pin).then(val => {
          this.msg = 'Unlocking ...';
          setTimeout(() => {
            Pin.hide();
          }, 1000);
          this.resolve(val);
        }).catch(e => {
          this.msg = e;
          this.reject(e);
        });
      }
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // only used during local development
  let unlocked = false;
  const contextItems = ['purchase', 'parental'];
  let submit = (pin, context) => {
    return new Promise((resolve, reject) => {
      if (pin.toString() === Settings$2.get('platform', 'pin', '0000').toString()) {
        unlocked = true;
        resolve(unlocked);
      } else {
        reject('Incorrect pin');
      }
    });
  };
  let check = context => {
    return new Promise(resolve => {
      resolve(unlocked);
    });
  };
  const initPin = config => {
    if (config.submit && typeof config.submit === 'function') {
      submit = config.submit;
    }
    if (config.check && typeof config.check === 'function') {
      check = config.check;
    }
  };
  let pinDialog = null;
  const contextCheck = context => {
    if (context === undefined) {
      Log.info('Please provide context explicitly');
      return contextItems[0];
    } else if (!contextItems.includes(context)) {
      Log.warn('Incorrect context provided');
      return false;
    }
    return context;
  };

  // Public API
  var Pin = {
    show() {
      return new Promise((resolve, reject) => {
        pinDialog = ApplicationInstance.stage.c({
          ref: 'PinDialog',
          type: PinDialog,
          resolve,
          reject
        });
        ApplicationInstance.childList.a(pinDialog);
        ApplicationInstance.focus = pinDialog;
      });
    },
    hide() {
      ApplicationInstance.focus = null;
      ApplicationInstance.children = ApplicationInstance.children.map(child => child !== pinDialog && child);
      pinDialog = null;
    },
    submit(pin, context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            submit(pin, context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    unlocked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    locked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(unlocked => resolve(!!!unlocked)).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let ApplicationInstance;
  var Launch = (App, appSettings, platformSettings, appData) => {
    initSettings$2(appSettings, platformSettings);
    initUtils(platformSettings);
    initStorage();
    // Initialize plugins
    if (platformSettings.plugins) {
      platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
      platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
      platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
      platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
      platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
      platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
      platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
    }
    const app = Application(App, appData, platformSettings);
    ApplicationInstance = new app(appSettings);
    return ApplicationInstance;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VideoTexture extends lng$1.Component {
    static _template() {
      return {
        Video: {
          alpha: 1,
          visible: false,
          pivot: 0.5,
          texture: {
            type: lng$1.textures.StaticTexture,
            options: {}
          }
        }
      };
    }
    set videoEl(v) {
      this._videoEl = v;
    }
    get videoEl() {
      return this._videoEl;
    }
    get videoView() {
      return this.tag('Video');
    }
    get videoTexture() {
      return this.videoView.texture;
    }
    get isVisible() {
      return this.videoView.alpha === 1 && this.videoView.visible === true;
    }
    _init() {
      this._createVideoTexture();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
      this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
      this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
    }
    start() {
      const stage = this.stage;
      this._lastTime = 0;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl;
            const currentTime = new Date().getTime();
            const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
            const frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
            const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoView.visible = true;
                this.videoTexture.options.w = this.videoEl.width;
                this.videoTexture.options.h = this.videoEl.height;
                const expectedAspectRatio = this.videoView.w / this.videoView.h;
                const realAspectRatio = this.videoEl.width / this.videoEl.height;
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoView.scaleY = 1;
                } else {
                  this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoView.scaleX = 1;
                }
              } catch (e) {
                Log.error('texImage2d video', e);
                this.stop();
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }
    stop() {
      const stage = this.stage;
      stage.removeListener('frameStart', this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoView.visible = false;
      if (this.videoTexture.options.source) {
        const gl = stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
    position(top, left) {
      this.videoView.patch({
        smooth: {
          x: left,
          y: top
        }
      });
    }
    size(width, height) {
      this.videoView.patch({
        smooth: {
          w: width,
          h: height
        }
      });
    }
    show() {
      this.videoView.setSmooth('alpha', 1);
    }
    hide() {
      this.videoView.setSmooth('alpha', 0);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let mediaUrl = url => url;
  let videoEl;
  let videoTexture;
  let metrics;
  let consumer$1;
  let precision = 1;
  let textureMode = false;
  const initVideoPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl = config.mediaUrl;
    }
  };

  // todo: add this in a 'Registry' plugin
  // to be able to always clean this up on app close
  let eventHandlers = {};
  const state$2 = {
    adsEnabled: false,
    playing: false,
    _playingAds: false,
    get playingAds() {
      return this._playingAds;
    },
    set playingAds(val) {
      if (this._playingAds !== val) {
        this._playingAds = val;
        fireOnConsumer$1(val === true ? 'AdStart' : 'AdEnd');
      }
    },
    skipTime: false,
    playAfterSeek: null
  };
  const hooks = {
    play() {
      state$2.playing = true;
    },
    pause() {
      state$2.playing = false;
    },
    seeked() {
      state$2.playAfterSeek === true && videoPlayerPlugin.play();
      state$2.playAfterSeek = null;
    },
    abort() {
      deregisterEventListeners();
    }
  };
  const withPrecision = val => Math.round(precision * val) + 'px';
  const fireOnConsumer$1 = (event, args) => {
    if (consumer$1) {
      consumer$1.fire('$videoPlayer' + event, args, videoEl.currentTime);
      consumer$1.fire('$videoPlayerEvent', event, args, videoEl.currentTime);
    }
  };
  const fireHook = (event, args) => {
    hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args);
  };
  let customLoader = null;
  let customUnloader = null;
  const loader$3 = (url, videoEl, config) => {
    return customLoader && typeof customLoader === 'function' ? customLoader(url, videoEl, config) : new Promise(resolve => {
      url = mediaUrl(url);
      videoEl.setAttribute('src', url);
      videoEl.load();
      resolve();
    });
  };
  const unloader = videoEl => {
    return customUnloader && typeof customUnloader === 'function' ? customUnloader(videoEl) : new Promise(resolve => {
      videoEl.removeAttribute('src');
      videoEl.load();
      resolve();
    });
  };
  const setupVideoTag = () => {
    const videoEls = document.getElementsByTagName('video');
    if (videoEls && videoEls.length) {
      return videoEls[0];
    } else {
      const videoEl = document.createElement('video');
      const platformSettingsWidth = Settings$2.get('platform', 'width') ? Settings$2.get('platform', 'width') : 1920;
      const platformSettingsHeight = Settings$2.get('platform', 'height') ? Settings$2.get('platform', 'height') : 1080;
      videoEl.setAttribute('id', 'video-player');
      videoEl.setAttribute('width', withPrecision(platformSettingsWidth));
      videoEl.setAttribute('height', withPrecision(platformSettingsHeight));
      videoEl.style.position = 'absolute';
      videoEl.style.zIndex = '1';
      videoEl.style.display = 'none';
      videoEl.style.visibility = 'hidden';
      videoEl.style.top = withPrecision(0);
      videoEl.style.left = withPrecision(0);
      videoEl.style.width = withPrecision(platformSettingsWidth);
      videoEl.style.height = withPrecision(platformSettingsHeight);
      document.body.appendChild(videoEl);
      return videoEl;
    }
  };
  const setUpVideoTexture = () => {
    if (!ApplicationInstance.tag('VideoTexture')) {
      const el = ApplicationInstance.stage.c({
        type: VideoTexture,
        ref: 'VideoTexture',
        zIndex: 0,
        videoEl
      });
      ApplicationInstance.childList.addAt(el, 0);
    }
    return ApplicationInstance.tag('VideoTexture');
  };
  const registerEventListeners = () => {
    Log.info('VideoPlayer', 'Registering event listeners');
    Object.keys(events$2).forEach(event => {
      const handler = e => {
        // Fire a metric for each event (if it exists on the metrics object)
        if (metrics && metrics[event] && typeof metrics[event] === 'function') {
          metrics[event]({
            currentTime: videoEl.currentTime
          });
        }
        // fire an internal hook
        fireHook(event, {
          videoElement: videoEl,
          event: e
        });

        // fire the event (with human friendly event name) to the consumer of the VideoPlayer
        fireOnConsumer$1(events$2[event], {
          videoElement: videoEl,
          event: e
        });
      };
      eventHandlers[event] = handler;
      videoEl.addEventListener(event, handler);
    });
  };
  const deregisterEventListeners = () => {
    Log.info('VideoPlayer', 'Deregistering event listeners');
    Object.keys(eventHandlers).forEach(event => {
      videoEl.removeEventListener(event, eventHandlers[event]);
    });
    eventHandlers = {};
  };
  const videoPlayerPlugin = {
    consumer(component) {
      consumer$1 = component;
    },
    loader(loaderFn) {
      customLoader = loaderFn;
    },
    unloader(unloaderFn) {
      customUnloader = unloaderFn;
    },
    position() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      videoEl.style.left = withPrecision(left);
      videoEl.style.top = withPrecision(top);
      if (textureMode === true) {
        videoTexture.position(top, left);
      }
    },
    size() {
      let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1920;
      let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1080;
      videoEl.style.width = withPrecision(width);
      videoEl.style.height = withPrecision(height);
      videoEl.width = parseFloat(videoEl.style.width);
      videoEl.height = parseFloat(videoEl.style.height);
      if (textureMode === true) {
        videoTexture.size(width, height);
      }
    },
    area() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1920;
      let bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1080;
      let left = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.position(top, left);
      this.size(right - left, bottom - top);
    },
    open(url) {
      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.canInteract) return;
      metrics = Metrics$5.media(url);
      this.hide();
      deregisterEventListeners();
      if (this.src == url) {
        this.clear().then(this.open(url, config));
      } else {
        const adConfig = {
          enabled: state$2.adsEnabled,
          duration: 300
        };
        if (config.videoId) {
          adConfig.caid = config.videoId;
        }
        Ads.get(adConfig, consumer$1).then(ads => {
          state$2.playingAds = true;
          ads.prerolls().then(() => {
            state$2.playingAds = false;
            loader$3(url, videoEl, config).then(() => {
              registerEventListeners();
              this.show();
              this.play();
            }).catch(e => {
              fireOnConsumer$1('error', {
                videoElement: videoEl,
                event: e
              });
            });
          });
        });
      }
    },
    reload() {
      if (!this.canInteract) return;
      const url = videoEl.getAttribute('src');
      this.close();
      this.open(url);
    },
    close() {
      Ads.cancel();
      if (state$2.playingAds) {
        state$2.playingAds = false;
        Ads.stop();
        // call self in next tick
        setTimeout(() => {
          this.close();
        });
      }
      if (!this.canInteract) return;
      this.clear();
      this.hide();
      deregisterEventListeners();
    },
    clear() {
      if (!this.canInteract) return;
      // pause the video first to disable sound
      this.pause();
      if (textureMode === true) videoTexture.stop();
      return unloader(videoEl).then(() => {
        fireOnConsumer$1('Clear', {
          videoElement: videoEl
        });
      });
    },
    play() {
      if (!this.canInteract) return;
      if (textureMode === true) videoTexture.start();
      executeAsPromise(videoEl.play, null, videoEl).catch(e => {
        fireOnConsumer$1('error', {
          videoElement: videoEl,
          event: e
        });
      });
    },
    pause() {
      if (!this.canInteract) return;
      videoEl.pause();
    },
    playPause() {
      if (!this.canInteract) return;
      this.playing === true ? this.pause() : this.play();
    },
    mute() {
      let muted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.canInteract) return;
      videoEl.muted = muted;
    },
    loop() {
      let looped = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      videoEl.loop = looped;
    },
    seek(time) {
      if (!this.canInteract) return;
      if (!this.src) return;
      // define whether should continue to play after seek is complete (in seeked hook)
      if (state$2.playAfterSeek === null) {
        state$2.playAfterSeek = !!state$2.playing;
      }
      // pause before actually seeking
      this.pause();
      // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
      videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
    },
    skip(seconds) {
      if (!this.canInteract) return;
      if (!this.src) return;
      state$2.skipTime = (state$2.skipTime || videoEl.currentTime) + seconds;
      easeExecution(() => {
        this.seek(state$2.skipTime);
        state$2.skipTime = false;
      }, 300);
    },
    show() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.show();
      } else {
        videoEl.style.display = 'block';
        videoEl.style.visibility = 'visible';
      }
    },
    hide() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.hide();
      } else {
        videoEl.style.display = 'none';
        videoEl.style.visibility = 'hidden';
      }
    },
    enableAds() {
      let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      state$2.adsEnabled = enabled;
    },
    /* Public getters */
    get duration() {
      return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
    },
    get currentTime() {
      return videoEl && videoEl.currentTime;
    },
    get muted() {
      return videoEl && videoEl.muted;
    },
    get looped() {
      return videoEl && videoEl.loop;
    },
    get src() {
      return videoEl && videoEl.getAttribute('src');
    },
    get playing() {
      return state$2.playing;
    },
    get playingAds() {
      return state$2.playingAds;
    },
    get canInteract() {
      // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
      return state$2.playingAds === false;
    },
    get top() {
      return videoEl && parseFloat(videoEl.style.top);
    },
    get left() {
      return videoEl && parseFloat(videoEl.style.left);
    },
    get bottom() {
      return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
    },
    get right() {
      return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
    },
    get width() {
      return videoEl && parseFloat(videoEl.style.width);
    },
    get height() {
      return videoEl && parseFloat(videoEl.style.height);
    },
    get visible() {
      if (textureMode === true) {
        return videoTexture.isVisible;
      } else {
        return videoEl && videoEl.style.display === 'block';
      }
    },
    get adsEnabled() {
      return state$2.adsEnabled;
    },
    // prefixed with underscore to indicate 'semi-private'
    // because it's not recommended to interact directly with the video element
    get _videoEl() {
      return videoEl;
    },
    get _consumer() {
      return consumer$1;
    }
  };
  var VideoPlayer = autoSetupMixin(videoPlayerPlugin, () => {
    precision = ApplicationInstance && ApplicationInstance.stage && ApplicationInstance.stage.getRenderPrecision() || precision;
    videoEl = setupVideoTag();
    textureMode = Settings$2.get('platform', 'textureMode', false);
    if (textureMode === true) {
      videoEl.setAttribute('crossorigin', 'anonymous');
      videoTexture = setUpVideoTexture();
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let consumer;
  let getAds = () => {
    // todo: enable some default ads during development, maybe from the settings.json
    return Promise.resolve({
      prerolls: [],
      midrolls: [],
      postrolls: []
    });
  };
  const initAds = config => {
    if (config.getAds) {
      getAds = config.getAds;
    }
  };
  const state$1 = {
    active: false
  };
  const playSlot = function () {
    let slot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return slot.reduce((promise, ad) => {
      return promise.then(() => {
        return playAd(ad);
      });
    }, Promise.resolve(null));
  };
  const playAd = ad => {
    return new Promise(resolve => {
      if (state$1.active === false) {
        Log.info('Ad', 'Skipping add due to inactive state');
        return resolve();
      }
      // is it safe to rely on videoplayer plugin already created the video tag?
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.style.display = 'block';
      videoEl.style.visibility = 'visible';
      videoEl.src = mediaUrl(ad.url);
      videoEl.load();
      let timeEvents = null;
      let timeout;
      const cleanup = () => {
        // remove all listeners
        Object.keys(handlers).forEach(handler => videoEl.removeEventListener(handler, handlers[handler]));
        resolve();
      };
      const handlers = {
        play() {
          Log.info('Ad', 'Play ad', ad.url);
          fireOnConsumer('Play', ad);
          sendBeacon(ad.callbacks, 'defaultImpression');
        },
        ended() {
          fireOnConsumer('Ended', ad);
          sendBeacon(ad.callbacks, 'complete');
          cleanup();
        },
        timeupdate() {
          if (!timeEvents && videoEl.duration) {
            // calculate when to fire the time based events (now that duration is known)
            timeEvents = {
              firstQuartile: videoEl.duration / 4,
              midPoint: videoEl.duration / 2,
              thirdQuartile: videoEl.duration / 4 * 3
            };
            Log.info('Ad', 'Calculated quartiles times', {
              timeEvents
            });
          }
          if (timeEvents && timeEvents.firstQuartile && videoEl.currentTime >= timeEvents.firstQuartile) {
            fireOnConsumer('FirstQuartile', ad);
            delete timeEvents.firstQuartile;
            sendBeacon(ad.callbacks, 'firstQuartile');
          }
          if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
            fireOnConsumer('MidPoint', ad);
            delete timeEvents.midPoint;
            sendBeacon(ad.callbacks, 'midPoint');
          }
          if (timeEvents && timeEvents.thirdQuartile && videoEl.currentTime >= timeEvents.thirdQuartile) {
            fireOnConsumer('ThirdQuartile', ad);
            delete timeEvents.thirdQuartile;
            sendBeacon(ad.callbacks, 'thirdQuartile');
          }
        },
        stalled() {
          fireOnConsumer('Stalled', ad);
          timeout = setTimeout(() => {
            cleanup();
          }, 5000); // make timeout configurable
        },
        canplay() {
          timeout && clearTimeout(timeout);
        },
        error() {
          fireOnConsumer('Error', ad);
          cleanup();
        },
        // this doesn't work reliably on sky box, moved logic to timeUpdate event
        // loadedmetadata() {
        //   // calculate when to fire the time based events (now that duration is known)
        //   timeEvents = {
        //     firstQuartile: videoEl.duration / 4,
        //     midPoint: videoEl.duration / 2,
        //     thirdQuartile: (videoEl.duration / 4) * 3,
        //   }
        // },
        abort() {
          cleanup();
        }
        // todo: pause, resume, mute, unmute beacons
      };
      // add all listeners
      Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]));
      videoEl.play();
    });
  };
  const sendBeacon = (callbacks, event) => {
    if (callbacks && callbacks[event]) {
      Log.info('Ad', 'Sending beacon', event, callbacks[event]);
      return callbacks[event].reduce((promise, url) => {
        return promise.then(() => fetch(url)
        // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
        // note: for fetch failed http responses don't throw an Error :)
        .then(response => {
          if (response.status === 200) {
            fireOnConsumer('Beacon' + event + 'Sent');
          } else {
            fireOnConsumer('Beacon' + event + 'Failed' + response.status);
          }
          Promise.resolve(null);
        }).catch(() => {
          Promise.resolve(null);
        }));
      }, Promise.resolve(null));
    } else {
      Log.info('Ad', 'No callback found for ' + event);
    }
  };
  const fireOnConsumer = (event, args) => {
    if (consumer) {
      consumer.fire('$ad' + event, args);
      consumer.fire('$adEvent', event, args);
    }
  };
  var Ads = {
    get(config, videoPlayerConsumer) {
      if (config.enabled === false) {
        return Promise.resolve({
          prerolls() {
            return Promise.resolve();
          }
        });
      }
      consumer = videoPlayerConsumer;
      return new Promise(resolve => {
        Log.info('Ad', 'Starting session');
        getAds(config).then(ads => {
          Log.info('Ad', 'API result', ads);
          resolve({
            prerolls() {
              if (ads.preroll) {
                state$1.active = true;
                fireOnConsumer('PrerollSlotImpression', ads);
                sendBeacon(ads.preroll.callbacks, 'slotImpression');
                return playSlot(ads.preroll.ads).then(() => {
                  fireOnConsumer('PrerollSlotEnd', ads);
                  sendBeacon(ads.preroll.callbacks, 'slotEnd');
                  state$1.active = false;
                });
              }
              return Promise.resolve();
            },
            midrolls() {
              return Promise.resolve();
            },
            postrolls() {
              return Promise.resolve();
            }
          });
        });
      });
    },
    cancel() {
      Log.info('Ad', 'Cancel Ad');
      state$1.active = false;
    },
    stop() {
      Log.info('Ad', 'Stop Ad');
      state$1.active = false;
      // fixme: duplication
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.pause();
      videoEl.removeAttribute('src');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScaledImageTexture extends lng$1.textures.ImageTexture {
    constructor(stage) {
      super(stage);
      this._scalingOptions = undefined;
    }
    set options(options) {
      this.resizeMode = this._scalingOptions = options;
    }
    _getLookupId() {
      return "".concat(this._src, "-").concat(this._scalingOptions.type, "-").concat(this._scalingOptions.w, "-").concat(this._scalingOptions.h);
    }
    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2023 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let ws = null;
  if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
  }
  var ws_1 = ws;
  const requestsQueue = {};
  const listeners$2 = {};
  var requestQueueResolver = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (data.id) {
      const request = requestsQueue[data.id];
      if (request) {
        if ('result' in data) request.resolve(data.result);else request.reject(data.error);
        delete requestsQueue[data.id];
      } else {
        console.log('no pending request found with id ' + data.id);
      }
    }
  };
  var notificationListener = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (!data.id && data.method) {
      const callbacks = listeners$2[data.method];
      if (callbacks && Array.isArray(callbacks) && callbacks.length) {
        callbacks.forEach(callback => {
          callback(data.params);
        });
      }
    }
  };
  const protocol = 'ws://';
  const host = 'localhost';
  const endpoint = '/jsonrpc';
  const port = 80;
  var makeWebsocketAddress = options => {
    return [options && options.protocol || protocol, options && options.host || host, ':' + (options && options.port || port), options && options.endpoint || endpoint, options && options.token ? '?token=' + options.token : null].join('');
  };
  const sockets = {};
  var connect = options => {
    return new Promise((resolve, reject) => {
      const socketAddress = makeWebsocketAddress(options);
      let socket = sockets[socketAddress];
      if (socket && socket.readyState === 1) return resolve(socket);
      if (socket && socket.readyState === 0) {
        const waitForOpen = () => {
          socket.removeEventListener('open', waitForOpen);
          resolve(socket);
        };
        return socket.addEventListener('open', waitForOpen);
      }
      if (socket == null) {
        if (options.debug) {
          console.log('Opening socket to ' + socketAddress);
        }
        socket = new ws_1(socketAddress, options && options.subprotocols || 'notification');
        sockets[socketAddress] = socket;
        socket.addEventListener('message', message => {
          if (options.debug) {
            console.log(' ');
            console.log('API REPONSE:');
            console.log(JSON.stringify(message.data, null, 2));
            console.log(' ');
          }
          requestQueueResolver(message.data);
        });
        socket.addEventListener('message', message => {
          notificationListener(message.data);
        });
        socket.addEventListener('error', () => {
          notificationListener({
            method: 'client.ThunderJS.events.error'
          });
          sockets[socketAddress] = null;
        });
        const handleConnectClosure = event => {
          sockets[socketAddress] = null;
          reject(event);
        };
        socket.addEventListener('close', handleConnectClosure);
        socket.addEventListener('open', () => {
          notificationListener({
            method: 'client.ThunderJS.events.connect'
          });
          socket.removeEventListener('close', handleConnectClosure);
          socket.addEventListener('close', () => {
            notificationListener({
              method: 'client.ThunderJS.events.disconnect'
            });
            sockets[socketAddress] = null;
          });
          resolve(socket);
        });
      } else {
        sockets[socketAddress] = null;
        reject('Socket error');
      }
    });
  };
  var makeBody = (requestId, plugin, method, params, version) => {
    if (params) {
      delete params.version;
      if (params.versionAsParameter) {
        params.version = params.versionAsParameter;
        delete params.versionAsParameter;
      }
    }
    const body = {
      jsonrpc: '2.0',
      id: requestId,
      method: [plugin, version, method].join('.')
    };
    params !== undefined ? body.params = params : null;
    return body;
  };
  var getVersion = (versionsConfig, plugin, params) => {
    const defaultVersion = 1;
    let version;
    if (version = params && params.version) {
      return version;
    }
    return versionsConfig ? versionsConfig[plugin] || versionsConfig.default || defaultVersion : defaultVersion;
  };
  let id$1 = 0;
  var makeId = () => {
    id$1 = id$1 + 1;
    return id$1;
  };
  var execRequest = (options, body) => {
    return connect(options).then(connection => {
      connection.send(JSON.stringify(body));
    });
  };
  var API = options => {
    return {
      request(plugin, method, params) {
        return new Promise((resolve, reject) => {
          const requestId = makeId();
          const version = getVersion(options.versions, plugin, params);
          const body = makeBody(requestId, plugin, method, params, version);
          if (options.debug) {
            console.log(' ');
            console.log('API REQUEST:');
            console.log(JSON.stringify(body, null, 2));
            console.log(' ');
          }
          requestsQueue[requestId] = {
            body,
            resolve,
            reject
          };
          execRequest(options, body).catch(e => {
            reject(e);
          });
        });
      }
    };
  };
  var DeviceInfo = {
    freeRam(params) {
      return this.call('systeminfo', params).then(res => {
        return res.freeram;
      });
    },
    version(params) {
      return this.call('systeminfo', params).then(res => {
        return res.version;
      });
    }
  };
  var plugins = {
    DeviceInfo
  };
  function listener$2(plugin, event, callback, errorCallback) {
    const thunder = this;
    const index = register.call(this, plugin, event, callback, errorCallback);
    return {
      dispose() {
        const listener_id = makeListenerId(plugin, event);
        if (listeners$2[listener_id] === undefined) return;
        listeners$2[listener_id].splice(index, 1);
        if (listeners$2[listener_id].length === 0) {
          unregister.call(thunder, plugin, event, errorCallback);
        }
      }
    };
  }
  const makeListenerId = (plugin, event) => {
    return ['client', plugin, 'events', event].join('.');
  };
  const register = function (plugin, event, callback, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    if (!listeners$2[listener_id]) {
      listeners$2[listener_id] = [];
      if (plugin !== 'ThunderJS') {
        const method = 'register';
        const request_id = listener_id.split('.').slice(0, -1).join('.');
        const params = {
          event,
          id: request_id
        };
        this.api.request(plugin, method, params).catch(e => {
          if (typeof errorCallback === 'function') errorCallback(e.message);
        });
      }
    }
    listeners$2[listener_id].push(callback);
    return listeners$2[listener_id].length - 1;
  };
  const unregister = function (plugin, event, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    delete listeners$2[listener_id];
    if (plugin !== 'ThunderJS') {
      const method = 'unregister';
      const request_id = listener_id.split('.').slice(0, -1).join('.');
      const params = {
        event,
        id: request_id
      };
      this.api.request(plugin, method, params).catch(e => {
        if (typeof errorCallback === 'function') errorCallback(e.message);
      });
    }
  };
  var thunderJS$1 = options => {
    if (options.token === undefined && typeof window !== 'undefined' && window.thunder && typeof window.thunder.token === 'function') {
      options.token = window.thunder.token();
    }
    return wrapper({
      ...thunder$l(options),
      ...plugins
    });
  };
  const resolve$1 = (result, args) => {
    if (typeof result !== 'object' || typeof result === 'object' && (!result.then || typeof result.then !== 'function')) {
      result = new Promise((resolve, reject) => {
        result instanceof Error === false ? resolve(result) : reject(result);
      });
    }
    const cb = typeof args[args.length - 1] === 'function' ? args[args.length - 1] : null;
    if (cb) {
      result.then(res => cb(null, res)).catch(err => cb(err));
    } else {
      return result;
    }
  };
  const thunder$l = options => ({
    options,
    api: API(options),
    plugin: false,
    call() {
      const args = [...arguments];
      if (this.plugin) {
        if (args[0] !== this.plugin) {
          args.unshift(this.plugin);
        }
      }
      const plugin = args[0];
      const method = args[1];
      if (typeof this[plugin][method] == 'function') {
        return this[plugin][method](args[2]);
      }
      return this.api.request.apply(this, args);
    },
    registerPlugin(name, plugin) {
      this[name] = wrapper(Object.assign(Object.create(thunder$l), plugin, {
        plugin: name
      }));
    },
    subscribe() {},
    on() {
      const args = [...arguments];
      if (['connect', 'disconnect', 'error'].indexOf(args[0]) !== -1) {
        args.unshift('ThunderJS');
      } else {
        if (this.plugin) {
          if (args[0] !== this.plugin) {
            args.unshift(this.plugin);
          }
        }
      }
      return listener$2.apply(this, args);
    },
    once() {
      console.log('todo ...');
    }
  });
  const wrapper = obj => {
    return new Proxy(obj, {
      get(target, propKey) {
        const prop = target[propKey];
        if (propKey === 'api') {
          return target.api;
        }
        if (typeof prop !== 'undefined') {
          if (typeof prop === 'function') {
            if (['on', 'once', 'subscribe'].indexOf(propKey) > -1) {
              return function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return prop.apply(this, args);
              };
            }
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return resolve$1(prop.apply(this, args), args);
            };
          }
          if (typeof prop === 'object') {
            return wrapper(Object.assign(Object.create(thunder$l(target.options)), prop, {
              plugin: propKey
            }));
          }
          return prop;
        } else {
          if (target.plugin === false) {
            return wrapper(Object.assign(Object.create(thunder$l(target.options)), {}, {
              plugin: propKey
            }));
          }
          return function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            args.unshift(propKey);
            return target.call.apply(this, args);
          };
        }
      }
    });
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */

  const themeOptions = {
    partnerOne: {
      hex: 0xfff58233,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    },
    partnerTwo: {
      hex: 0xff91c848,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    }
  };
  const availableLanguages = ['en', 'es'];
  const availableLanguageCodes = {
    "en": "en-US",
    "es": "es-US"
  };
  var CONFIG = {
    theme: themeOptions['partnerOne'],
    language: localStorage.getItem('Language') != null ? localStorage.getItem('Language') : 'en',
    thunderConfig: {
      host: '127.0.0.1',
      port: 9998,
      versions: {
        default: 1,
        'org.rdk.System': 2,
        ControlSettings: 2,
        'org.rdk.UsbAccess': 2,
        'org.rdk.DisplaySettings': 2
      }
    }
  };
  const GLOBALS = {
    _constantselfClientName: window.__firebolt && window.__firebolt.endpoint !== undefined ? "FireboltMainApp-refui" : "ResidentApp",
    get selfClientName() {
      return this._constantselfClientName;
    },
    _currentTopMostApp: localStorage.getItem('topmostApp') || (window.__firebolt && window.__firebolt.endpoint !== undefined ? "FireboltMainApp-refui" : "ResidentApp"),
    get topmostApp() {
      return this._currentTopMostApp;
    },
    set topmostApp(value) {
      this._currentTopMostApp = value;
      console.log('Setting current topmostApp as:' + this._currentTopMostApp);
    },
    set powerState(state) {
      this._currentPowerState = state;
    },
    get powerState() {
      return this._currentPowerState;
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Error$1 extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xffb70606,
        InvalidText: {
          x: 960,
          y: 540,
          mount: 0.5,
          text: {
            text: 'Invalid Route',
            textColor: 0xff000000,
            fontFace: CONFIG.language.font,
            fontSize: 70,
            fontStyle: 'bold'
          },
          SubText: {
            y: 80,
            text: {
              text: 'Press OK to return home',
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              fontStyle: 'bold',
              textAlign: 'center'
            }
          }
        }
      };
    }
    _handleEnter() {
      Router.navigate('menu');
    }
    _focus() {
      console.log('focus error page');
    }
    pageTransition() {
      return 'up';
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  const win$6 = typeof window !== 'undefined' ? window : {};

  let listener$1;
  const setMockListener$1 = func => { listener$1 = func; };

  let mock$4;
  const pending$1 = [];
  const eventMap$1 = {};

  let callback$1;
  let testHarness$1;

  if (win$6.__firebolt && win$6.__firebolt.testHarness) {
    testHarness$1 = win$6.__firebolt.testHarness;
  }

  function send$1(message) {
    console.debug('Sending message to transport: ' + message);
    let json = JSON.parse(message);

    // handle bulk sends
    if (Array.isArray(json)) {
      json.forEach(j => send$1(JSON.stringify(j)));
      return
    }

    let [module, method] = json.method.split('.');

    if (testHarness$1 && testHarness$1.onSend) {
      testHarness$1.onSend(module, method, json.params, json.id);
    }

    // store the ID of the first listen for each event
    if (method.match(/^on[A-Z]/)) {
      if (json.params.listen) {
        eventMap$1[json.id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3);
      } else {
        Object.keys(eventMap$1).forEach(key => {
          if (eventMap$1[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
            delete eventMap$1[key];
          }
        });
      }
    }

    if (mock$4)
      handle$1(json);
    else
      pending$1.push(json);
  }

  function handle$1(json) {
    let result;
    try {
      result = getResult$1(json.method, json.params);
    }
    catch (error) {
      setTimeout(() => callback$1(JSON.stringify({ 
        jsonrpc: '2.0',
        error: {
          code: -32602,
          message: "Invalid params (this is a mock error from the mock transport layer)"
        },
        id: json.id
      })));
    }

    setTimeout(() => callback$1(JSON.stringify({ 
      jsonrpc: '2.0',
      result: result,
      id: json.id
    })));
  }

  function receive$1(_callback) {
    callback$1 = _callback;

    if (testHarness$1 && (typeof testHarness$1.initialize === 'function')) {
      testHarness$1.initialize({
        emit: event$2,
        listen: function(...args) { listener$1(...args); },
      });
    }
  }

  function event$2(module, event, value) {
   const listener = Object.entries(eventMap$1).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase());
    if (listener) {
      let message = JSON.stringify({
        jsonrpc: '2.0',
        id: parseInt(listener[0]),
        result: value
      });
      callback$1(message);
    }
  }

  function dotGrab$3(obj = {}, key) {
    const keys = key.split('.');
    let ref = obj;
    for (let i = 0; i < keys.length; i++) {
      ref = (Object.entries(ref).find( ([k, v]) => k.toLowerCase() === keys[i].toLowerCase()) || [null, {}])[1];
    }
    return ref
  }

  function getResult$1(method, params) {
    let api = dotGrab$3(mock$4, method);

    if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
      api = {
        event: method,
        listening: true
      };
    }

    if (typeof api === 'function') {
      return params == null ? api() : api(params)
    } else return api
  }

  function setMockResponses$1(m) {
    mock$4 = m;

    pending$1.forEach(json => handle$1(json));
    pending$1.length = 0;
  }

  var mock$5 = {
    send: send$1,
    receive: receive$1,
    event: event$2
  };

  const mocks$1 = {};

  function mock$3(module, method, args, def) {
    const fullMethod = `${module}.${method}`;
    if ((args == null) || args.length === 0 || (Object.values(args[0]).length === 0)) {
      // get
      const rv = mocks$1[fullMethod] && (mocks$1[fullMethod].value != null) ? mocks$1[fullMethod].value : def;
      return rv
    } else {
      // set
      let mockMethod = mocks$1[fullMethod];
      if (mockMethod == null) {
        mockMethod = {
          subscribers: []
        };
      }
      mocks$1[fullMethod] = mockMethod;
      mockMethod.value = args[0].value;
      mock$5.event(module, method + 'Changed', {
        value: args[0].value
      });
      return {}
    }
  }

  var MockProps$1 = {
    mock: mock$3
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Accessibility = {
      closedCaptions:  {"enabled":true,"styles":{"fontFamily":"Monospace sans-serif","fontSize":1,"fontColor":"#ffffff","fontEdge":"none","fontEdgeColor":"#7F7F7F","fontOpacity":100,"backgroundColor":"#000000","backgroundOpacity":100,"textAlign":"center","textAlignVertical":"middle","windowColor":"white","windowOpacity":50}},
      closedCaptionsSettings: function () { return MockProps$1.mock('Accessibility', 'closedCaptionsSettings', arguments, {"enabled":true,"styles":{"fontFamily":"Monospace sans-serif","fontSize":1,"fontColor":"#ffffff","fontEdge":"none","fontEdgeColor":"#7F7F7F","fontOpacity":100,"backgroundColor":"#000000","backgroundOpacity":100,"textAlign":"center","textAlignVertical":"middle","windowColor":"white","windowOpacity":50}}) },
      voiceGuidance:  {"enabled":true,"speed":2},
      voiceGuidanceSettings: function () { return MockProps$1.mock('Accessibility', 'voiceGuidanceSettings', arguments, {"enabled":true,"speed":2}) },
      audioDescriptionSettings: function () { return MockProps$1.mock('Accessibility', 'audioDescriptionSettings', arguments, {"enabled":true}) }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Account$1 = {
      id: function () { return MockProps$1.mock('Account', 'id', arguments, "123") },
      uid: function () { return MockProps$1.mock('Account', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Advertising$1 = {
      config:  {"adServerUrl":"https://demo.v.fwmrm.net/ad/p/1","adServerUrlTemplate":"https://demo.v.fwmrm.net/ad/p/1?flag=+sltp+exvt+slcb+emcr+amcb+aeti&prof=12345:caf_allinone_profile &nw=12345&mode=live&vdur=123&caid=a110523018&asnw=372464&csid=gmott_ios_tablet_watch_live_ESPNU&ssnw=372464&vip=198.205.92.1&resp=vmap1&metr=1031&pvrn=12345&vprn=12345&vcid=1X0Ce7L3xRWlTeNhc7br8Q%3D%3D","adNetworkId":"519178","adProfileId":"12345:caf_allinone_profile","adSiteSectionId":"caf_allinone_profile_section","adOptOut":true,"privacyData":"ew0KICAicGR0IjogImdkcDp2MSIsDQogICJ1c19wcml2YWN5IjogIjEtTi0iLA0KICAibG10IjogIjEiIA0KfQ0K","ifaValue":"01234567-89AB-CDEF-GH01-23456789ABCD","ifa":"ewogICJ2YWx1ZSI6ICIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0QiLAogICJpZmFfdHlwZSI6ICJzc3BpZCIsCiAgImxtdCI6ICIwIgp9Cg==","appName":"FutureToday","appBundleId":"FutureToday.comcast","distributorAppId":"1001","deviceAdAttributes":"ewogICJib0F0dHJpYnV0ZXNGb3JSZXZTaGFyZUlkIjogIjEyMzQiCn0=","coppa":0,"authenticationEntity":"60f72475281cfba3852413bd53e957f6"},
      policy: function () { return MockProps$1.mock('Advertising', 'policy', arguments, {"skipRestriction":"adsUnwatched","limitAdTracking":false}) },
      advertisingId:  {"ifa":"01234567-89AB-CDEF-GH01-23456789ABCD","ifa_type":"idfa","lmt":"0"},
      deviceAttributes:  {},
      appBundleId:  "operator.app"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Authentication = {
      token:  {"value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c","expires":"2022-04-23T18:25:43.511Z","type":"platform"},
      device:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      session:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      root:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Capabilities = {
      supported:  true,
      available:  true,
      permitted:  true,
      granted:  true,
      info:  [{"capability":"xrn:firebolt:capability:device:model","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:input:keyboard","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:protocol:bluetoothle","supported":false,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unsupported"]},{"capability":"xrn:firebolt:capability:token:device","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:token:platform","supported":true,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unavailable"]},{"capability":"xrn:firebolt:capability:protocol:moca","supported":true,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["disabled","unavailable"]},{"capability":"xrn:firebolt:capability:wifi:scan","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unpermitted"]},{"capability":"xrn:firebolt:capability:localization:postal-code","supported":true,"available":true,"use":{"permitted":true,"granted":null},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["ungranted"]},{"capability":"xrn:firebolt:capability:localization:postal-code","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["ungranted"]},{"capability":"xrn:firebolt:capability:localization:locality","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["grantDenied","ungranted"]}],
      request:  [{"capability":"xrn:firebolt:capability:commerce:purchase","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}}]
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Device$1 = {
      id: function () { return MockProps$1.mock('Device', 'id', arguments, "123") },
      distributor: function () { return MockProps$1.mock('Device', 'distributor', arguments, "Company") },
      platform: function () { return MockProps$1.mock('Device', 'platform', arguments, "WPE") },
      uid: function () { return MockProps$1.mock('Device', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") },
      type: function () { return MockProps$1.mock('Device', 'type', arguments, "STB") },
      model: function () { return MockProps$1.mock('Device', 'model', arguments, "xi6") },
      sku: function () { return MockProps$1.mock('Device', 'sku', arguments, "AX061AEI") },
      make: function () { return MockProps$1.mock('Device', 'make', arguments, "Arris") },
      version: function () { return MockProps$1.mock('Device', 'version', arguments, {"sdk":{"major":0,"minor":8,"patch":0,"readable":"Firebolt JS SDK v0.8.0"},"api":{"major":0,"minor":8,"patch":0,"readable":"Firebolt API v0.8.0"},"firmware":{"major":1,"minor":2,"patch":3,"readable":"Device Firmware v1.2.3"},"os":{"major":0,"minor":1,"patch":0,"readable":"Firebolt OS v0.1.0"},"debug":"Non-parsable build info for error logging only."}) },
      hdcp: function () { return MockProps$1.mock('Device', 'hdcp', arguments, {"hdcp1.4":true,"hdcp2.2":true}) },
      hdr: function () { return MockProps$1.mock('Device', 'hdr', arguments, {"hdr10":true,"hdr10Plus":true,"dolbyVision":true,"hlg":true}) },
      audio: function () { return MockProps$1.mock('Device', 'audio', arguments, {"stereo":true,"dolbyDigital5.1":true,"dolbyDigital5.1+":true,"dolbyAtmos":true}) },
      screenResolution: function () { return MockProps$1.mock('Device', 'screenResolution', arguments, [1920,1080]) },
      videoResolution: function () { return MockProps$1.mock('Device', 'videoResolution', arguments, [1920,1080]) },
      name: function () { return MockProps$1.mock('Device', 'name', arguments, "Living Room") },
      network: function () { return MockProps$1.mock('Device', 'network', arguments, {"state":"connected","type":"wifi"}) }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Discovery$1 = {
      policy: function () { return MockProps$1.mock('Discovery', 'policy', arguments, {"enableRecommendations":true,"shareWatchHistory":true,"rememberWatchedPrograms":true}) },
      entityInfo:  true,
      purchasedContent:  true,
      watched:  true,
      watchNext:  true,
      entitlements:  true,
      contentAccess:  null,
      clearContentAccess:  null,
      launch:  true,
      signIn:  true,
      signOut:  true
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Keyboard$1 = {
      email:  "user@domain.com",
      password:  "abc123",
      standard:  "Living Room"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let inactive = {"state":"inactive","previous":"initializing"};
  let foreground = {"state":"foreground","previous":"inactive"};
  let unloading = {"state":"unloading","previous":"inactive"};

  const emit$2 = (value) => {
    mock$5.event('Lifecycle', value.state, value);
  };

  const win$5 = typeof window !== 'undefined' ? window : {};
  const automation = win$5.__firebolt ? !!win$5.__firebolt.automation : false;

  var _Lifecycle = {
    ready: function() {
      inactive.previous = 'initializing';
      setTimeout(() => emit$2(inactive), automation ? 1 : 500);
      foreground.previous = 'inactive';
      setTimeout(() => emit$2(foreground), automation ? 2 : 1000);
    },

    close: function(params) {
      let reason = params.reason;
      if (reason === 'remoteButton') {
        inactive.previous = 'foreground';
        setTimeout(() => emit$2(inactive), automation ? 1 : 500);
      }
      else if (['userExit', 'error'].includes(reason)) {
        inactive.previous = 'foreground';
        unloading.previous = 'inactive';
        setTimeout(() => emit$2(inactive), automation ? 1 : 500);
        setTimeout(() => emit$2(unloading), automation ? 2 : 1000);
      }
      else {
        throw "Invalid close reason"
      }
    },

    finished: function() {
      if (win$5.location)
        win$5.location.href = "about:blank";
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Localization$1 = {
      locality: function () { return MockProps$1.mock('Localization', 'locality', arguments, "Philadelphia") },
      postalCode: function () { return MockProps$1.mock('Localization', 'postalCode', arguments, "19103") },
      countryCode: function () { return MockProps$1.mock('Localization', 'countryCode', arguments, "US") },
      language: function () { return MockProps$1.mock('Localization', 'language', arguments, "en") },
      preferredAudioLanguages: function () { return MockProps$1.mock('Localization', 'preferredAudioLanguages', arguments, ["es","en"]) },
      locale: function () { return MockProps$1.mock('Localization', 'locale', arguments, "en-US") },
      latlon:  [39.9549,75.1699],
      additionalInfo:  {}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Metrics$1 = {
      ready:  true,
      signIn:  true,
      signOut:  true,
      startContent:  true,
      stopContent:  true,
      page:  true,
      action:  true,
      error:  true,
      mediaLoadStart:  true,
      mediaPlay:  true,
      mediaPlaying:  true,
      mediaPause:  true,
      mediaWaiting:  true,
      mediaProgress:  true,
      mediaSeeking:  true,
      mediaSeeked:  true,
      mediaRateChange:  true,
      mediaRenditionChange:  true,
      mediaEnded:  true
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Parameters = {
      initialization:  {"lmt":0,"us_privacy":"1-Y-","discovery":{"navigateTo":{"action":"entity","data":{"entityId":"abc","entityType":"program","programType":"movie"},"context":{"source":"voice"}}}}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Profile = {
      approveContentRating:  false,
      approvePurchase:  false,
      flags:  {"userExperience":"1000"}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecondScreen = {
      protocols:  {"dial1.7":true},
      device:  "device-id",
      friendlyName: function () { return MockProps$1.mock('SecondScreen', 'friendlyName', arguments, "Living Room") }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecureStorage$1 = {
      get:  "VGhpcyBub3QgYSByZWFsIHRva2VuLgo=",
      set:  null,
      remove:  null,
      clear:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Platform = {
    localization: _Localization$1,
    device: _Device$1,
    accessibility: _Accessibility,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Queue$1 {
    constructor () {
      this._callback = null;
      this._queue = [];
    }

    send (json) {
      this._queue.push(json);
    }

    receive (_callback) {
      this._callback = _callback;
    }

    flush (transport) {
      transport.receive(this._callback);
      this._queue.forEach(item => transport.send(item));
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const settings$1 = {};
  const subscribers$1 = {};

  const initSettings$1 = (appSettings, platformSettings) => {
    settings$1['app'] = appSettings;
    settings$1['platform'] = {
      logLevel: 'WARN',
      ...platformSettings
    };
    settings$1['user'] = {};
  };

  const publish$1 = (key, value) => {
    subscribers$1[key] && subscribers$1[key].forEach(subscriber => subscriber(value));
  };

  const dotGrab$2 = (obj = {}, key) => {
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
  };

  var Settings$1 = {
    get(type, key, fallback = undefined) {
      const val = dotGrab$2(settings$1[type], key);
      return val !== undefined ? val : fallback
    },
    has(type, key) {
      return !!this.get(type, key)
    },
    set(key, value) {
      settings$1['user'][key] = value;
      publish$1(key, value);
    },
    subscribe(key, callback) {
      subscribers$1[key] = subscribers$1[key] || [];
      subscribers$1[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers$1[key] && subscribers$1[key].findIndex(cb => cb === callback);
        index > -1 && subscribers$1[key].splice(index, 1);
      } else {
        if (key in subscribers$1) {
          subscribers$1[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers$1)) {
        delete subscribers$1[key];
      }
    },
    setLogLevel (logLevel) {
      settings$1.platform.logLevel = logLevel;
    },
    getLogLevel () {
      return settings$1.platform.logLevel
    }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const win$4 = typeof window !== 'undefined' ? window : {};

  class LegacyTransport$1 {
    constructor (bridge) {
      this.bridge = bridge;
    }

    send (msg) {
      this.bridge.JSMessageChanged(msg, () => {});
    }

    receive (callback) {
      win$4.$badger = win$4.$badger || {};
      /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
      const badgerCallback = win$4.$badger.callback ? win$4.$badger.callback.bind(win$4.$badger) : null;
      const badgerEvent = win$4.$badger.event ? win$4.$badger.event.bind(win$4.$badger) : null;
      win$4.$badger.callback = (pid, success, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerCallback) {
          badgerCallback(pid, success, json);
        }
      };
      win$4.$badger.event = (handlerId, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerEvent) {
          badgerEvent(handlerId, json);
        }
      };
    }

    static isLegacy (transport) {
      return LegacyTransport$1.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
    }

    static isXREProxy (transport) {
      /** Set top boxes running XRE has a "Proxy" transport
       * native object that intercepts ALL method calls, so we
       * cannot test for transport.send existence because it will return true
       * even though it actually is not supported. Check if some obscure method
       * name like "proxyObjectTest" is defined. If it is then we know we are using a
       * Proxy object and thus is legacy transport.
       */
      return transport.proxyObjectTest !== undefined
    }
  }

  const MAX_QUEUED_MESSAGES$1 = 100;

  class WebsocketTransport$1 {
    constructor (endpoint) {
      this._endpoint = endpoint;
      this._ws = null;
      this._connected = false;
      this._queue = [];
      this._callbacks = [];
    }

    send (msg) {
      this._connect();

      if (this._connected) {
        this._ws.send(msg);
      } else {
        if (this._queue.length < MAX_QUEUED_MESSAGES$1) {
          this._queue.push(msg);
        }
      }
    }

    receive (callback) {
      if (!callback) return
      this._connect();
      this._callbacks.push(callback);
    }

    _notifyCallbacks (message) {
      for (let i = 0; i < this._callbacks.length; i++) {
        setTimeout(() => this._callbacks[i](message), 1);
      }
    }

    _connect () {
      if (this._ws) return
      this._ws = new WebSocket(this._endpoint, ['jsonrpc']);
      this._ws.addEventListener('message', message => {
        this._notifyCallbacks(message.data);
      });
      this._ws.addEventListener('error', message => {
      });
      this._ws.addEventListener('close', message => {
        this._ws = null;
        this._connected = false;
      });
      this._ws.addEventListener('open', message => {
        this._connected = true;
        for (let i = 0; i < this._queue.length; i++) {
          this._ws.send(this._queue[i]);
        }
        this._queue = [];
      });
    }
  }

  /*
  methods = Map<string, {
      x-this-param: 'accessory',
      x-additional-params: ['timeout'],
      x-method: 'Accessory.pair'
  }>
  */

  function transform$1(result, transforms) {

      if (!transforms || !transforms.methods) {
          return result
      }

      const { methods } = transforms;
      const transformed = JSON.parse(JSON.stringify(result));

      Object.keys(methods).forEach(key => {
          const method_info = methods[key];
          const rpc_method = method_info['x-method'];
          const [module, method] = rpc_method.split('.');
          const params = {};
          params[method_info['x-this-param']] = transformed;
          transformed[key] = (...args) => {
              // copy the args into the correct RPC param names
              for (var i=0; i<args.length; i++) {
                  params[method_info['x-additional-params'][i]] = args[i];
              }
              return Transport$1.send(module.toLowerCase(), method, params)
          };
      });
      return transformed
  }

  var Results$1 = {
      transform: transform$1
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const LEGACY_TRANSPORT_SERVICE_NAME$1 = 'com.comcast.BridgeObject_1';
  let moduleInstance$1 = null;

  const isEventSuccess$1 = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean');

  const win$3 = typeof window !== 'undefined' ? window : {};

  class Transport$1 {
    constructor () {
      this._promises = [];
      this._transport = null;
      this._id = 1;
      this._eventEmitters = [];
      this._eventIds = [];
      this._queue = new Queue$1();
      this._deprecated = {};
      this.isMock = false;
    }

    static addEventEmitter (emitter) {
      Transport$1.get()._eventEmitters.push(emitter);
    }

    static registerDeprecatedMethod (module, method, alternative) {
      Transport$1.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
        alternative: alternative || ''
      };
    }

    _endpoint () {
      if (win$3.__firebolt && win$3.__firebolt.endpoint) {
        return win$3.__firebolt.endpoint
      }
      return null
    }

    constructTransportLayer () {
      let transport;
      const endpoint = this._endpoint();
      if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
        transport = new WebsocketTransport$1(endpoint);
        transport.receive(this.receiveHandler.bind(this));
      } else if (
        typeof win$3.ServiceManager !== 'undefined' &&
        win$3.ServiceManager &&
        win$3.ServiceManager.version
      ) {
        // Wire up the queue
        transport = this._queue;
        // get the default bridge service, and flush the queue
        win$3.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME$1, service => {
          if (LegacyTransport$1.isLegacy(service)) {
            transport = new LegacyTransport$1(service);
          } else {
            transport = service;
          }
          this.setTransportLayer(transport);
        });
      } else {
        this.isMock = true;
        transport = mock$5;
        transport.receive(this.receiveHandler.bind(this));
      }
      return transport
    }

    setTransportLayer (tl) {
      this._transport = tl;
      this._queue.flush(tl);
    }

    static send (module, method, params, transforms) {
      /** Transport singleton across all SDKs to keep single id map */
      return Transport$1.get()._send(module, method, params, transforms)
    }

    static listen(module, method, params, transforms) {
      return Transport$1.get()._sendAndGetId(module, method, params, transforms)
    }

    _send (module, method, params, transforms) {
      if (Array.isArray(module) && !method && !params) {
        return this._batch(module)
      }
      else {
        return this._sendAndGetId(module, method, params, transforms).promise
      }
    }

    _sendAndGetId (module, method, params, transforms) {
      const {promise, json, id } = this._processRequest(module, method, params, transforms);
      const msg = JSON.stringify(json);
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return { id, promise }
    }

    _batch (requests) {
      const results = [];
      const json = [];

      requests.forEach( ({module, method, params, transforms}) => {
        const result = this._processRequest(module, method, params, transforms);
        results.push({
          promise: result.promise,
          id: result.id
        });
        json.push(result.json);
      });

      const msg = JSON.stringify(json);
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return results
    }

    _processRequest (module, method, params, transforms) {

      const p = this._addPromiseToQueue(module, method, params, transforms);
      const json = this._createRequestJSON(module, method, params);

      const result = {
        promise: p,
        json: json,
        id: this._id
      };

      this._id++;

      return result
    }

    _createRequestJSON (module, method, params) {
      return { jsonrpc: '2.0', method: module.toLowerCase() + '.' + method, params: params, id: this._id }
    }

    _addPromiseToQueue (module, method, params, transforms) {
      return new Promise((resolve, reject) => {
        this._promises[this._id] = {};
        this._promises[this._id].promise = this;
        this._promises[this._id].resolve = resolve;
        this._promises[this._id].reject = reject;
        this._promises[this._id].transforms = transforms;

        const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()];
        if (deprecated) {
          console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative);
        }

        // store the ID of the first listen for each event
        // TODO: what about wild cards?
        if (method.match(/^on[A-Z]/)) {
          if (params.listen) {
            this._eventIds.push(this._id);
          } else {
            this._eventIds = this._eventIds.filter(id => id !== this._id);
          }
        }
      })
    }

    /**
     * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
     * @returns {Transport}
     */
    static get () {
      /** Set up singleton and initialize it */
      win$3.__firebolt = win$3.__firebolt || {};
      if ((win$3.__firebolt.transport == null) && (moduleInstance$1 == null)) {
        const transport = new Transport$1();
        transport.init();
        if (transport.isMock) {
          /** We should use the mock transport built with the SDK, not a global */
          moduleInstance$1 = transport;
        } else {
          win$3.__firebolt = win$3.__firebolt || {};
          win$3.__firebolt.transport = transport;
        }
        win$3.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport);
      }
      return win$3.__firebolt.transport ? win$3.__firebolt.transport : moduleInstance$1
    }

    receiveHandler (message) {
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Received message from transport: ' + message);
      }
      const json = JSON.parse(message);
      const p = this._promises[json.id];

      if (p) {
        if (json.error) p.reject(json.error);
        else {
          // Do any module-specific transforms on the result
          let result = json.result;

          if (p.transforms) {
            if (Array.isArray(json.result)) {
              result = result.map(x => Results$1.transform(x, p.transforms));
            }
            else {
              result = Results$1.transform(result, p.transforms);
            }
          }
          
          p.resolve(result);
        }
        delete this._promises[json.id];
      }

      // event responses need to be emitted, even after the listen call is resolved
      if (this._eventIds.includes(json.id) && !isEventSuccess$1(json.result)) {
        this._eventEmitters.forEach(emit => {
          emit(json.id, json.result);
        });
      }
    }

    init () {
      initSettings$1({}, { log: true });
      this._queue.receive(this.receiveHandler.bind(this));
      if (win$3.__firebolt) {
        if (win$3.__firebolt.mockTransportLayer === true) {
          this.isMock = true;
          this.setTransportLayer(mock$5);
        } else if (win$3.__firebolt.getTransportLayer) {
          this.setTransportLayer(win$3.__firebolt.getTransportLayer());
        }
      }
      if (this._transport == null) {
        this._transport = this.constructTransportLayer();
      }
    }
  }
  win$3.__firebolt = win$3.__firebolt || {};
  win$3.__firebolt.setTransportLayer = transport => {
    Transport$1.get().setTransportLayer(transport);
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let listenerId$1 = 0;

  // holds two maps of ${module}.${event} => listenerId, e.g. callback method id
  // note that one callback can listen to multiple events, e.g. 'discovery.*'
  // internal is only available via a private export that we use to ensure our modules know about
  // events before the apps using the SDK (otherwise state errors can happen)
  const listeners$1 = {
    internal: {},
    external: {},

    // Several convenience functions below for checking both internal & external lists w/ one operation

    // gets a merge list of ids for a single event key
    get: (key) => {
      return Object.assign(Object.assign({}, listeners$1.internal[key]), listeners$1.external[key])
    },
    // adds a callback/id to a key on the external list only 
    set: (key, id, value) => {
      listeners$1.external[key] = listeners$1.external[key] || {};
      listeners$1.external[key][id] = value;
    },
    // adds a callback/id to a key on the internal list only 
    setInternal: (key, id, value) => {
      listeners$1.internal[key] = listeners$1.internal[key] || {};
      listeners$1.internal[key][id] = value;
    },
    // finds the key for an id in either list (it can only be in one)
    find: (id) => {
      let key;
      [listeners$1.internal, listeners$1.external].find(group => {
        key = Object.keys(group).find(key => group[key][id]);
        if (key) return true
      });
      return key
    },
    // removes an id from either list
    remove: (id) => {
      [listeners$1.internal, listeners$1.external].forEach(group => {
        Object.keys(group).forEach(key => {
          if (group[key] && group[key][id]) {
            delete group[key][id];
            if (Object.values(group[key]).length === 0) {
              delete group[key];
            }
          }
        });
      });
    },
    // removes a key from both lists if _internal is true, otherwise only the external list
    removeKey: (key, _internal=false) => {
      _internal && listeners$1.internal[key] && delete listeners$1.internal[key];
      listeners$1.external[key] && delete listeners$1.external[key];
    },
    // gives a list of all keys
    keys: () => {
      return Array.from(new Set(Object.keys(listeners$1.internal).concat(Object.keys(listeners$1.external))))
    },
    // counts how many listeners are in a key across both lists
    count: (key) => {
      return Object.values(listeners$1.get(key)).length
    }
  };

  // holds a map of RPC Ids => Context Key, e.g. the RPC id of an onEvent call mapped to the corresponding context parameters key for that RPC call
  const keys$1 = {};

  // holds a map of ${module}.${event} => Transport.send calls (only called once per event)
  // note that the keys here MUST NOT contain wild cards
  const oncers$1 = [];
  const validEvents$1 = {};
  const validContext$1 = {};

  let transportInitialized$1 = false;

  const emit$1 = (id, value) => {
    callCallbacks$1(listeners$1.internal[keys$1[id]], [value]);
    callCallbacks$1(listeners$1.external[keys$1[id]], [value]);
  };

  const registerEvents$1 = (module, events) => {
    validEvents$1[module.toLowerCase()] = events.concat();
  };

  const registerEventContext$1 = (module, event, context) => {
    validContext$1[module.toLowerCase()] = validContext$1[module.toLowerCase()] || {};
    validContext$1[module.toLowerCase()][event] = context.concat();
  };

  const callCallbacks$1 = (cbs, args) => {
    cbs &&
      Object.keys(cbs).forEach(listenerId => {
        let callback = cbs[listenerId];
        if (oncers$1.indexOf(parseInt(listenerId)) >= 0) {
          oncers$1.splice(oncers$1.indexOf(parseInt(listenerId)), 1);
          delete cbs[listenerId];
        }
        callback.apply(null, args);
      });
  };

  const doListen$1 = function(module, event, callback, context, once, internal=false) {
    init$1();

    if (typeof callback !== 'function') {
      return Promise.reject('No valid callback function provided.')
    } else {
      if (module === '*') {
        return Promise.reject('No valid module name provided')
      }

      const wildcard = event === '*';
      const events = (wildcard ? validEvents$1[module] : [event]); // explodes wildcards into an array
      const promises = [];
      const hasContext = Object.values(context).length > 0;
      const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');

      listenerId$1++;

      if (once) {
        oncers$1.push(listenerId$1);
      }

      events.forEach(event => {
        const key = module + '.' + event + (hasContext ? `.${contextKey}`  : '');

        if (Object.values(listeners$1.get(key)).length === 0) {
          const args = Object.assign({ listen: true }, context);
          const { id, promise } = Transport$1.listen(module, 'on' + event[0].toUpperCase() + event.substring(1), args);
          keys$1[id] = key;
          promises.push(promise);
        }

        const setter = internal ? listeners$1.setInternal : listeners$1.set;

        if (wildcard) {
          setter(key, ''+listenerId$1, value => callback(event, value));
        }
        else {
          setter(key, ''+listenerId$1, callback);
        }
      });

      let resolve, reject;
      let p = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });

      if (promises.length) {
        Promise.all(promises).then(responses => {
          resolve(listenerId$1);
        }).catch(error => {
          // Promise.all rejects if at least one promise rejects... we don't want that behavior here
          // TODO: Do something better than fail silently
          if (event === '*') {
            resolve(listenerId$1);
          }
          else {
            reject(error);
          }
        });
      }
      else {
        resolve(listenerId$1);
      }

      return p
    }
  };

  const getListenArgs$1 = function(...args) {
    const callback = args.pop();
    const [module, event, context] = getClearArgs$1(...args);

    return [module, event, callback, context]
  };

  const getClearArgs$1 = function(...args) {
    const module = (args.shift() || '*').toLowerCase();
    const event = args.shift() || '*';
    const context = {};
    
    for (let i = 0; args.length; i++) {
      context[validContext$1[module][event][i]] = args.shift();
    }

    return [module, event, context]
  };

  const once$6 = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, true)
  };

  const listen$6 = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, false)
  };

  const clear$6 = function(...args) {
    if (args && args.length && typeof args[0] === 'number') {
      return doClear$1(args[0])
    }
    else if (args && args.length && typeof args[1] === 'number') {
      return doClear$1(args[1])
    }
    else {
      const [moduleOrId, event, context] = getClearArgs$1(...args);
      return doClear$1(moduleOrId, event, context)
    }
  };

  // calls doListen with a priority flag for internal listeners to get priority
  const prioritize = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, false, true)
  };

  const unsubscribe$1 = (key, context) => {
    const [module, event] = key.split('.').slice(0, 2);
    const args = Object.assign({ listen: false }, context);
    Transport$1.send(module, 'on' + event[0].toUpperCase() + event.substr(1), args);
  };


  // TODO: clear needs to go through Transport Layer
  const doClear$1 = function (moduleOrId = false, event = false, context) {
    if (event === '*') {
      event = false;
    }

    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString();
      const key = listeners$1.find(searchId);

      if (key) {
        listeners$1.remove(searchId);
        if (listeners$1.count(key) === 0) {
          unsubscribe$1(key);
        }
        return true
      }
      return false
    } else {
      if (!moduleOrId && !event) {
        listeners$1.keys().forEach(key => {
          listeners$1.removeKey(key);
          unsubscribe$1(key);
        });
      } else if (!event) {
        listeners$1.keys().forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            listeners$1.removeKey(key);
            unsubscribe$1(key);
          }
        });
      } else {
        const hasContext = Object.values(context).length > 0;
        const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');
        const key = moduleOrId + '.' + event + (hasContext ? `.${contextKey}`  : '');

        listeners$1.removeKey(key);
        unsubscribe$1(key, context);
      }
    }
  };

  const init$1 = () => {
    if (!transportInitialized$1) {
      Transport$1.addEventEmitter(emit$1);
      setMockListener$1(listen$6);
      transportInitialized$1 = true;
    }
  };

  var Events$1 = {
    listen: listen$6,
    once: once$6,
    clear: clear$6,
    broadcast(event, value) {
      emit$1(Object.entries(keys$1).find( ([k, v]) => v === 'app.'+event)[0], value);
    },
  };

  function prop$1(moduleName, key, params, callbackOrValue = null, immutable, readonly, contextParameterCount) {
    const numArgs = Object.values(params).length;

    if (numArgs === contextParameterCount && callbackOrValue === null) {
      // getter
      return Transport$1.send(moduleName, key, params)
    } else if (numArgs === contextParameterCount && typeof callbackOrValue === 'function') {
      // subscribe
      if (immutable) {
        throw new Error('Cannot subscribe to an immutable property')
      }
      return Events$1.listen(moduleName, key + 'Changed', ...Object.values(params), callbackOrValue)
    } else if (numArgs === (contextParameterCount) && callbackOrValue !== null) {
      // setter
      if (immutable) {
        throw new Error('Cannot set a value to an immutable property')
      }
      if (readonly) {
        throw new Error('Cannot set a value to a readonly property')
      }
      return Transport$1.send(moduleName, 'set' + key[0].toUpperCase() + key.substring(1), Object.assign({
        value: callbackOrValue
      }, params))
    }
    else if (numArgs < contextParameterCount) {
      throw new Error('Cannot get a value without all required context parameters.')
    }
    else {
      throw new Error('Property accessed with unexpected number of parameters.')
    }
  }

  var Prop$1 = {
    prop: prop$1
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Accessibility', ["audioDescriptionSettingsChanged","closedCaptionsSettingsChanged","voiceGuidanceSettingsChanged"]);


  Transport$1.registerDeprecatedMethod('Accessibility', 'closedCaptions', 'Use Accessibility.closedCaptionsSettings() instead.');
  Transport$1.registerDeprecatedMethod('Accessibility', 'voiceGuidance', 'Use Accessibility.voiceGuidanceSettings() instead.');

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Advertising', ["policyChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */



  Transport$1.registerDeprecatedMethod('Authentication', 'token', 'Use Authentication module has individual methods for each token type. instead.');

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Capabilities', ["available","granted","revoked","unavailable"]);



  // onAvailable is accessed via listen('available, ...)

  registerEventContext$1('Capabilities', 'available', ["capability"]);
  // onGranted is accessed via listen('granted, ...)

  registerEventContext$1('Capabilities', 'granted', ["role","capability"]);
  // onRevoked is accessed via listen('revoked, ...)

  registerEventContext$1('Capabilities', 'revoked', ["role","capability"]);
  // onUnavailable is accessed via listen('unavailable, ...)

  registerEventContext$1('Capabilities', 'unavailable', ["capability"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Device', ["audioChanged","deviceNameChanged","hdcpChanged","hdrChanged","nameChanged","networkChanged","screenResolutionChanged","videoResolutionChanged"]);


  Transport$1.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.');

  function version() {
    return new Promise( (resolve, reject) => {
        Transport$1.send('device', 'version').then( v => {
            v = v || {};
            v.sdk = v.sdk || {};
            v.sdk.major = parseInt('0');
            v.sdk.minor = parseInt('15');
            v.sdk.patch = parseInt('0');
            v.sdk.readable = 'Firebolt Core SDK 0.15.0';
            resolve(v);    
        }).catch(error => {
            reject(error);
        });
    })
  }


      // Methods
  function audio() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'audio', {  }, callbackOrValue, false, true, 0)
  }
    function clear$5(...args) {
      return Events$1.clear('Device', ...args)
    }

  function distributor() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'distributor', {  }, callbackOrValue, true, true, 0)
  }
  function hdcp() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'hdcp', {  }, callbackOrValue, false, true, 0)
  }
  function hdr() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'hdr', {  }, callbackOrValue, false, true, 0)
  }
  function id() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'id', {  }, callbackOrValue, true, true, 0)
  }
    function listen$5(...args) {
      return Events$1.listen('Device', ...args)
    } 
    
  function make() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'make', {  }, callbackOrValue, true, true, 0)
  }
  function model() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'model', {  }, callbackOrValue, true, true, 0)
  }
  function name() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'name', {  }, callbackOrValue, false, true, 0)
  }
  function network() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'network', {  }, callbackOrValue, false, true, 0)
  }
    function once$5(...args) {
      return Events$1.once('Device', ...args)
    }

  function platform$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'platform', {  }, callbackOrValue, true, true, 0)
  }
  function screenResolution() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'screenResolution', {  }, callbackOrValue, false, true, 0)
  }
  function sku() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'sku', {  }, callbackOrValue, true, true, 0)
  }
  function type() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'type', {  }, callbackOrValue, true, true, 0)
  }
  function uid() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'uid', {  }, callbackOrValue, true, true, 0)
  }
  function videoResolution() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Device',  'videoResolution', {  }, callbackOrValue, false, true, 0)
  }

  var Device = {

  events: {
      DEVICE_NAME_CHANGED: 'deviceNameChanged',
      NAME_CHANGED: 'nameChanged',
      HDCP_CHANGED: 'hdcpChanged',
      HDR_CHANGED: 'hdrChanged',
      AUDIO_CHANGED: 'audioChanged',
      SCREEN_RESOLUTION_CHANGED: 'screenResolutionChanged',
      VIDEO_RESOLUTION_CHANGED: 'videoResolutionChanged',
      NETWORK_CHANGED: 'networkChanged',
  },

  NetworkState: {
      CONNECTED: 'connected',
      DISCONNECTED: 'disconnected',
  },

  NetworkType: {
      WIFI: 'wifi',
      ETHERNET: 'ethernet',
      HYBRID: 'hybrid',
  },

  AudioProfile: {
      STEREO: 'stereo',
      DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
      DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
      DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
      DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
      DOLBY_ATMOS: 'dolbyAtmos',
  },


    version,
  audio,
clear:   clear$5,
  distributor,
  hdcp,
  hdr,
  id,
listen:   listen$5,
  make,
  model,
  name,
  network,
once:   once$5,
platform:   platform$1,
  screenResolution,
  sku,
  type,
  uid,
  videoResolution
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */




  function ready$1() {
    return Transport$1.send('metrics', 'ready', {})
  }

  function signIn$1() {
    return Transport$1.send('metrics', 'signIn', {})
  }

  function signOut$1() {
    return Transport$1.send('metrics', 'signOut', {})
  }



      // Methods

  function action(category, type, parameters) {

    const transforms = null;

    return Transport$1.send('Metrics', 'action', { category, type, parameters }, transforms)
  }

  function error(type, code, description, visible, parameters) {

    const transforms = null;

    return Transport$1.send('Metrics', 'error', { type, code, description, visible, parameters }, transforms)
  }

  function mediaEnded(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaEnded', { entityId }, transforms)
  }

  function mediaLoadStart(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaLoadStart', { entityId }, transforms)
  }

  function mediaPause(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaPause', { entityId }, transforms)
  }

  function mediaPlay(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaPlay', { entityId }, transforms)
  }

  function mediaPlaying(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaPlaying', { entityId }, transforms)
  }

  function mediaProgress(entityId, progress) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaProgress', { entityId, progress }, transforms)
  }

  function mediaRateChange(entityId, rate) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaRateChange', { entityId, rate }, transforms)
  }

  function mediaRenditionChange(entityId, bitrate, width, height, profile) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaRenditionChange', { entityId, bitrate, width, height, profile }, transforms)
  }

  function mediaSeeked(entityId, position) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaSeeked', { entityId, position }, transforms)
  }

  function mediaSeeking(entityId, target) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaSeeking', { entityId, target }, transforms)
  }

  function mediaWaiting(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'mediaWaiting', { entityId }, transforms)
  }

  function page(pageId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'page', { pageId }, transforms)
  }




  function startContent(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'startContent', { entityId }, transforms)
  }

  function stopContent(entityId) {

    const transforms = null;

    return Transport$1.send('Metrics', 'stopContent', { entityId }, transforms)
  }

  var Metrics$3 = {

  ErrorType: {
      NETWORK: 'network',
      MEDIA: 'media',
      RESTRICTION: 'restriction',
      ENTITLEMENT: 'entitlement',
      OTHER: 'other',
  },

  action,
  error,
  mediaEnded,
  mediaLoadStart,
  mediaPause,
  mediaPlay,
  mediaPlaying,
  mediaProgress,
  mediaRateChange,
  mediaRenditionChange,
  mediaSeeked,
  mediaSeeking,
  mediaWaiting,
  page,
  startContent,
  stopContent
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Discovery', ["navigateTo","policyChanged","pullEntityInfo","pullPurchasedContent"]);


  Transport$1.registerDeprecatedMethod('Discovery', 'entitlements', 'Use Discovery.contentAccess() instead.');

  // onNavigateTo is accessed via listen('navigateTo, ...)

  // onPolicyChanged is accessed via listen('policyChanged, ...)




      // Methods
    function clear$4(...args) {
      return Events$1.clear('Discovery', ...args)
    }


  function clearContentAccess() {

    const transforms = null;

    return Transport$1.send('Discovery', 'clearContentAccess', {  }, transforms)
  }

  function contentAccess(ids) {

    const transforms = null;

    return Transport$1.send('Discovery', 'contentAccess', { ids }, transforms)
  }

  function entitlements(entitlements) {

    const transforms = null;

    return Transport$1.send('Discovery', 'entitlements', { entitlements }, transforms)
  }

  let entityInfoHasCallback = false;

  function entityInfo (data) {
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      if (entityInfoHasCallback) {
        return Promise.reject('Cannot register more than one entityInfo handler.')
      }

      const callback = arguments[0];
      entityInfoHasCallback = true;
      return Events$1.listen('Discovery', 'pullEntityInfo', (request) => {
        if (typeof request === 'boolean') return

        try {
          const result = callback(request.parameters).then(result => {
            const params = {
              correlationId: request.correlationId,
              result: result
            };
            Transport$1.send('Discovery', 'entityInfo', params).catch(error => {
              const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
              console.error(`Failed to send entityInfo pull response through Transport Layer: ${msg}`);
            });
          }).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
            console.error(`App 'entityInfo' callback failed: ${msg}`);
          });
        }
        catch (error) {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`App 'entityInfo' callback failed: ${msg}`);
      }
      })
    }
    else {
      return Transport$1.send('Discovery', 'entityInfo', { correlationId: null, result: data })
    }
  }

  function launch(appId, intent) {

    const transforms = null;

    return Transport$1.send('Discovery', 'launch', { appId, intent }, transforms)
  }
    function listen$4(...args) {
      return Events$1.listen('Discovery', ...args)
    } 
    
    function once$4(...args) {
      return Events$1.once('Discovery', ...args)
    }

  function policy() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Discovery',  'policy', {  }, callbackOrValue, false, true, 0)
  }

  let purchasedContentHasCallback = false;

  function purchasedContent (data) {
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      if (purchasedContentHasCallback) {
        return Promise.reject('Cannot register more than one purchasedContent handler.')
      }

      const callback = arguments[0];
      purchasedContentHasCallback = true;
      return Events$1.listen('Discovery', 'pullPurchasedContent', (request) => {
        if (typeof request === 'boolean') return

        try {
          const result = callback(request.parameters).then(result => {
            const params = {
              correlationId: request.correlationId,
              result: result
            };
            Transport$1.send('Discovery', 'purchasedContent', params).catch(error => {
              const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
              console.error(`Failed to send purchasedContent pull response through Transport Layer: ${msg}`);
            });
          }).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
            console.error(`App 'purchasedContent' callback failed: ${msg}`);
          });
        }
        catch (error) {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`App 'purchasedContent' callback failed: ${msg}`);
      }
      })
    }
    else {
      return Transport$1.send('Discovery', 'purchasedContent', { correlationId: null, result: data })
    }
  }

  function signIn(entitlements) {
      const transforms = null;

      const p = Transport$1.send('Discovery', 'signIn', { entitlements }, transforms);
      
      p.then(_ => {
          setTimeout(_ => {
              signIn$1();
          });    
      }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`Metrics 'signIn' callback failed: ${msg}`);
      });

      return p
  }

  function signOut() {
      const transforms = null;

      const p = Transport$1.send('Discovery', 'signOut', {  }, transforms);
      
      p.then(_ => {
          setTimeout(_ => {
              signOut$1();
          });    
      }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`Metrics 'signOut' callback failed: ${msg}`);
      });

      return p
  }

  function watched(entityId, progress, completed, watchedOn) {
    const transforms = null;

    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return Transport$1.send('Discovery', 'watched', arguments[0], transforms)
    }
    else {
      return Transport$1.send('Discovery', 'watched', { entityId, progress, completed, watchedOn }, transforms)
    }
  }

  function watchNext(title, identifiers, expires, images) {

    const transforms = null;

    return Transport$1.send('Discovery', 'watchNext', { title, identifiers, expires, images }, transforms)
  }
    
  var Discovery = {

  events: {
      NAVIGATE_TO: 'navigateTo',
      POLICY_CHANGED: 'policyChanged',
      PULL_ENTITY_INFO: 'pullEntityInfo',
      PULL_PURCHASED_CONTENT: 'pullPurchasedContent',
  },

  ProgramType: {
      MOVIE: 'movie',
      EPISODE: 'episode',
      SEASON: 'season',
      SERIES: 'series',
      OTHER: 'other',
      PREVIEW: 'preview',
      EXTRA: 'extra',
      CONCERT: 'concert',
      SPORTING_EVENT: 'sportingEvent',
      ADVERTISEMENT: 'advertisement',
      MUSIC_VIDEO: 'musicVideo',
      MINISODE: 'minisode',
  },

  OfferingType: {
      FREE: 'free',
      SUBSCRIBE: 'subscribe',
      BUY: 'buy',
      RENT: 'rent',
  },

  AudioProfile: {
      STEREO: 'stereo',
      DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
      DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
      DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
      DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
      DOLBY_ATMOS: 'dolbyAtmos',
  },

clear:   clear$4,
  clearContentAccess,
  contentAccess,
  entitlements,
  entityInfo,
  launch,
listen:   listen$4,
once:   once$4,
  policy,
  purchasedContent,
  signIn,
  signOut,
  watched,
  watchNext
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Lifecycle', ["background","foreground","inactive","suspended","unloading"]);



  const store = {
    _current: 'initializing',
    get current() {
      return this._current
    }
  };

  async function ready() {
    let readyRes;
    await prioritize('Lifecycle', (event, value) => {
      store._current = event;
    });
    readyRes =await Transport$1.send('lifecycle', 'ready', {});
    setTimeout(_ => {
      ready$1();
    });
    return readyRes
  }


      // Methods
    function clear$3(...args) {
      return Events$1.clear('Lifecycle', ...args)
    }


  function close(reason) {

    const transforms = null;

    return Transport$1.send('Lifecycle', 'close', { reason }, transforms)
  }
    function listen$3(...args) {
      return Events$1.listen('Lifecycle', ...args)
    } 
    
    function once$3(...args) {
      return Events$1.once('Lifecycle', ...args)
    }


  function state() {
    return store.current
  }

  function finished() {
    if (store.current === 'unloading') {
      return Transport$1.send('lifecycle', 'finished')
    } else {
      throw 'Cannot call finished() except when in the unloading transition'
    }
  }

  // public API
  var Lifecycle = {

  events: {
      INACTIVE: 'inactive',
      FOREGROUND: 'foreground',
      BACKGROUND: 'background',
      SUSPENDED: 'suspended',
      UNLOADING: 'unloading',
  },


  CloseReason: {
      REMOTE_BUTTON: 'remoteButton',
      USER_EXIT: 'userExit',
      DONE: 'done',
      ERROR: 'error',
  },

  LifecycleState: {
      INITIALIZING: 'initializing',
      INACTIVE: 'inactive',
      FOREGROUND: 'foreground',
      BACKGROUND: 'background',
      UNLOADING: 'unloading',
      SUSPENDED: 'suspended',
  },


    ready,
    state,
    finished,

clear:   clear$3,
  close,
listen:   listen$3,
once:   once$3
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Localization', ["countryCodeChanged","languageChanged","localeChanged","localityChanged","postalCodeChanged","preferredAudioLanguagesChanged"]);



  // onCountryCodeChanged is accessed via listen('countryCodeChanged, ...)

  // onLanguageChanged is accessed via listen('languageChanged, ...)

  // onLocaleChanged is accessed via listen('localeChanged, ...)

  // onLocalityChanged is accessed via listen('localityChanged, ...)

  // onPostalCodeChanged is accessed via listen('postalCodeChanged, ...)

  // onPreferredAudioLanguagesChanged is accessed via listen('preferredAudioLanguagesChanged, ...)


      // Methods

  function additionalInfo$1() {

    const transforms = null;

    return Transport$1.send('Localization', 'additionalInfo', {  }, transforms)
  }
    function clear$2(...args) {
      return Events$1.clear('Localization', ...args)
    }

  function countryCode$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'countryCode', {  }, callbackOrValue, false, true, 0)
  }
  function language$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'language', {  }, callbackOrValue, false, true, 0)
  }

  function latlon() {

    const transforms = null;

    return Transport$1.send('Localization', 'latlon', {  }, transforms)
  }
    function listen$2(...args) {
      return Events$1.listen('Localization', ...args)
    } 
    
  function locale$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'locale', {  }, callbackOrValue, false, true, 0)
  }
  function locality$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'locality', {  }, callbackOrValue, false, true, 0)
  }
    function once$2(...args) {
      return Events$1.once('Localization', ...args)
    }

  function postalCode$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'postalCode', {  }, callbackOrValue, false, true, 0)
  }
  function preferredAudioLanguages$1() {
    const callbackOrValue = arguments[0];
    return Prop$1.prop('Localization',  'preferredAudioLanguages', {  }, callbackOrValue, false, true, 0)
  }
    
  var Localization$1 = {

  events: {
      LOCALITY_CHANGED: 'localityChanged',
      POSTAL_CODE_CHANGED: 'postalCodeChanged',
      COUNTRY_CODE_CHANGED: 'countryCodeChanged',
      LANGUAGE_CHANGED: 'languageChanged',
      PREFERRED_AUDIO_LANGUAGES_CHANGED: 'preferredAudioLanguagesChanged',
      LOCALE_CHANGED: 'localeChanged',
  },

additionalInfo:   additionalInfo$1,
clear:   clear$2,
countryCode:   countryCode$1,
language:   language$1,
  latlon,
listen:   listen$2,
locale:   locale$1,
locality:   locality$1,
once:   once$2,
postalCode:   postalCode$1,
preferredAudioLanguages:   preferredAudioLanguages$1
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('SecondScreen', ["closeRequest","friendlyNameChanged","launchRequest"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  setMockResponses$1({
      Accessibility: _Accessibility,
      Account: _Account$1,
      Advertising: _Advertising$1,
      Authentication: _Authentication,
      Capabilities: _Capabilities,
      Device: _Device$1,
      Discovery: _Discovery$1,
      Keyboard: _Keyboard$1,
      Lifecycle: _Lifecycle,
      Localization: _Localization$1,
      Metrics: _Metrics$1,
      Parameters: _Parameters,
      Profile: _Profile,
      SecondScreen: _SecondScreen,
      SecureStorage: _SecureStorage$1,
      Platform: _Platform,
  });

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance$6 = null;
  class Network {
    constructor() {
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
      this.callsign = 'org.rdk.Network';
      this.INFO = console.info;
      this.LOG = console.log;
      this.ERR = console.error;
    }
    static get() {
      if (instance$6 === null) {
        instance$6 = new Network();
        // Vital plugins; always keep activated.
        instance$6.activate();
      }
      return instance$6;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO(this.callsign + " activate result:" + result);
          resolve(true);
        }).catch(err => {
          this.ERR(this.callsign + " activate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error while Thunder Controller Network activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO(this.callsign + " deactivate result:" + result);
          resolve(true);
        }).catch(err => {
          this.ERR(this.callsign + " deactivate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error while Thunder Controller Network deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getDefaultInterface').then(result => {
          this.INFO(this.callsign + " getDefaultInterface result: " + result);
          if (result.success) resolve(result.interface);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " getDefaultInterface error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getDefaultInterface " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getInterfaces() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getInterfaces').then(result => {
          this.INFO(this.callsign + " getInterfaces result: " + result);
          if (result.success) {
            resolve(result.interfaces);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " getInterfaces error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getInterfaces " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getIPSettings(interfaceName) {
      let ipversion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IPv4";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getIPSettings', {
          "interface": interfaceName,
          "ipversion": ipversion
        }).then(result => {
          this.INFO(this.callsign + "[getIPSettings] result: " + result);
          if (result.success) {
            resolve(result);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getIPSettings] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getIPSettings " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getNamedEndpoints() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getNamedEndpoints').then(result => {
          this.INFO(this.callsign + "[getNamedEndpoints] result: " + result);
          if (result.success) resolve(result.endpoints);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getNamedEndpoints] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getNamedEndpoints " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getQuirks() {
      return new Promise((resolve, reject) => {
        // TODO: unknown usecase.
        reject(false);
      });
    }
    getStbIp() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getStbIp').then(result => {
          this.INFO(this.callsign + "[getStbIp] result: " + JSON.stringify(result));
          if (result.success) {
            resolve(result.ip);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getStbIp] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getStbIp result " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSTBIPFamily() {
      let family = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "AF_INET";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getSTBIPFamily', {
          "family": family
        }).then(result => {
          this.INFO(this.callsign + "[getSTBIPFamily] result: " + result);
          if (result.success) {
            resolve(result);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getSTBIPFamily] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getSTBIPFamily " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setConnectivityTestEndpoints() {
      let endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return new Promise((resolve, reject) => {
        if (!endpoints.length) reject(false);
        this._thunder.call(this.callsign, 'setConnectivityTestEndpoints', {
          endpoints: endpoints
        }).then(result => {
          this.INFO(this.callsign + "[setConnectivityTestEndpoints] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setConnectivityTestEndpoints] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network setConnectivityTestEndpoints " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    isConnectedToInternet() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'isConnectedToInternet').then(result => {
          this.LOG(this.callsign + "[isConnectedToInternet] result: " + JSON.stringify(result));
          if (result.success) resolve(result.connectedToInternet);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[isConnectedToInternet] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network isConnectedToInternet " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getinternetconnectionstate() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getInternetConnectionState').then(result => {
          this.INFO(this.callsign + "[getinternetconnectionstate] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getinternetconnectionstate] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getInternetConnectionState " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getCaptivePortalURI() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getCaptivePortalURI').then(result => {
          this.INFO(this.callsign + "[getCaptivePortalURI] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getCaptivePortalURI] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getCaptivePortalURI " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    startConnectivityMonitoring() {
      let intervalInSec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'startConnectivityMonitoring', {
          "interval": intervalInSec
        }).then(result => {
          this.INFO(this.callsign + "[startConnectivityMonitoring] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[startConnectivityMonitoring] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network startConnectivityMonitoring " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    stopConnectivityMonitoring() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'stopConnectivityMonitoring').then(result => {
          this.INFO(this.callsign + "[stopConnectivityMonitoring] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[stopConnectivityMonitoring] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network stopConnectivityMonitoring " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    isInterfaceEnabled() {
      let interfaceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "WIFI";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'isInterfaceEnabled', {
          "interface": interfaceName
        }).then(result => {
          this.INFO(this.callsign + "[isInterfaceEnabled]" + interfaceName + " result: " + JSON.stringify(result));
          if (result.success) resolve(result.enabled);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[isInterfaceEnabled] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network isInterfaceEnabled " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    ping() {
      let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "8.8.8.8";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      let guid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "2c6ff543-d929-4be4-a0d8-9abae2ca7471";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'ping', {
          "endpoint": endpoint,
          "packets": packets,
          "guid": guid
        }).then(result => {
          this.INFO(this.callsign + "[ping] result: " + result);
          if (result.success) resolve(result);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[ping] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network ping " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    pingNamedEndpoint() {
      let endpointName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "CMTS";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
      let guid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "2c6ff543-d929-4be4-a0d8-9abae2ca7471";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'pingNamedEndpoint', {
          "endpointName": endpointName,
          "packets": packets,
          "guid": guid
        }).then(result => {
          this.INFO(this.callsign + "[pingNamedEndpoint] result: " + result);
          if (result.success) resolve(result);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[pingNamedEndpoint] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network pingNamedEndpoint " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setDefaultInterface() {
      let interfaceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ETHERNET";
      let persist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setDefaultInterface', {
          "interface": interfaceName,
          "persist": persist
        }).then(result => {
          this.INFO(this.callsign + "[setDefaultInterface] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setDefaultInterface] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network setDefaultInterface " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setInterfaceEnabled(interfaceName) {
      let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let persist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setInterfaceEnabled', {
          "interface": interfaceName,
          "enabled": enabled,
          "persist": persist
        }).then(result => {
          this.INFO(this.callsign + "[setInterfaceEnabled] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setInterfaceEnabled] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network setInterfaceEnabled " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setIPSettings(IPSettings) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setIPSettings', IPSettings).then(result => {
          this.INFO(this.callsign + "[setIPSettings] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setIPSettings] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network setIPSettings " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getPublicIP() {
      let iface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ETHERNET";
      let ipv6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getPublicIP', {
          "iface": iface,
          "ipv6": ipv6
        }).then(result => {
          this.INFO(this.callsign + "[getPublicIP] result: " + result);
          if (result.success) resolve(result.public_ip);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getPublicIP] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network getPublicIP " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setStunEndPoint() {
      let server = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "global.stun.twilio.com";
      let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3478;
      let sync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
      let cache_timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setStunEndPoint', {
          "server": server,
          "port": port,
          "sync": sync,
          "timeout": timeout,
          "cache_timeout": cache_timeout
        }).then(result => {
          this.INFO(this.callsign + "[setStunEndPoint] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setStunEndPoint] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network setStunEndPoint " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    configurePNI() {
      let disableConnectivityTest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'configurePNI', {
          "disableConnectivityTest": disableConnectivityTest
        }).then(result => {
          this.INFO(this.callsign + "[configurePNI] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[configurePNI] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network configurePNI " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    trace() {
      let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "8.8.8.8";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'trace', {
          endpoint: endpoint,
          packets: packets
        }).then(result => {
          this.INFO(this.callsign + "[trace] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[trace] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network trace " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    traceNamedEndpoint() {
      let endpointName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "CMTS";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'trace', {
          "endpointName": endpointName,
          "packets": packets
        }).then(result => {
          this.INFO(this.callsign + "[traceNamedEndpoint] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[traceNamedEndpoint] error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkApiError", "Error in Thunder Network traceNamedEndpoint " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI thunder plugin apis.
   */
  class HDMIApi {
    constructor() {
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
      this._events = new Map();
      this.callsign = 'org.rdk.HdmiInput';

      // Updated as per https://github.com/rdkcentral/ThunderInterfaces/blob/master/interfaces/IPlayerInfo.h: PlaybackResolution
      this.resolution = {
        ResolutionUnknown: [1920, 1080],
        Resolution480: [640, 480],
        Resolution576: [768, 576],
        Resolution720: [1280, 720],
        Resolution1080: [1920, 1080],
        Resolution2160: [3840, 2160]
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Activated HdmiInput plugin');
          this._thunder.on(this.callsign, 'onInputStatusChanged', notification => {
            if (this._events.has('onInputStatusChanged')) {
              this._events.get('onInputStatusChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onDevicesChanged', notification => {
            if (this._events.has('onDevicesChanged')) {
              this._events.get('onDevicesChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onSignalChanged', notification => {
            if (this._events.has('onSignalChanged')) {
              this._events.get('onSignalChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'videoStreamInfoUpdate', notification => {
            if (this._events.has('videoStreamInfoUpdate')) {
              this._events.get('videoStreamInfoUpdate')(notification);
            }
          });
          if (result === null) resolve(true);else resolve(false);
        }).catch(err => {
          console.log('Failed to activate HdmiInput plugin', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiApiError", "Error while Thunder Controller HdmiApi activate " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    getHDMIDevices() {
      return new Promise(resolve => {
        // resolve([{id: 0,locator: "hdmiin://localhost/deviceid/0",connected: true,},{id: 1,locator: "hdmiin://localhost/deviceid/1",connected: false,},{id: 2,locator: "hdmiin://localhost/deviceid/2",connected: true,}]) //#forTesting
        this._thunder.call(this.callsign, 'getHDMIInputDevices').then(result => {
          resolve(result.devices);
        }).catch(err => {
          // reject(err) // #forTesting //make the api reject, instead of resolving empty array
          console.log("getHDMIDevices Error: ", JSON.stringify(err), " resolving empty array");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiApiError", "Error in Thunder HdmiApi getHDMIInputDevices " + JSON.stringify(err), false, null);
          resolve([]);
        });
      });
    }
    checkStatus(plugin) {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller.1', 'status@' + plugin).then(res => {
          console.log(JSON.stringify(res));
          resolve(res);
        }).catch(err => {
          console.error(JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiApiError", "Error while Thunder Controller.1 HdmiApi status " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getDimensions() {
      return new Promise(resolve => {
        // resolve([1920, 1080])//#forTesting
        this._thunder.call('PlayerInfo', 'resolution').then(result => {
          // We need only the Width & Height for rectangle.
          let result1 = result.slice(0, result.indexOf(result.indexOf('I') !== -1 ? 'I' : 'P'));
          resolve(this.resolution[result1]);
        }).catch(err => {
          console.log('Failed to fetch dimensions', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiApiError", "Error in Thunder playerInfo resolution " + JSON.stringify(err), false, null);
          resolve([1920, 1080]);
        });
      });
    }
    setHDMIInput(portDetails) {
      return new Promise(async (resolve, reject) => {
        // resolve(true)//#forTesting
        if (portDetails.connected) {
          this._thunder.call(this.callsign, 'startHdmiInput', {
            portId: portDetails.id
          }).then(async result => {
            const dimension = await this.getDimensions();
            this._thunder.call(this.callsign, 'setVideoRectangle', {
              x: 0,
              y: 0,
              w: dimension[0],
              h: dimension[1]
            });
            resolve(result);
          }).catch(err => {
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiApiError", "Error in Thunder HdmiApi startHdmiInput " + JSON.stringify(err), false, null);
            reject(err);
          });
        } else {
          reject(false);
        }
      });
    }
    stopHDMIInput() {
      return new Promise(resolve => {
        // resolve(true)//#forTesting
        this._thunder.call(this.callsign, 'stopHdmiInput').then(result => {
          resolve(result);
        });
      });
    }

    /**
    *Register events and event listeners.
    * @param {string} eventId
    * @param {function} callback
    *
    */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
  }

  var App_launched_via_Netflix_Button = {
  	source_type: 3,
  	iid: "00000001"
  };
  var App_launched_at_suspended_mode_at_power_on = {
  	source_type: 22,
  	iid: "00000002"
  };
  var App_launched_via_DIAL_request = {
  	source_type: 12,
  	iid: "00000003"
  };
  var App_launched_from_EPG_Grid = {
  	source_type: 3,
  	iid: "00000004"
  };
  var App_launched_via_channel_number = {
  	source_type: 3,
  	iid: "00000005"
  };
  var App_launched_from_channel_info_bar = {
  	source_type: 3,
  	iid: "00000006"
  };
  var App_launched_via_channel_surf_option = {
  	source_type: 3,
  	iid: "00000007"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Section = {
  	source_type: 3,
  	iid: "00000008"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page = {
  	source_type: 3,
  	iid: "00000009"
  };
  var NetflixIIDs = {
  	App_launched_via_Netflix_Button: App_launched_via_Netflix_Button,
  	App_launched_at_suspended_mode_at_power_on: App_launched_at_suspended_mode_at_power_on,
  	App_launched_via_DIAL_request: App_launched_via_DIAL_request,
  	App_launched_from_EPG_Grid: App_launched_from_EPG_Grid,
  	App_launched_via_channel_number: App_launched_via_channel_number,
  	App_launched_from_channel_info_bar: App_launched_from_channel_info_bar,
  	App_launched_via_channel_surf_option: App_launched_via_channel_surf_option,
  	App_launched_via_Netflix_Icon_On_The_Apps_Section: App_launched_via_Netflix_Icon_On_The_Apps_Section,
  	App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page: App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  //Payloads, and other keys related to alexa and voiceControl plugin.

  //app/shortcuts identifier and callsign map
  const AlexaLauncherKeyMap = {
    "amzn1.alexa-ask-target.app.70045": {
      "name": "YouTube",
      "callsign": "YouTube",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.50623": {
      "name": "YouTubeTV",
      "callsign": "YouTubeTV",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.72095": {
      "name": "Prime Video",
      "callsign": "Amazon",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.36377": {
      "name": "Netflix",
      "callsign": "Netflix",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.34908": {
      "name": "XUMO",
      "callsign": "HtmlApp",
      "url": "https://x1box-app.xumo.com/index.html"
    },
    "amzn1.alexa-ask-target.app.94721": {
      "name": "NBCU Peacock",
      "callsign": "Peacock",
      "url": ""
    },
    // // TODO: refactor
    // "amzn1.alexa-ask-target.app.73751": {
    //     "name": "Amazon Alexa",
    //     "callsign": "SmartScreen",
    //     "url": "",
    // },
    // // TODO: refactor
    // "amzn1.alexa-ask-target.app.32470": {
    //     "name": "Amazon Music",
    //     "callsign": "SmartScreen",
    //     "url": "",
    // },
    //shortcuts
    "amzn1.alexa-ask-target.shortcut.33122": {
      "name": "Home",
      "route": "menu"
    },
    "amzn1.alexa-ask-target.shortcut.28647": {
      "name": "Apps",
      "route": "apps"
    },
    "amzn1.alexa-ask-target.shortcut.82911": {
      "name": "Audio Output",
      "route": "settings/audio"
    },
    "amzn1.alexa-ask-target.shortcut.68228": {
      "name": "Guide",
      "route": "epg"
    },
    "amzn1.alexa-ask-target.shortcut.07395": {
      "name": "Settings",
      "route": "settings"
    },
    "amzn1.alexa-ask-target.shortcut.94081": {
      "name": "Bluetooth Settings",
      "route": "settings/bluetooth"
    },
    "amzn1.alexa-ask-target.app.30720": {
      "name": "Simple Player",
      "route": "player"
    },
    "amzn1.alexa-ask-target.shortcut.72631": {
      "name": "Language Settings",
      "route": "settings/other/language"
    },
    "amzn1.alexa-ask-target.shortcut.58566": {
      "name": "Network Settings",
      "route": "settings/network"
    },
    "amzn1.alexa-ask-target.shortcut.07345": {
      "name": "Power Settings",
      "route": "settings/other/energy"
    },
    "amzn1.alexa-ask-target.shortcut.12736": {
      "name": "Privacy Settings",
      "route": "settings/other/privacy"
    },
    "amzn1.alexa-ask-target.shortcut.69249": {
      "name": "Reset",
      "route": "settings/advanced/device/factoryReset"
    },
    "amzn1.alexa-ask-target.shortcut.78173": {
      "name": "Resolution Settings",
      "route": "settings/video/resolution"
    },
    "amzn1.alexa-ask-target.shortcut.94631": {
      "name": "Sleep timer",
      "route": "settings/other/timer"
    },
    "amzn1.alexa-ask-target.shortcut.32343": {
      "name": "Sound Settings",
      "route": "settings/audio"
    },
    "amzn1.alexa-ask-target.shortcut.10089": {
      "name": "System Information",
      "route": "settings/advanced/device/info"
    },
    "amzn1.alexa-ask-target.shortcut.01622": {
      "name": "Terms and Policy",
      "route": "settings/other/privacyPolicy"
    }
  };
  const errorPayload = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa",
          "name": "ErrorResponse",
          "messageId": "Unique identifier, preferably a version 4 UUID",
          "correlationToken": "Opaque correlation token that matches the request",
          "payloadVersion": "3"
        },
        "endpoint": {
          "endpointId": "Endpoint ID"
        },
        "payload": {
          "type": "Error type",
          "message": "Error message"
        }
      }
    }
  };
  const VolumePayload = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Speaker",
          "name": "VolumeChanged",
          "messageId": "8912c9cc-a770-4fe9-8bf1-87e01a4a1f0b"
        },
        "payload": {
          "volume": 30,
          "muted": false
        }
      }
    }
  };
  const ApplicationStateReporter = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa.ApplicationStateReporter",
          "name": "ForegroundApplication",
          "value": {
            "foregroundApplication": {
              "id": "amzn1.alexa-ask-target.shortcut.33122",
              "version": "1",
              "type": "vsk",
              "metadata": {
                "categories": ["OTHER"],
                "isVisible": true,
                "isHome": true
              }
            }
          }
        }
      }
    }
  };

  /* state: PLAYING/PAUSED/STOPPED */
  const PlaybackStateReport = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa.PlaybackStateReporter",
          "name": "playbackState",
          "value": {
            "state": "PLAYING"
          }
        }
      }
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class VoiceApi {
    constructor() {
      this._events = new Map();
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.INFO = function () {};
      this.LOG = function () {};
      this.ERR = console.error;
    }
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    activate() {
      return new Promise(resolve => {
        this.INFO("VoiceApi: activate.");
        this.thunder.Controller.activate({
          callsign: 'org.rdk.VoiceControl'
        }).then(() => {
          this.thunder.on('org.rdk.VoiceControl', 'onKeywordVerification', notification => {
            this.INFO('VoiceApi: onKeywordVerification ' + JSON.stringify(notification));
            if (this._events.has('onKeywordVerification')) {
              this._events.get('onKeywordVerification')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onServerMessage', notification => {
            this.INFO('VoiceApi: onServerMessage ' + JSON.stringify(notification));
            if (this._events.has('onServerMessage')) {
              this._events.get('onServerMessage')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onSessionBegin', notification => {
            this.INFO('VoiceApi: onSessionBegin ' + JSON.stringify(notification));
            if (this._events.has('onSessionBegin')) {
              this._events.get('onSessionBegin')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onSessionEnd', notification => {
            this.INFO('VoiceApi: onSessionEnd ' + JSON.stringify(notification));
            if (this._events.has('onSessionEnd')) {
              this._events.get('onSessionEnd')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onStreamBegin', notification => {
            this.INFO('VoiceApi: nStreamBegin ' + JSON.stringify(notification));
            if (this._events.has('onStreamBegin')) {
              this._events.get('onStreamBegin')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onStreamEnd', notification => {
            this.INFO('VoiceApi: onStreamEnd ' + JSON.stringify(notification));
            if (this._events.has('onStreamEnd')) {
              this._events.get('onStreamEnd')(notification);
            }
          });
          resolve(true);
        }).catch(err => {
          this.ERR('VoiceApi: Error Activation ', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error while Thunder Controller VoiceApi activate " + JSON.stringify(err), false, null);
        });
      });
    }
    deactivate() {
      return new Promise(resolve => {
        this.thunder.Controller.deactivate({
          callsign: 'org.rdk.VoiceControl'
        }).then(() => {
          this.INFO("VoiceApi: deactivated org.rdk.VoiceControl");
          resolve(true);
        }).catch(err => {
          this.ERR('VoiceApi: Error deactivation ', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error while Thunder Controller VoiceApi deactivate " + JSON.stringify(err), false, null);
        });
      });
    }
    configureVoice(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: configure params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'configureVoice', params).then(result => {
          this.INFO("VoiceApi: configureVoice: " + JSON.stringify(params) + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: configureVoice error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error while Thunder VoiceApi configureVoice " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    sendVoiceMessage(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: sendVoiceMessage params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'sendVoiceMessage', params).then(result => {
          this.INFO("VoiceApi: sendVoiceMessage result:", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: sendVoiceMessage error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi sendVoiceMessage " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setVoiceInit(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: setVoiceInit params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'setVoiceInit', params).then(result => {
          this.INFO("VoiceApi: setVoiceInit result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: setVoiceInit error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi setVoiceInit " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceSessionByText(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: voiceSessionByText params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionByText', params).then(result => {
          this.INFO("VoiceApi: voiceSessionByText result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionByText error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceSessionByText " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceSessionTypes() {
      return new Promise(resolve => {
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionTypes').then(result => {
          this.INFO("VoiceApi: voiceSessionTypes result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionTypes error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceSessionTypes " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceSessionRequest(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: voiceSessionRequest params", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionRequest', params).then(result => {
          this.INFO("VoiceApi: voiceSessionRequest result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionRequest error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceSessionRequest " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceSessionTerminate(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: voiceSessionTerminate params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionTerminate', params).then(result => {
          this.INFO("VoiceApi: voiceSessionTerminate result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionTerminate error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceSessionTerminate " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceSessionAudioStreamStart(params) {
      return new Promise(resolve => {
        this.INFO("VoiceApi: voiceSessionAudioStreamStart params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionAudioStreamStart', params).then(result => {
          this.INFO("VoiceApi: voiceSessionAudioStreamStart : " + JSON.stringify(params) + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionAudioStreamStart error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceSessionAudioStreamStart " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    voiceStatus() {
      return new Promise(resolve => {
        this.INFO("VoiceApi: voiceStatus");
        this.thunder.call('org.rdk.VoiceControl', 'voiceStatus').then(result => {
          this.INFO("VoiceApi: voiceStatus result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "VoiceApiError", "Error in Thunder VoiceApi voiceStatus " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
  }

  function _defineProperty$1(e, r, t) {
    return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _toPrimitive$1(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey$1(t) {
    var i = _toPrimitive$1(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }

  class RDKShellApis {
    constructor() {
      var _this = this;
      _defineProperty$1(this, "registerEvent", (eventId, callback) => {
        this._events.set(eventId, callback);
      });
      _defineProperty$1(this, "thunderCall", function (infoMessage, method) {
        let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let property = arguments.length > 3 ? arguments[3] : undefined;
        return new Promise((resolve, reject) => {
          _this.INFO('info', "RDKShellApi: ".concat(infoMessage, "."));
          _this.thunder.call(_this.callsign, method, params).then(result => {
            _this.LOG('info', "RDKShellApi: ".concat(infoMessage, ": ").concat(JSON.stringify(params), " result: ").concat(JSON.stringify(result)));
            if (result.success) {
              if (property === 'result') {
                resolve(result);
              } else {
                resolve(property ? result[property] : result.success);
              }
            } else {
              _this.ERR('error', "RDKShellApi: Error ".concat(infoMessage, " ").concat(JSON.stringify(params), " result: ").concat(JSON.stringify(result)));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "RDKShellApiError", "Error ".concat(infoMessage, " ").concat(JSON.stringify(params), " result: ").concat(JSON.stringify(result)), false, null);
              reject(result.success);
            }
          }).catch(err => {
            _this.ERR('error', "RDKShellApi: Error ".concat(infoMessage, " ").concat(err));
            reject(err);
          });
        });
      });
      _defineProperty$1(this, "getKeyRepeatsEnabled", () => this.thunderCall('getKeyRepeatsEnabled', 'getKeyRepeatsEnabled', {}, 'keyRepeat'));
      _defineProperty$1(this, "getLastWakeupKey", () => this.thunderCall('getLastWakeupKey', 'getLastWakeupKey', {}, 'result'));
      _defineProperty$1(this, "getLogLevel", () => this.thunderCall('getLogLevel', 'getLogLevel', {}, 'logLevel'));
      _defineProperty$1(this, "getLogsFlushingEnabled", () => this.thunderCall('getLogsFlushingEnabled', 'getLogsFlushingEnabled', {}, 'enabled'));
      _defineProperty$1(this, "getOpacity", client => this.thunderCall('getOpacity', 'getOpacity', {
        client
      }, 'opacity'));
      _defineProperty$1(this, "getScale", client => this.thunderCall('getScale', 'getScale', {
        client
      }, 'result'));
      _defineProperty$1(this, "getVirtualDisplayEnabled", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('getVirtualDisplayEnabled', 'getVirtualDisplayEnabled', {
          client,
          callsign
        }, 'enabled');
      });
      _defineProperty$1(this, "getVirtualResolution", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('getVirtualResolution', 'getVirtualResolution', {
          client,
          callsign
        }, 'result');
      });
      _defineProperty$1(this, "getVisibility", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('getVisibility', 'getVisibility', {
          client,
          callsign
        }, 'visible');
      });
      _defineProperty$1(this, "getZOrder", () => this.thunderCall('getZOrder', 'getZOrder', {}, 'clients'));
      _defineProperty$1(this, "getGraphicsFrameRate", () => this.thunderCall('getGraphicsFrameRate', 'getGraphicsFrameRate', {}, 'frameRate'));
      _defineProperty$1(this, "launch", params => this.thunderCall('launch', 'launch', params, 'result'));
      _defineProperty$1(this, "getBlockedAVApplications", () => this.thunderCall('getBlockedAVApplications', 'getBlockedAVApplications'));
      _defineProperty$1(this, "activate", () => this.thunderCall('activate', 'Controller.activate', {}));
      _defineProperty$1(this, "deactivate", () => this.thunderCall('deactivate', 'Controller.deactivate', {}));
      _defineProperty$1(this, "addAnimation", params => this.thunderCall('addAnimation', 'addAnimation', params));
      _defineProperty$1(this, "addKeyIntercept", params => this.thunderCall('addKeyIntercept', 'addKeyIntercept', params));
      _defineProperty$1(this, "addKeyIntercepts", params => this.thunderCall('addKeyIntercepts', 'addKeyIntercepts', params));
      _defineProperty$1(this, "addKeyListener", params => this.thunderCall('addKeyListener', 'addKeyListener', params));
      _defineProperty$1(this, "addKeyMetadataListener", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('addKeyMetadataListener', 'addKeyMetadataListener', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "createDisplay", params => this.thunderCall('createDisplay', 'createDisplay', params));
      _defineProperty$1(this, "destroy", callsign => this.thunderCall('destroy', 'destroy', {
        callsign
      }));
      _defineProperty$1(this, "enableInactivityReporting", function () {
        let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('enableInactivityReporting', 'enableInactivityReporting', {
          enable
        });
      });
      _defineProperty$1(this, "enableKeyRepeats", function () {
        let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('enableKeyRepeats', 'enableKeyRepeats', {
          enable
        });
      });
      _defineProperty$1(this, "enableLogsFlushing", function () {
        let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('enableLogsFlushing', 'enableLogsFlushing', {
          enable
        });
      });
      _defineProperty$1(this, "enableVirtualDisplay", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        let enable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return _this.thunderCall('enableVirtualDisplay', 'enableVirtualDisplay', {
          client,
          callsign,
          enable
        });
      });
      _defineProperty$1(this, "generateKey", params => this.thunderCall('generateKey', 'generateKey', params));
      _defineProperty$1(this, "getAvailableTypes", () => this.thunderCall('getAvailableTypes', 'getAvailableTypes', {}, "types"));
      _defineProperty$1(this, "getBounds", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('getBounds', 'getBounds', {
          client,
          callsign
        }, 'bounds');
      });
      _defineProperty$1(this, "getClients", () => this.thunderCall('getClients', 'getClients', {}, 'clients'));
      _defineProperty$1(this, "getCursorSize", () => this.thunderCall('getCursorSize', 'getCursorSize', {}, 'result'));
      _defineProperty$1(this, "getHolePunch", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('getHolePunch', 'getHolePunch', {
          client,
          callsign
        }, 'holePunch');
      });
      _defineProperty$1(this, "hideAllClients", function () {
        let hide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('hideAllClients', 'hideAllClients', {
          hide
        });
      });
      _defineProperty$1(this, "hideCursor", () => this.thunderCall('hideCursor', 'hideCursor', {}));
      _defineProperty$1(this, "hideFullScreenImage", () => this.thunderCall('hideFullScreenImage', 'hideFullScreenImage', {}));
      _defineProperty$1(this, "hideSplashLogo", () => this.thunderCall('hideSplashLogo', 'hideSplashLogo', {}));
      _defineProperty$1(this, "ignoreKeyInputs", function () {
        let ignore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('ignoreKeyInputs', 'ignoreKeyInputs', {
          ignore
        });
      });
      _defineProperty$1(this, "injectKey", params => this.thunderCall('injectKey', 'injectKey', params));
      _defineProperty$1(this, "kill", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('kill', 'kill', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "launchApplication", params => this.thunderCall('launchApplication', 'launchApplication', params));
      _defineProperty$1(this, "launchResidentApp", () => this.thunderCall('launchResidentApp', 'launchResidentApp', {}));
      _defineProperty$1(this, "moveBehind", (client, target) => this.thunderCall('moveBehind', 'moveBehind', {
        client,
        target
      }));
      _defineProperty$1(this, "moveToBack", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('moveToBack', 'moveToBack', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "moveToFront", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('moveToFront', 'moveToFront', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "removeAllKeyIntercepts", () => this.thunderCall('removeAllKeyIntercepts', 'removeAllKeyIntercepts', {}));
      _defineProperty$1(this, "removeAllKeyListeners", () => this.thunderCall('removeAllKeyListeners', 'removeAllKeyListeners', {}));
      _defineProperty$1(this, "removeAnimation", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('removeAnimation', 'removeAnimation', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "removeKeyIntercept", params => this.thunderCall('removeKeyIntercept', 'removeKeyIntercept', params));
      _defineProperty$1(this, "removeKeyListener", params => this.thunderCall('removeKeyListener', 'removeKeyListener', params));
      _defineProperty$1(this, "removeKeyMetadataListener", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('removeKeyMetadataListener', 'removeKeyMetadataListener', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "resetInactivityTime", () => this.thunderCall('resetInactivityTime', 'resetInactivityTime', {}));
      _defineProperty$1(this, "resumeApplication", client => this.thunderCall('resumeApplication', 'resumeApplication', {
        client
      }));
      _defineProperty$1(this, "scaleToFit", params => this.thunderCall('scaleToFit', 'scaleToFit', params));
      _defineProperty$1(this, "setBounds", params => this.thunderCall('setBounds', 'setBounds', params));
      _defineProperty$1(this, "setCursorSize", (width, height) => this.thunderCall('setCursorSize', 'setCursorSize', {
        width,
        height
      }));
      _defineProperty$1(this, "setFocus", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        return _this.thunderCall('setFocus', 'setFocus', {
          client,
          callsign
        });
      });
      _defineProperty$1(this, "setHolePunch", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        let holePunch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return _this.thunderCall('setHolePunch', 'setHolePunch', {
          client,
          callsign,
          holePunch
        });
      });
      _defineProperty$1(this, "setInactivityInterval", interval => this.thunderCall('setInactivityInterval', 'setInactivityInterval', {
        interval
      }));
      _defineProperty$1(this, "setLogLevel", function () {
        let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "INFO";
        return _this.thunderCall('setLogLevel', 'setLogLevel', {
          logLevel
        });
      });
      _defineProperty$1(this, "setOpacity", (client, opacity) => this.thunderCall('setOpacity', 'setOpacity', {
        client,
        opacity
      }));
      _defineProperty$1(this, "setScale", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        let xScale = arguments.length > 2 ? arguments[2] : undefined;
        let yScale = arguments.length > 3 ? arguments[3] : undefined;
        return _this.thunderCall('setScale', 'setScale', {
          client,
          callsign,
          xScale,
          yScale
        });
      });
      _defineProperty$1(this, "setScreenResolution", (w, h) => this.thunderCall('setScreenResolution', 'setScreenResolution', {
        w,
        h
      }));
      _defineProperty$1(this, "setTopmost", function (client) {
        let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        let focus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return _this.thunderCall('setTopmost', 'setTopmost', {
          client,
          topmost,
          focus
        });
      });
      _defineProperty$1(this, "setVisibility", function (client) {
        let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : client;
        let visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return _this.thunderCall('setVisibility', 'setVisibility', {
          client,
          callsign,
          visible
        });
      });
      _defineProperty$1(this, "setGraphicsFrameRate", frameRate => this.thunderCall('setGraphicsFrameRate', 'setGraphicsFrameRate', {
        frameRate
      }));
      _defineProperty$1(this, "showCursor", () => this.thunderCall('showCursor', 'showCursor', {}));
      _defineProperty$1(this, "showFullScreenImage", path => this.thunderCall('showFullScreenImage', 'showFullScreenImage', {
        path
      }));
      _defineProperty$1(this, "showSplashLogo", displayTime => this.thunderCall('showSplashLogo', 'showSplashLogo', {
        displayTime
      }));
      _defineProperty$1(this, "showWatermark", function () {
        let show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return _this.thunderCall('showWatermark', 'showWatermark', {
          show
        });
      });
      _defineProperty$1(this, "suspend", callsign => this.thunderCall('suspend', 'suspend', {
        callsign
      }));
      _defineProperty$1(this, "suspendApplication", client => this.thunderCall('suspendApplication', 'suspendApplication', {
        client
      }));
      _defineProperty$1(this, "keyRepeatConfig", params => this.thunderCall('keyRepeatConfig', 'keyRepeatConfig', params));
      _defineProperty$1(this, "setAVBlocked", function (callsign) {
        let blocked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return _this.thunderCall('setAVBlocked', 'setAVBlocked', {
          callsign,
          blocked
        });
      });
      _defineProperty$1(this, "restore", callsign => this.thunderCall('restore', 'restore', {
        callsign
      }));
      _defineProperty$1(this, "hibernate", function (callsign) {
        let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        let procsequence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return _this.thunderCall('hibernate', 'hibernate', {
          callsign,
          timeout,
          procsequence
        });
      });
      this._events = new Map();
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.callsign = 'org.rdk.RDKShell';
      this.INFO = console.info;
      this.LOG = console.log;
      this.ERR = console.error;
    }
  }
  const rdkShellApisInstance = new RDKShellApis();

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$k = thunderJS$1(CONFIG.thunderConfig);
  let instance$5 = null;
  class AlexaApi extends VoiceApi {
    static get() {
      if (instance$5 == null) {
        instance$5 = new AlexaApi();
      }
      return instance$5;
    }

    /* Can be used to reduce enableSmartScreen() call */
    isSmartScreenActiavated() {
      let appApi = new AppApi();
      appApi.checkStatus('SmartScreen').then(result => {
        console.log("AlexaAPI: isSmartScreenActiavated result-" + JSON.stringify(result[0].state.toLowerCase()));
        switch (result[0].state.toLowerCase()) {
          case "resumed":
          case "activated":
            break;
          default:
            return false;
        }
        return true;
      }).catch(err => {
        console.error("AlexaAPI: isSmartScreenActiavated error-", err);
        return false;
      });
    }
    enableSmartScreen() {
      thunder$k.Controller.activate({
        callsign: 'SmartScreen'
      }).then(res => {
        console.log("AlexaAPI: Activate SmartScreen result: " + res);
      }).catch(err => {
        console.error("AlexaAPI: Activate SmartScreen ERROR!: ", err);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", "Thunder Controller AlexaAPI: Activate SmartScreen error with ".concat(err), false, null);
      });
    }
    disableSmartScreen() {
      thunder$k.Controller.deactivate({
        callsign: 'SmartScreen'
      }).then(res => {
        console.log("AlexaAPI: Deactivate SmartScreen result: " + res);
      }).catch(err => {
        console.error("AlexaAPI: Deactivate SmartScreen ERROR!: ", err);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", "Thunder Controller AlexaAPI: Deactivate SmartScreen error with ".concat(err), false, null);
      });
    }
    displaySmartScreenOverlay() {
      let focused = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      let visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      rdkShellApisInstance.moveToFront("SmartScreen");
      rdkShellApisInstance.setOpacity("SmartScreen", opacity);
      rdkShellApisInstance.setVisibility("SmartScreen", visible);
      if (focused) {
        rdkShellApisInstance.setFocus("SmartScreen");
      }
    }
    reportApplicationState() {
      let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "menu";
      let isRoute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.checkAlexaAuthStatus() != "AlexaUserDenied" && this.checkAlexaAuthStatus() != "AlexaAuthPending") {
        /* retrieve 'app' matching from AlexaLauncherKeyMap. */
        let appStateReportPayload = ApplicationStateReporter;
        let isListedApp = false;
        for (let [key, value] of Object.entries(AlexaLauncherKeyMap)) {
          if (isRoute && Object.prototype.hasOwnProperty.call(value, "route") && value.route === app.toLowerCase()) {
            appStateReportPayload.msgPayload.event.header.value.foregroundApplication.id = key;
            if (app.toLowerCase() === "menu") appStateReportPayload.msgPayload.event.header.value.foregroundApplication.metadata.isHome = true;
            isListedApp = true;
            break;
          } else if (!isRoute && (value.callsign === app || value.url === app)) {
            appStateReportPayload.msgPayload.event.header.value.foregroundApplication.id = key;
            appStateReportPayload.msgPayload.event.header.value.foregroundApplication.metadata.isHome = false;
            isListedApp = true;
            break;
          }
        }
        /* Send the new app state object if its a known app. */
        if (isListedApp) {
          console.warn("Sending app statereport to Alexa:" + JSON.stringify(appStateReportPayload));
          this.sendVoiceMessage(appStateReportPayload);
        } else {
          console.error("Alexa reportApplicationState; no match found, won't send state report.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", 'Alexa reportApplicationState; no match found, wont send state report.', false, null);
        }
      } else {
        console.log("Alexa reportApplicationState: AlexaUserDenied/AlexaAuthPending, skip state reporting.");
      }
    }
    reportVolumeState() {
      let volumeLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      let muteStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let messageId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      if (volumeLevel != undefined) VolumePayload.msgPayload.event.payload.volume = volumeLevel;
      if (muteStatus != undefined) VolumePayload.msgPayload.event.payload.muted = muteStatus;
      if (messageId != undefined) VolumePayload.msgPayload.event.header.messageId = messageId;
      console.log("Sending volume statereport to Alexa:", VolumePayload);
      this.sendVoiceMessage(VolumePayload);
    }
    updateDeviceLanguageInAlexa(updatedLanguage) {
      let updatedLan = [];
      updatedLan.push(updatedLanguage);
      let payload = {
        "msgPayload": {
          "DeviceSettings": "Set Device Settings",
          "values": {
            "locale": updatedLan
          }
        }
      };
      console.log("Sending language statereport to Alexa:", updatedLan);
      this.sendVoiceMessage(payload);
    }

    //reportDeviceTimeZone(updatedTimeZone) {
    updateDeviceTimeZoneInAlexa(updatedTimeZone) {
      console.log("updateDeviceTimeZoneInAlexa sending :" + updatedTimeZone);
      let payload = {
        "msgPayload": {
          "DeviceSettings": "Set Device Settings",
          "values": {
            "timezone": updatedTimeZone
          }
        }
      };
      this.sendVoiceMessage(payload);
    }
    reportErrorState(directive) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ENDPOINT_UNREACHABLE";
      let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "ENDPOINT_UNREACHABLE";
      errorPayload.msgPayload.event.payload.type = type;
      errorPayload.msgPayload.event.payload.message = message;
      errorPayload.msgPayload.event.header.correlationToken = directive.header.correlationToken;
      errorPayload.msgPayload.event.header.payloadVersion = directive.header.payloadVersion;
      errorPayload.msgPayload.event.endpoint.endpointId = directive.endpoint.endpointId;
      errorPayload.msgPayload.event.header.messageId = directive.header.messageId;
      console.log("AlexaAPI: reportErrorState payload:", errorPayload);
      this.sendVoiceMessage(errorPayload);
    }
    reportPlaybackState() {
      let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "STOPPED";
      PlaybackStateReport.msgPayload.event.header.value = state;
      console.log("AlexaAPI: reportPlaybackState payload:", PlaybackStateReport);
      this.sendVoiceMessage(PlaybackStateReport);
    }
    getAlexaDeviceSettings() {
      this.sendVoiceMessage({
        "msgPayload": {
          "DeviceSettings": "Get Device Settings"
        }
      });
    }
    pingAlexaSDK() {
      /* Temporary fix to wake AVS SDK socket connectivity; this logic will be moved to middleware */
      this.sendVoiceMessage({
        "msgPayload": {
          "KeepAlive": "ping to awake AVS SDK"
        }
      });
    }
    /**
     * Function to send voice message.
     */
    resetAVSCredentials() {
      return new Promise(resolve => {
        Storage$1.set("AlexaVoiceAssitantState", "AlexaAuthPending");
        thunder$k.Controller.activate({
          callsign: 'SmartScreen'
        }).then(() => {
          console.log("AlexaAPI: resetAVSCredentials activating SmartScreen instance.");
        }).catch(err => {
          console.error("AlexaAPI: resetAVSCredentials activate SmartScreen ERROR!: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", "Thunder Controller AlexaAPI: resetAVSCredentials activating SmartScreen error with ".concat(JSON.stringify(err)), false, null);
        });
        this.sendVoiceMessage({
          "msgPayload": {
            "event": "ResetAVS"
          }
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AlexaAPI: resetAVSCredentials ERROR!: " + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", "Thunder Controller AlexaAPI: resetAVSCredentials Activate ERROR!: ".concat(JSON.stringify(err)), false, null);
          resolve(false);
        });
      });
    }

    /**
     * User can opt out Alexa; could be in Auth state or Some generic Alexa Error after Auth completed.
     * Return respective map so that logic can be drawn based on that.
     */
    checkAlexaAuthStatus() {
      if (Storage$1.get("AlexaVoiceAssitantState") === undefined || Storage$1.get("AlexaVoiceAssitantState") === null || Storage$1.get("AlexaVoiceAssitantState") === "AlexaAuthPending") return "AlexaAuthPending"; // Do not handle Alexa Related Errors; only Handle its Auth status.
      else return Storage$1.get("AlexaVoiceAssitantState"); // Return the stored value of AlexaVoiceAssitantState
    }
    setAlexaAuthStatus() {
      let newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Storage$1.set("AlexaVoiceAssitantState", newState);
      if (newState === "AlexaUserDenied") {
        this.configureVoice({
          "enable": false
        });
        /* Free up Smartscreen resources */
        thunder$k.Controller.deactivate({
          callsign: 'SmartScreen'
        }).then(() => {
          console.log("AlexaAPI: deactivated SmartScreen instance.");
        }).catch(err => {
          console.error("AlexaAPI: deactivate SmartScreen ERROR!: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AlexaAPIError", "Thunder Controller AlexaAPI: deactivate SmartScreen ERROR: ".concat(JSON.stringify(err)), true, null);
        });
      } else {
        this.configureVoice({
          "enable": true
        });
      }
      console.warn("setAlexaAuthStatus with ", newState);
    }

    /**
     * To track playback state of Alexa Smartscreen App(AmazonMusic or anything else)
     */
    checkAlexaSmartscreenAudioPlaybackState() {
      if (Storage$1.get("AlexaSmartscreenAudioPlaybackState") === null || Storage$1.get("AlexaSmartscreenAudioPlaybackState") === "null") return "stopped"; // Assume default state.
      else return Storage$1.get("AlexaSmartscreenAudioPlaybackState");
    }
    setAlexaSmartscreenAudioPlaybackState() {
      let newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Storage$1.set("AlexaSmartscreenAudioPlaybackState", newState);
      console.log("setAlexaSmartscreenAudioPlaybackState with ", newState);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$j = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class that contains functions which commuicates with thunder API's
   */
  class AppApi {
    constructor() {
      this.activatedForeground = false;
      this._events = new Map();
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    fetchTimeZone() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getTimeZones').then(result => {
          resolve(result.zoneinfo);
        }).catch(err => {
          console.error('AppAPI Cannot fetch time zone', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getTimeZones" + err, false, null);
          resolve({});
        });
      });
    }

    /**
     * Function to launch Html app.
     * @param {String} url url of app.
     */
    getIP() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.System'
        }).then(() => {
          thunder$j.call('org.rdk.System', 'getDeviceInfo', {
            params: 'estb_ip'
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            console.error("AppAPI System getDeviceInfo estb_ip failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.NETWORK, "Network Error", "Error in Thunder system getDeviceInfo" + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error("AppAPI activate System failed." + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "Network Error", "Error in Thunder system activation " + JSON.stringify(err), false, null);
        });
      });
    }
    /**
    *  Function to get timeZone
    */
    getZone() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getTimeZoneDST').then(result => {
          resolve(result.timeZone);
        }).catch(err => {
          console.error('AppAPI System plugin getTimeZoneDST failed.' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getTimeZoneDST" + JSON.stringify(err), false, null);
          resolve(undefined);
        });
      });
    }
    setZone(zone) {
      console.log(zone);
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'setTimeZoneDST', {
          timeZone: zone
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI System plugin setTimeZoneDST failed." + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system setTimeZoneDSt" + JSON.stringify(err), false, null);
          resolve(false);
        });
      }).catch(err => {
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system setTimeZoneDST " + JSON.stringify(err), false, null);
        console.error("AppAPI activate System failed." + JSON.stringify(err));
      });
    }
    getPluginStatus(plugin) {
      return new Promise((resolve, reject) => {
        thunder$j.call('Controller', "status@".concat(plugin)).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI Controller plugin '" + plugin + "' status check failed.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system status " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    /**
     * Function to get resolution of the display screen.
     */
    getResolution() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getCurrentResolution', {
          "videoDisplay": "HDMI0"
        }).then(result => {
          resolve(result.resolution);
        }).catch(err => {
          console.error("AppAPI DisplaySettings plugin getCurrentResolution failed." + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", "Error in Thunder displaySettings getCurrentResolution " + JSON.stringify(err), false, null);
          resolve('NA');
        });
      });
    }
    activateDisplaySettings() {
      return new Promise(resolve => {
        const systemcCallsign = "org.rdk.DisplaySettings";
        thunder$j.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings failed.' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error while Thunder Controller displaysettings activate ' + JSON.stringify(err), false, null); // change from here on monday
        });
      });
    }
    getSupportedResolutions() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$j.call('org.rdk.DisplaySettings', 'getSupportedResolutions', {
            params: 'HDMI0'
          }).then(result => {
            resolve(result.supportedResolutions);
          }).catch(err => {
            console.error("AppAPI DisplaySettings getSupportedResolutions failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", "Error in Thunder displaySettings getSupportedResolutions " + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error while Thunder Controller displaysettings activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to set the display resolution.
     */
    setResolution(res) {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$j.call('org.rdk.DisplaySettings', 'setCurrentResolution', {
            videoDisplay: 'HDMI0',
            resolution: res,
            persist: true
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            console.error("AppAPI DisplaySettings setCurrentResolution failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error in Thunder displaysettings setCurrentResolution ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error while Thunder Controller displaysettings activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to get HDCP Status.
     */
    getHDCPStatus() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.HdcpProfile'
        }).then(() => {
          thunder$j.call('org.rdk.HdcpProfile', 'getHDCPStatus').then(result => {
            console.log("AppAPI HdcpProfile getHDCPStatus : " + JSON.stringify(result.HDCPStatus));
            resolve(result.HDCPStatus);
          }).catch(err => {
            console.error("AppAPI HdcpProfile getHDCPStatus failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "HDCPError", 'Error in Thunder HdcpProfile getHDCPStatus ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate HdcpProfile ', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HDCPError", 'Error while Thunder Controller HdcpProfile activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to get TV HDR Support.
     */
    getTvHDRSupport() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$j.call('org.rdk.DisplaySettings', 'getTvHDRSupport').then(result => {
            console.log("AppAPI DisplaySettings getTvHDRSupport : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error("AppAPI DisplaySettings getTvHDRSupport failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error in Thunder DisplaySettings getTvHDRSupport ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", 'Error while Thunder Controller DisplaySettings activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to get settop box HDR Support.
     */
    getSettopHDRSupport() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$j.call('org.rdk.DisplaySettings', 'getSettopHDRSupport').then(result => {
            console.log("AppAPI DisplaySettings getSettopHDRSupport : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error('AppAPI DisplaySettings getSettopHDRSupport failed ', JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error in Thunder DisplaySettings getSettopHDRSupport ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error while Thunder Controller DisplaySettings activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to get HDR Format in use.
     */
    getHDRSetting() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'DisplayInfo'
        }).then(() => {
          thunder$j.call('DisplayInfo', 'hdrsetting').then(result => {
            console.log("AppAPI DisplayInfo hdrsetting : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error("AppAPI DisplayInfo hdrsetting failed : " + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error in fetching Thunder DisplayInfo hdrsetting ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.log('AppAPI activate DisplayInfo Error', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error while Thunder Controller DisplayInfo activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to get DRMs.
     */
    getDRMS() {
      return new Promise(resolve => {
        thunder$j.Controller.activate({
          callsign: 'OCDM'
        }).then(() => {
          thunder$j.call('OCDM', 'drms').then(result => {
            console.log("AppAPI OCDM supported drms: " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error("AppAPI OCDM drms failed." + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "OCDMError", 'Error in fetching Thunder OCDM drms ' + JSON.stringify(err), false, null);
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate OCDM error:', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "OCDMError", 'Error while Thunder Controller OCDM activate ' + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to clear cache.
     */
    clearCache() {
      return new Promise(resolve => {
        thunder$j.call(GLOBALS.selfClientName, 'delete', {
          path: ".cache"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI ResidentApp delete cache failed.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "Cache failure", JSON.stringify(err), false, null);
          resolve(err);
        });
      });
    }
    async getAvailableTypes() {
      return rdkShellApisInstance.getAvailableTypes().then(types => {
        // Include NativeApp as well as its not being included from backend.
        if (!types.includes("NativeApp")) types.push("NativeApp");
        console.log("RDKShell.getAvailableTypes:", JSON.stringify(types));
        resolve(types);
      }).catch(err => {
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "Cache failure", 'Error in fetching Thunder RDKShell getAvailableTypes ' + JSON.stringify(err), false, null);
        resolve(false);
      });
    }

    /**
     * Function to launch All types of apps. Accepts 2 params.
     * @param {String} callsign String required callsign of the particular app.
     * @param {Object} args Object optional depending on following properties.
     *  @property {string} url: optional for YouTube & netflix | required for Lightning and WebApps
     *  @property {string} launchLocation: optional | to pass Netflix IIDs or YouTube launch reason | launchLocation value is one among these values ["mainView", "dedicatedButton", "appsMenu", "epgScreen", "dial", "gracenote","alexa"]
     *  @property {boolean} preventInternetCheck: optional | true will prevent bydefault check for internet
     *  @property {boolean} preventCurrentExit: optional |  true will prevent bydefault launch of previous app
     */

    async launchApp(callsign, args) {
      Storage$1.set("appSwitchingInProgress", true);
      const saveAbleRoutes = ["menu", "epg", "apps"]; //routing back will happen to only these routes, otherwise it will default to #menu when exiting the app.
      const lastVisitedRoute = Router.getActiveHash();
      if (saveAbleRoutes.includes(lastVisitedRoute)) {
        Storage$1.set("lastVisitedRoute", lastVisitedRoute);
      } else {
        Storage$1.set("lastVisitedRoute", "menu");
      }
      Router.navigate("applauncher");
      console.log("AppAPI launchApp called with: ", callsign, args);
      if (callsign.startsWith("YouTube")) {
        Storage$1.set(callsign + "LaunchLocation", args.launchLocation);
      }
      let url,
        preventInternetCheck,
        preventCurrentExit,
        launchLocation,
        gracenoteUrl = null;
      if (args) {
        url = args.url;
        preventInternetCheck = args.preventInternetCheck;
        preventCurrentExit = args.preventCurrentExit;
        launchLocation = args.launchLocation;
      }
      const launchLocationKeyMapping = {
        //currently supported launch locations by the UI and mapping to corresponding reason/keys for IID
        "mainView": {
          "YouTube": "menu",
          "YouTubeTV": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        },
        "dedicatedButton": {
          "YouTube": "remote",
          "YouTubeTV": "remote",
          "Netflix": "App_launched_via_Netflix_Button"
        },
        "appsMenu": {
          "YouTube": "menu",
          "YouTubeTV": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Section"
        },
        "epgScreen": {
          "YouTube": "guide",
          "YouTubeTV": "guide",
          "Netflix": "App_launched_from_EPG_Grid"
        },
        "dial": {
          "YouTube": "dial",
          "YouTubeTV": "dial",
          "Netflix": "App_launched_via_DIAL_request"
        },
        "gracenote": {
          "YouTube": "launcher",
          "YouTubeTV": "launcher",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        },
        "alexa": {
          "YouTube": "voice",
          "YouTubeTV": "voice",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        }
      };
      if (launchLocation && launchLocationKeyMapping[launchLocation]) {
        if (callsign === "Netflix" || callsign.startsWith("YouTube")) {
          /* Gracenote provides shortened url which shall only be deeplinked; do not use for activation. */
          if (launchLocation === "gracenote") {
            gracenoteUrl = url;
          }
          launchLocation = launchLocationKeyMapping[launchLocation][callsign];
        }
      }
      console.log("AppAPI launchApp with callsign: " + callsign + " | url: " + url + " | preventInternetCheck: " + preventInternetCheck + " | preventCurrentExit: " + preventCurrentExit + " | launchLocation: " + launchLocation);
      let IIDqueryString = "";
      if (callsign === "Netflix") {
        let netflixIids = await this.getNetflixIIDs();
        if (launchLocation) {
          IIDqueryString = "source_type=".concat(netflixIids[launchLocation].source_type, "&iid=").concat(netflixIids[launchLocation].iid);
          if (url) {
            IIDqueryString = "&" + IIDqueryString; //so that IIDqueryString can be appended with url later.
          }
        } else {
          console.warn("AppAPI launchLocation(IID) not specified while launching netflix");
        }
      }
      const availableCallsigns = await rdkShellApisInstance.getAvailableTypes();
      if (!availableCallsigns.includes(callsign)) {
        Storage$1.set("appSwitchingInProgress", false);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
        return Promise.reject("Can't launch App: " + callsign + " | Error: callsign not found!");
      }
      if (!preventInternetCheck) {
        let internet = await Network.get().isConnectedToInternet();
        if (!internet) {
          Storage$1.set("appSwitchingInProgress", false);
          Router.navigate(Storage$1.get("lastVisitedRoute"));
          return Promise.reject("No Internet Available, can't launchApp.");
        }
      }
      const currentApp = GLOBALS.topmostApp; //get it from stack if required. | current app ==="" means residentApp

      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      try {
        if (callsign != "NativeApp") {
          pluginStatus = await this.getPluginStatus(callsign);
          pluginState = pluginStatus[0].state;
        }
      } catch (err) {
        console.error(err);
        Storage$1.set("appSwitchingInProgress", false);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
        return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
      }
      console.log("AppAPI " + callsign + " : pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
      if (callsign.startsWith("Amazon") || callsign.startsWith("Netflix") || callsign.startsWith("YouTube")) {
        if (pluginState === 'hibernated') {
          thunder$j.call('org.rdk.RDKShell.1', 'restore', {
            "callsign": callsign
          }).then(res => {
            console.log(JSON.stringify(res));
          });
        }
      }
      if (callsign === "Netflix") {
        if (pluginState === "deactivated" || pluginState === "deactivation") {
          //netflix cold launch scenario
          console.log("AppAPI Netflix : ColdLaunch");
          if (Router.getActivePage().showSplashImage) {
            Router.getActivePage().showSplashImage(callsign); //to make the splash image for netflix visible
          }
          if (url) {
            try {
              console.log("AppAPI Netflix ColdLaunch passing netflix url & IIDqueryString using configureApplication method:  ", url, IIDqueryString);
              await this.configureApplication("Netflix", url + IIDqueryString);
            } catch (err) {
              console.error("AppAPI Netflix configureApplication error: ", err);
            }
          } else {
            try {
              console.log("AppAPI Netflix ColdLaunch passing netflix IIDqueryString using configureApplication method:  ", IIDqueryString);
              await this.configureApplication("Netflix", IIDqueryString);
            } catch (err) {
              console.error("AppAPI Netflix configureApplication error: ", err);
            }
          }
        } else {
          //netflix hot launch scenario
          console.log("AppAPI Netflix : HotLaunch");
          if (url) {
            try {
              console.log("AppAPI Netflix HotLaunch passing netflix url & IIDqueryString using systemcommand method: ", url, IIDqueryString);
              await thunder$j.call("Netflix", "systemcommand", {
                command: url + IIDqueryString
              });
            } catch (err) {
              console.error("AppAPI Netflix systemcommand error: ", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder Netflix systemcommand " + JSON.stringify(err), false, null);
            }
          } else {
            try {
              console.log("AppAPI Netflix HotLaunch passing netflix IIDqueryString using systemcommand method: ", IIDqueryString);
              await thunder$j.call("Netflix", "systemcommand", {
                command: IIDqueryString
              });
            } catch (err) {
              console.error("AppAPI Netflix systemcommand error: ", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder Netflix systemcommand " + JSON.stringify(err), false, null);
            }
          }
        }
      }
      let params = {
        "callsign": callsign,
        "type": callsign,
        "configuration": {}
      };
      if (url && (callsign === "LightningApp" || callsign === "HtmlApp" || callsign === "NativeApp")) {
        //for lightning/htmlapp url is passed via rdkshell.launch method
        params.uri = url;
      } else if (callsign.startsWith("YouTube")) {
        let language = Language$1.get();
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US"; //default to english US if language is not available.
        if (gracenoteUrl === null) {
          url = url ? url : Storage$1.get(callsign + "DefaultURL");
        } else {
          /* Gracenote provided url cannot be used for 'Configuring' plugin. Use only to deeplink. */
          url = Storage$1.get(callsign + "DefaultURL");
        }
        if (url) {
          if (!url.includes("?")) {
            url += "?";
          }
          if (!url.includes("inApp=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += GLOBALS.topmostApp === callsign ? "inApp=true" : "inApp=false";
          }
          if (!url.includes("launch=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += "launch=" + launchLocation;
          }
          if (launchLocation === "voice" && !url.includes("vs=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += "vs=2"; // YT Dev Doc specific to Alexa
          }
          console.log("AppAPI " + callsign + " is being launched using the url: " + url);
        }
        params.configuration = {
          //for gracenote cold launch url needs to be re formatted to youtube.com/tv/
          "language": language,
          "url": url,
          "launchtype": "launch=" + launchLocation
        };
        params.type = "Cobalt";
      } else if (callsign === "Amazon") {
        let language = Language$1.get();
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US";
        params.configuration = {
          "deviceLanguage": language
        };
      } else if (callsign === "Netflix") {
        let language = Language$1.get();
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US";
        params.configuration = {
          "language": language
        };
      }
      if (!preventCurrentExit && currentApp !== GLOBALS.selfClientName && currentApp !== callsign) {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack
        try {
          console.log("AppAPI calling exitApp with params: " + callsign + " and exitInBackground " + currentApp + " true.");
          await this.exitApp(currentApp, true);
        } catch (err) {
          console.error("AppAPI currentApp " + currentApp + " exit failed!: launching new app...");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppError", "exit failed! for ".concat(currentApp, " with ").concat(JSON.stringify(err), ".So launching new app..."), false, null);
        }
      }
      if (currentApp === GLOBALS.selfClientName && callsign !== "Netflix") {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack | for netflix keep the splash screen visible till it launches
        rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
      }
      if (callsign === "Netflix") {
        //special case for netflix to show splash screen
        params.behind = GLOBALS.selfClientName; //to make the app launch behind resident app | app will be moved to front after first frame event is triggered
      }
      if (JSON.stringify(params.configuration) === '{}') {
        delete params.configuration;
      }
      console.log("AppAPI RDKShell launch with params: ", params);
      return new Promise((resolve, reject) => {
        if (callsign === "NativeApp") {
          // Could be coming from PartnerApp.
          params.client = callsign;
          params.mimeType = "application/native";
          rdkShellApisInstance.launchApplication(params).then(res => {
            console.log("AppAPI ".concat(callsign, " : Launch results in ").concat(JSON.stringify(res)));
            if (res.success) {
              AlexaApi.get().reportApplicationState(callsign);
              if (args.appIdentifier) {
                let order = Storage$1.get("appCarouselOrder");
                if (!order) {
                  Storage$1.set("appCarouselOrder", "");
                } else {
                  let storedApps = order.split(",");
                  let ix = storedApps.indexOf(args.appIdentifier);
                  if (ix != -1) {
                    storedApps.splice(ix, 1);
                  }
                  storedApps.unshift(args.appIdentifier);
                  Storage$1.set("appCarouselOrder", storedApps.toString());
                }
              }
              GLOBALS.topmostApp = callsign;
              Storage$1.set("appSwitchingInProgress", false);
              resolve(res);
            } else {
              console.error("AppAPI failed to launchApp(success false) : ", callsign, " ERROR: ", JSON.stringify(res));
              Storage$1.set("appSwitchingInProgress", false);
              Router.navigate(Storage$1.get("lastVisitedRoute"));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launchApplication " + JSON.stringify(res), false, null);
              reject(res);
            }
          }).catch(err => {
            console.error("AppAPI failed to launchApp: ", callsign, " ERROR: ", JSON.stringify(err), " | Launching residentApp back");
            rdkShellApisInstance.kill(callsign);
            this.launchResidentApp(GLOBALS.selfClientName);
            Storage$1.set("appSwitchingInProgress", false);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launchApplication " + JSON.stringify(err), false, null);
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            reject(err);
          });
        } else {
          rdkShellApisInstance.launch(params).then(res => {
            console.log("AppAPI ".concat(callsign, " : Launch results in ").concat(JSON.stringify(res)));
            if (res.success) {
              if (callsign === "HtmlApp" || callsign === "LightningApp") {
                AlexaApi.get().reportApplicationState(url);
              } else {
                AlexaApi.get().reportApplicationState(callsign);
              }
              if (args.appIdentifier) {
                let order = Storage$1.get("appCarouselOrder");
                if (!order) {
                  Storage$1.set("appCarouselOrder", "");
                } else {
                  let storedApps = order.split(",");
                  let ix = storedApps.indexOf(args.appIdentifier);
                  if (ix != -1) {
                    storedApps.splice(ix, 1);
                  }
                  storedApps.unshift(args.appIdentifier);
                  Storage$1.set("appCarouselOrder", storedApps.toString());
                }
              }
              if (callsign !== "Netflix") {
                //if app is not netflix, move it to front(netflix will be moved to front from applauncherScreen.)
                rdkShellApisInstance.getZOrder().then(res => {
                  console.warn("AppAPI zOrder:" + JSON.stringify(res));
                }).catch(err => {
                  console.error("AppAPI failed to zOrder : ", callsign, " ERROR: ", JSON.stringify(err));
                  Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell zOrder " + JSON.stringify(err), false, null);
                });
                rdkShellApisInstance.moveToFront(callsign, callsign).catch(err => {
                  console.error("AppAPI failed to moveToFront : ", callsign, " ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
                  Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell moveToFront " + JSON.stringify(err), false, null);
                });
              }
              rdkShellApisInstance.setFocus(callsign, callsign).catch(err => {
                console.error("AppAPI failed to setFocus : ", callsign, " ERROR: ", JSON.stringify(err));
                Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell setFocus " + JSON.stringify(err), false, null);
              });
              rdkShellApisInstance.setVisibility(callsign, true).catch(err => {
                console.error("AppAPI failed to setVisibility : ", callsign, " ERROR: ", JSON.stringify(err));
                Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell setVisibility " + JSON.stringify(err), false, null);
              });
              if (callsign === "Netflix") {
                console.log("AppAPI Netflix launched: hiding residentApp");
                //if netflix splash screen was launched resident app was kept visible Netflix until app launched.
                rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false).catch(err => {
                  console.error("AppAPI failed to setVisibility : ", GLOBALS.selfClientName, " ERROR: ", JSON.stringify(err));
                });
              }
              if (callsign.startsWith("YouTube") && (res.launchType === "resume" || gracenoteUrl != null)) {
                // Page visibility requirement; 'launch' need to be 'deeplink'ed when app is 'resumed'.
                if (gracenoteUrl != null) {
                  url = gracenoteUrl;
                } else if (!url) {
                  url = params.configuration.url;
                }
                console.log("AppAPI Calling " + callsign + ".deeplink with url: " + url);
                thunder$j.call(callsign, 'deeplink', url);
              }
              Storage$1.set("appSwitchingInProgress", false);
              GLOBALS.topmostApp = callsign;
              resolve(res);
            } else {
              console.error("AppAPI failed to launchApp(success false) : ", callsign, " ERROR: ", JSON.stringify(res));
              Storage$1.set("appSwitchingInProgress", false);
              Router.navigate(Storage$1.get("lastVisitedRoute"));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);
              reject(res);
            }
          }).catch(err => {
            console.error("AppAPI failed to launchApp: ", callsign, " ERROR: ", JSON.stringify(err), " | Launching residentApp back");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);

            //destroying the app incase it's stuck in launching | if taking care of ResidentApp as callsign, make sure to prevent destroying it
            rdkShellApisInstance.destroy(callsign).catch(err => {
              console.error("AppAPI failed to destroy : ", callsign, " ERROR: ", JSON.stringify(err));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell destroy " + JSON.stringify(err), false, null);
            });
            this.launchResidentApp(GLOBALS.selfClientName);
            Storage$1.set("appSwitchingInProgress", false);
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            reject(err);
          });
        }
      });
    }

    /**
     * Function to launch Exit types of apps.
     * @param {String} callsign callsign of the particular app.
     * @param {boolean} exitInBackground to make the app not bring up residentApp on exit
     * @param {boolean} forceDestroy to force the app to do rdkshell.destroy instead of suspend
     */

    // exit method does not need to launch the previous app.
    async exitApp(callsign, exitInBackground, forceDestroy) {
      //test the new exit app method
      if (callsign === "" || callsign === GLOBALS.selfClientName) {
        //previousApp==="" means it's residentApp | change it to residentApp in cache and here
        return Promise.reject("AppAPI Can't exit from " + callsign);
      }
      if (callsign === "HDMI") {
        console.log("AppAPI exit method called for hdmi");
        new HDMIApi().stopHDMIInput();
        Storage$1.set("_currentInputMode", {});
        if (!exitInBackground) {
          //means resident App needs to be launched
          this.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
            AlexaApi.get().reportApplicationState("menu", true);
          });
        }
        return Promise.resolve(true);
        //check for hdmi scenario
      }
      if (callsign === "LightningApp" || callsign === "HtmlApp" || callsign === "Peacock") {
        forceDestroy = true; //html and lightning apps need not be suspended.
      }
      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      if (callsign != "NativeApp" && !callsign.includes('application/dac.native') && callsign != "FireboltApp") {
        try {
          pluginStatus = await this.getPluginStatus(callsign);
          if (pluginStatus !== undefined) {
            pluginState = pluginStatus[0].state;
            console.log("AppAPI pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
          } else {
            return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device");
          }
        } catch (err) {
          return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
        }
      }
      if (!exitInBackground) {
        //means resident App needs to be launched
        this.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
          AlexaApi.get().reportApplicationState("menu", true);
        });
      }

      //to hide the current app
      console.log("AppAPI setting visibility of " + callsign + " to false");
      await rdkShellApisInstance.setVisibility(callsign, false).catch(err => {
        console.error("AppAPI failed to setVisibility : " + callsign + " ERROR: ", JSON.stringify(err));
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell setVisibility " + JSON.stringify(err), false, null);
      });
      if (forceDestroy) {
        if (pluginState != undefined) {
          // App is a Plugin
          console.log("AppAPI Force Destroying the app: ", callsign);
          await rdkShellApisInstance.destroy(callsign).catch(err => {
            console.error("AppAPI Error in destroying app: " + callsign + " " + JSON.stringify(err));
            rdkShellApisInstance.kill(callsign).catch(err => {
              console.error("AppAPI Error in killing app: " + callsign + " " + JSON.stringify(err));
            });
          });
          return Promise.resolve(true);
        } else if (callsign === "NativeApp" || callsign.includes('application/dac.native')) {
          await rdkShellApisInstance.kill(callsign.includes('application/dac.native') ? callsign.substring(0, callsign.indexOf(';')) : callsign).catch(err => {
            console.error("AppAPI RDKShell kill: " + callsign + " ERROR: ", JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell kill " + JSON.stringify(err), false, null);
            return Promise.resolve(false);
          });
        }
      } else {
        console.log("AppAPI Exiting from App: ", callsign, " depending on platform settings enableAppSuspended: ", Settings$2.get("platform", "enableAppSuspended"));
        //enableAppSuspended = true means apps will be suspended by default
        if (Settings$2.get("platform", "enableAppSuspended")) {
          if (pluginState != undefined) {
            // App is a Plugin
            await rdkShellApisInstance.suspend(callsign).catch(err => {
              console.error("AppAPI Error in suspending app: ", callsign, " | trying to destroy the app" + JSON.stringify(err));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell suspend " + JSON.stringify(err), false, null);
              rdkShellApisInstance.destroy(callsign);
            });
            return Promise.resolve(true);
          } else if (callsign === "NativeApp" || callsign.includes('application/dac.native')) {
            // DAC Demo WorkAround; TODO: use suspendApplication instead of kill
            await rdkShellApisInstance.kill(callsign.includes('application/dac.native') ? callsign.substring(0, callsign.indexOf(';')) : callsign).catch(err => {
              console.error("AppAPI Error in kill app: ", callsign, " | trying to destroy the app" + JSON.stringify(err));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell kill " + JSON.stringify(err), false, null);
              rdkShellApisInstance.destroy(callsign);
            });
            return Promise.resolve(true);
          }
        } else {
          await rdkShellApisInstance.destroy(callsign);
          return Promise.resolve(true);
        }
      }
    }

    /**
     * Function to launch ResidentApp explicitly(incase of special scenarios)
     * Prefer using launchApp and exitApp for ALL app launch and exit scenarios.
     */
    async launchResidentApp() {
      let client = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GLOBALS.selfClientName;
      let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GLOBALS.selfClientName;
      console.log("AppAPI launchResidentApp got Called: setting visibility, focus and moving to front the client: " + client);
      await rdkShellApisInstance.moveToFront(client, callsign).catch(err => {
        console.error("AppAPI failed to moveToFront : ResidentApp ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell moveToFront " + JSON.stringify(err), false, null);
      });
      await rdkShellApisInstance.setFocus(client, callsign).catch(err => {
        console.error("AppAPI failed to setFocus : ResidentApp ERROR: ", JSON.stringify(err));
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell setFocus " + JSON.stringify(err), false, null);
      });
      await rdkShellApisInstance.setVisibility(client, true).catch(err => {
        console.error("AppAPI failed to setVisibility : ResidentApp ERROR: ", JSON.stringify(err));
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell setVisibility " + JSON.stringify(err), false, null);
      });
      GLOBALS.topmostApp = client;
    }
    async getNetflixIIDs() {
      let defaultIIDs = NetflixIIDs;
      let data = new HomeApi().getPartnerAppsInfo();
      if (!data) {
        return defaultIIDs;
      }
      console.log("AppAPI homedata: ", data);
      try {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "netflix-iid-file-path")) {
          let url = data["netflix-iid-file-path"];
          console.log("AppAPI Netflix : requested to fetch iids from ", url);
          const fetchResponse = await fetch(url);
          const fetchData = await fetchResponse.json();
          return fetchData;
        } else {
          console.log("AppAPI Netflix IID file path not found in conf file, using deffault IIDs");
          return defaultIIDs;
        }
      } catch (err) {
        console.error("AppAPI Error in fetching iid data from specified path, returning defaultIIDs | Error:", err);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "Apperror", "AppAPI Error in fetching iid data from specified path" + JSON.stringify(err), false, null);
        return defaultIIDs;
      }
    }

    /*
     *Function to launch apps in hidden mode
     */
    launchPremiumAppInSuspendMode(childCallsign) {
      return new Promise((resolve, reject) => {
        rdkShellApisInstance.launch({
          callsign: childCallsign,
          type: childCallsign,
          suspend: true,
          visible: false,
          focused: false
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("AppAPI launchPremiumAppInSuspendMode : launch netflix results in :", res);
          } else {
            console.log("AppAPI launchPremiumAppInSuspendMode : launch amazon results in :", res);
          }
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("AppAPI Netflix : error while launching netflix :", err);
          } else {
            console.log("AppAPI Amazon : error while launching amazon :", err);
          }
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }

    /**
     * Function to launch Netflix/Amazon Prime app.
     */
    launchPremiumApp(childCallsign) {
      return new Promise((resolve, reject) => {
        rdkShellApisInstance.launch({
          callsign: childCallsign,
          type: childCallsign,
          visible: true,
          focused: true
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("AppAPI launchPremiumApp : launch netflix results in :", res);
          } else {
            console.log("AppAPI launchPremiumApp : launch amazon results in :", res);
          }
          rdkShellApisInstance.setVisibility(childCallsign, true);
          rdkShellApisInstance.setFocus(childCallsign);
          rdkShellApisInstance.moveToFront(childCallsign);
          GLOBALS.topmostApp = childCallsign;
          console.log("AppAPI launchPremiumApp the current application Type : ", GLOBALS.topmostApp);
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("AppAPI launchPremiumApp : error while launching netflix :", err);
          } else {
            console.error("AppAPI launchPremiumApp : error while launching amazon :", err);
          }
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }

    /**
     * Function to launch Resident app.
     * @param {String} url url of app.
     */
    launchResident(url, client) {
      return new Promise((resolve, reject) => {
        const childCallsign = client;
        rdkShellApisInstance.launch({
          callsign: childCallsign,
          type: GLOBALS.selfClientName,
          uri: url
        }).then(res => {
          console.log("AppAPI launchResident returned: ", JSON.stringify(res));
          resolve(true);
        }).catch(err => {
          console.error('AppAPI launchResident error: ' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    launchOverlay(url, client) {
      return new Promise((resolve, reject) => {
        const childCallsign = client;
        rdkShellApisInstance.launch({
          callsign: childCallsign,
          type: GLOBALS.selfClientName,
          uri: url
        }).then(res => {
          rdkShellApisInstance.moveToFront(childCallsign, childCallsign);
          console.log("AppAPI launchOverlay : launched overlay : ", JSON.stringify(res));
          resolve(res);
        }).catch(err => {
          console.error("AppAPI launchOverlay : error ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell launch " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    /**
     * Function to suspend Netflix/Amazon Prime app.
     */
    suspendPremiumApp(appName) {
      return new Promise(resolve => {
        rdkShellApisInstance.suspend(appName).then(() => {
          resolve(true);
        }).catch(err => {
          console.error("AppAPI suspendPremiumApp error: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder RDKShell suspend " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    /**
     * Function to deactivate html app.
     */
    deactivateWeb() {
      rdkShellApisInstance.destroy("HtmlApp");
    }

    /**
     * Function to deactivate cobalt app.
     */
    deactivateCobalt() {
      let instanceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cobalt';
      rdkShellApisInstance.destroy(instanceName);
    }
    cobaltStateChangeEvent() {
      try {
        thunder$j.on('Controller', 'statechange', notification => {
          if (this._events.has('statechange')) {
            this._events.get('statechange')(notification);
          }
        });
      } catch (e) {
        console.error('AppAPI Failed to register statechange event' + e);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error while Thunder Controller stateChange " + JSON.stringify(e), false, null);
      }
    }

    /**
     * Function to deactivate lightning app.
     */
    deactivateLightning() {
      rdkShellApisInstance.destroy("Lightning");
    }

    /**
     * Function to deactivate resident app.
     */
    deactivateResidentApp(client) {
      rdkShellApisInstance.destroy(client);
    }
    enabledisableinactivityReporting(bool) {
      rdkShellApisInstance.enableInactivityReporting(bool);
    }
    setInactivityInterval(duration) {
      rdkShellApisInstance.setInactivityInterval(duration);
    }

    /**
    * Function to set the configuration of premium apps.
    * @param {appName} Name of the application
    * @param {config_data} config_data configuration data
    */
    configureApplication(appName, config_data) {
      let plugin = 'Controller';
      let method = 'configuration@' + appName;
      return new Promise((resolve, reject) => {
        thunder$j.call(plugin, method).then(res => {
          res.querystring = config_data;
          thunder$j.call(plugin, method, res).then(resp => {
            console.log("AppAPI ".concat(appName, " : updating configuration with object ").concat(res, " results in ").concat(resp));
            resolve(true);
          }).catch(err => {
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder ".concat(plugin, " ").concat(method, " ").concat(JSON.stringify(err)), false, null);
            reject(err); //resolve(true)
          });
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder ".concat(plugin, " ").concat(method, " ").concat(JSON.stringify(err)), false, null);
          reject(err);
        });
      });
    }
    setPowerState(value) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'setPowerState', {
          "powerState": value,
          "standbyReason": "ResidentApp User Requested"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System setPowerState failed: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PowerStateFailure", "Error in Thunder System setPowerState " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getPowerState() {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'getPowerState').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getPowerState failed: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PowerStateFailure", "Error in Thunder System getPowerState " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getWakeupReason() {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'getWakeupReason').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("org.rdk.System: getWakeupReason: Error in getting wake up reason: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PowerStateFailure", "Error in Thunder System getWakeupReason " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    enableDisplaySettings() {
      return new Promise((resolve, reject) => {
        thunder$j.call('Controller', 'activate', {
          callsign: 'org.rdk.DisplaySettings'
        }).then(result => {
          console.log('AppAPI activate DisplaySettings success.');
          resolve(result);
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings error: ', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppError", "Error while Thunder Controller displaySettings activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSoundMode() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getSoundMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSoundMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getSoundMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setSoundMode(mode) {
      mode = mode.startsWith("AUTO") ? "AUTO" : mode;
      console.log("mode", mode);
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setSoundMode', {
          "audioPort": "HDMI0",
          "soundMode": mode,
          "persist": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setSoundMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings setSoundMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getSupportedAudioModes() {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.DisplaySettings', 'getSupportedAudioModes', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSupportedAudioModes error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getSupportedAudioModes " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }

    //Enable or disable the specified audio port based on the input audio port ID.
    setEnableAudioPort(port) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setEnableAudioPort', {
          "audioPort": port,
          "enable": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setEnableAudioPort error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings setEnableAudioPort " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getDRCMode() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getDRCMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getDRCMode error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getDRCMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setDRCMode(DRCNum) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setDRCMode', {
          "DRCMode": DRCNum
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setDRCMode error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings setDRCMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getZoomSetting() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getZoomSetting').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getZoomSetting error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getZoomSetting " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setZoomSetting(zoom) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setZoomSetting', {
          "zoomSetting": zoom
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setZoomSetting error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings setZoomSetting " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getEnableAudioPort(audioPort) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getEnableAudioPort', {
          "audioPort": audioPort
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getEnableAudioPort error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getEnableAudioPort " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getSupportedAudioPorts() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'getSupportedAudioPorts').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSupportedAudioPorts error:", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DisplaySettings getSupportedAudioPorts " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //________________________________________________________________________________________________________________________

    //OTHER SETTINGS PAGE API

    //1. UI VOICE

    //Start a speech
    ttsSpeak() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.TextToSpeech', 'speak', {
          "text": "speech_1"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech speak error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder TextToSpeech Speak " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //Resume a speech
    ttsResume() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.TextToSpeech', 'resume', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech resume error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder TextToSpeech resume " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //Pause a speech
    ttsPause() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.TextToSpeech', 'pause', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech pause error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder TextToSpeech pause " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // 2. TTS Options
    ttsGetListVoices() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.TextToSpeech', 'listvoices', {
          "language": "en-US"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech listvoices error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder TextToSpeech listVoices " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // 3. Sync Location
    syncLocation() {
      return new Promise(resolve => {
        thunder$j.call('LocationSync', 'sync').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI LocationSync sync error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder LocationSync sync " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getLocation() {
      return new Promise(resolve => {
        thunder$j.call('LocationSync', 'location').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI LocationSync location error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder LocationSync location " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    // 4. Check for Firmware Update

    //Get Firmware Update Info
    getFirmwareUpdateInfo() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getFirmwareUpdateInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getFirmwareUpdateInfo error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getFirmwareUpdateInfo " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // Get Firmware Update State
    getFirmwareUpdateState() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getFirmwareUpdateState').then(result => {
          resolve(result);
        }).catch(err => {
          console.error(" AppAPI System getFirmwareUpdateState error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getFirmwareUpdateState " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // Get Firmware download info
    getDownloadFirmwareInfo() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getDownloadedFirmwareInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getDownloadedFirmwareInfo error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getDownloadedFirmwareInfo " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getModelName() {
      return new Promise(resolve => {
        thunder$j.call('DeviceInfo', 'modelname').then(result => {
          resolve(result.model);
        }).catch(err => {
          console.error("AppAPI DeviceInfo modelname failed:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DeviceInfo modelname " + JSON.stringify(err), false, null);
          resolve("RDK-VA");
        });
      });
    }
    getSerialNumber() {
      return new Promise(resolve => {
        thunder$j.call('DeviceInfo', 'serialnumber').then(result => {
          resolve(result.serialnumber);
        }).catch(err => {
          console.error("AppAPI DeviceInfo serialnumber error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DeviceInfo serialnumber " + JSON.stringify(err), false, null);
          resolve('0123456789');
        });
      });
    }

    //Get system versions
    getSystemVersions() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getSystemVersions').then(result => {
          console.log(JSON.stringify(result, 3, null));
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getSystemVersions error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getSystemVersions " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //Update firmware
    updateFirmware() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'updateFirmware').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System updateFirmware error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system updateFirmware " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //Get download percentage
    getFirmwareDownloadPercent() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getFirmwareDownloadPercent').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getFirmwareDownloadPercent error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getFirmwareDownloadPercent " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // device Identification
    getDeviceIdentification() {
      return new Promise(resolve => {
        thunder$j.call('DeviceIdentification', 'deviceidentification').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getDeviceIdentification error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DeviceIdentification deviceidentification " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // 5. Device Info
    systeminfo() {
      return new Promise(resolve => {
        thunder$j.call('DeviceInfo', 'systeminfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI systeminfo error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DeviceInfo systeminfo " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    deviceType() {
      return new Promise(resolve => {
        thunder$j.call('DeviceInfo', 'devicetype').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI devicetype error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder DeviceInfo devicetype " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // 6. Reboot
    reboot() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'reboot', {
          "rebootReason": "FIRMWARE_FAILURE"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI reboot error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system reboot " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getNetflixESN() {
      return new Promise(resolve => {
        thunder$j.call('Netflix', 'esn').then(res => {
          resolve(res);
        });
      });
    }

    // get prefered standby mode
    getPreferredStandbyMode() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'getPreferredStandbyMode').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getPreferredStandbyMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "PluginError", "Error in Thunder system getPreferredStandbyMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setPreferredStandbyMode(standbyMode) {
      console.log("setPreferredStandbyMode called : " + standbyMode);
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'setPreferredStandbyMode', {
          "standbyMode": standbyMode
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI setPreferredStandbyMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "PluginError", "Error in Thunder system setPreferredStandbyMode " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getNetworkStandbyMode() {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'getNetworkStandbyMode').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getNetworkStandbyMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "PluginError", "Error in Thunder system getNetworkStandbyMode " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getRFCConfig(rfcParamsList) {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'getRFCConfig', rfcParamsList).then(result => {
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          console.error("AppAPI getRFCConfig error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system getRFCConfig " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setNetworkStandbyMode() {
      let nwStandby = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'setNetworkStandbyMode', {
          nwStandby: nwStandby
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI setNetworkStandbyMode error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder system setNetworkStandbyMode " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setWakeupSrcConfiguration(params) {
      console.log("AppAPI: setWakeupSrcConfiguration params:", JSON.stringify(params));
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.System', 'setWakeupSrcConfiguration', params).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI setWakeupSrcConfiguration error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder system setWakeupSrcConfiguration " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    registerChangeLocation() {
      thunder$j.call('Controller', 'activate', {
        callsign: "LocationSync"
      }).then(() => {
        thunder$j.on("LocationSync", "locationchange", notification => {
          console.log("AppAPI locationchange notification :", notification);
        });
      }).catch(err => {
        console.error(err);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder locationchange of LocationSync " + JSON.stringify(err), false, null);
      });
    }
    async sendAppState(value) {
      const state = await thunder$j.call('org.rdk.RDKShell', 'getState', {}).then(result => result.state);
      this.state = state;
      let params = {
        applicationName: value,
        state: 'stopped'
      };
      for (let i = 0; i < state.length; i++) {
        if (state[i].callsign == value) {
          if (state[i].state == 'resumed') {
            params.state = 'running';
          } else if (state[i].state == 'suspended') {
            params.state = 'suspended';
          } else {
            params.state = 'stopped';
          }
        }
      }
      await thunder$j.call('org.rdk.Xcast', 'onApplicationStateChanged', params).then(result => result.success);
    }
    //NETWORK INFO APIS

    //1. Get IP Setting
    getIPSetting(defaultInterface) {
      let ipversion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IPv4";
      return new Promise(resolve => {
        thunder$j.call('org.rdk.Network', 'getIPSettings', {
          "interface": defaultInterface,
          "ipversion": ipversion
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getIPSetting error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder getIPSettings of Network " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //2. Get default interface
    getDefaultInterface() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.Network', 'getDefaultInterface').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getDefaultInterface error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder getDefaultInterface of Network " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //3. Is interface enabled
    isInterfaceEnabled() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.Network', 'isInterfaceEnabled', {
          "interface": "WIFI"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI isInterfaceEnabled error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder isInterfaceEnabled of Network " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //4. Get interfaces
    getInterfaces() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.Network', 'getInterfaces').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getInterfaces error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder getInterfaces of Network " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //5. getConnectedSSID
    getConnectedSSID() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.Wifi', 'getConnectedSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getConnectedSSID error:", JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "NetworkError", "Error in Thunder getConnectedSSID of WIFI " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    // Volume Apis
    getConnectedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.DisplaySettings', 'getConnectedAudioPorts', {}).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getConnectedAudioPorts error:', JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder getConnectedAudioPorts of DisplaySettings " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    getVolumeLevel(port) {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.DisplaySettings', 'getVolumeLevel', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getVolumeLevel error:', JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder getVolumeLevel of DisplaySettings " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    getMuted(port) {
      return new Promise((resolve, reject) => {
        thunder$j.call('org.rdk.DisplaySettings', 'getMuted', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getMuted error:', JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder getMuted of DisplaySettings " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    setVolumeLevel(port, volume) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setVolumeLevel', {
          audioPort: port,
          volumeLevel: volume
        }).then(result => {
          console.log("AppAPI setVolumeLevel :", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.error('AppAPI setVolumeLevel error:', JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder setVolumeLevel of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    audio_mute(audio_source, value) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'setMuted', {
          audioPort: audio_source,
          muted: value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI audio_mute setMuted error:', JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder setMuted of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    //created only to get the required params
    getPluginStatusParams(plugin) {
      return new Promise((resolve, reject) => {
        thunder$j.call('Controller', "status@".concat(plugin)).then(result => {
          console.log("pluginstatus", result);
          let pluginParams = [result[0].callsign, result[0].state];
          resolve(pluginParams);
        }).catch(err => {
          console.error("AppAPI getPluginStatusParams error: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder status@".concat(plugin, " of Thunder Controller ").concat(JSON.stringify(err)), false, null);
          reject(err);
        });
      });
    }
    //activate autopairing for stack
    activateAutoPairing() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.RemoteControl', 'startPairing', {
          "netType": '1',
          "timeout": '30'
        }).then(result => {
          console.log("AppAPI activateAutoPairing: ", result);
          resolve(result);
        }).catch(err => {
          console.error('AppAPI activateAutoPairing error:', JSON.stringify(err, 3, null));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder startPairing of RemoteControl " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    resetBassEnhancer(port) {
      console.log("portname", port);
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'resetBassEnhancer', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetBassEnhancer error: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder resetBassEnhancer of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    resetDialogEnhancement(port) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'resetDialogEnhancement', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetDialogEnhancement error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder resetDialogEnhancement of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    //resetSurroundVirtualizer
    resetSurroundVirtualizer(port) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'resetSurroundVirtualizer', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetSoundVitualizer error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder resetSurroundVirtualizer of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    //resetVolumeLeveller
    resetVolumeLeveller(port) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DisplaySettings', 'resetVolumeLeveller', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetvolumeLevel error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder resetVolumeLeveller of DisplaySettings " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    //resetInactivityTime
    resetInactivityTime() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.RDKShell', 'resetInactivityTime').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetInactivityTime error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in fetching Thunder resetInactivityTime of RDKShell " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //clearLastDeepSleepReason
    clearLastDeepSleepReason() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.System', 'clearLastDeepSleepReason').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI clearLastDeepSleepReason error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder clearLastDeepSleepReason of system " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    monitorStatus(callsign) {
      return new Promise(resolve => {
        thunder$j.call('Monitor', 'resetstats', {
          "callsign": callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI monitorStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder fetching resetstats of Monitor " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    //{ path: ".cache" }
    deletecache(systemcCallsign, path) {
      return new Promise(resolve => {
        thunder$j.call(systemcCallsign, 'delete', {
          path: path
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI deletecache error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error in Thunder delete of ".concat(systemcCallsign, " ").concat(JSON.stringify(err)), false, null);
          resolve(false);
        });
      });
    }

    // activate controller plugin
    activateController(callsign) {
      return new Promise(resolve => {
        thunder$j.call('Controller', 'activate', {
          callsign: callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI activateController error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error while Thunder Controller activate ".concat(callsign, " ").concat(JSON.stringify(err)), false, null);
          resolve(false);
        });
      });
    }
    checkStatus(plugin) {
      return new Promise(resolve => {
        thunder$j.call('Controller', 'status@' + plugin).then(res => {
          //console.log("AppAPI checkStatus ", JSON.stringify(res))
          resolve(res);
        }).catch(err => {
          console.error("AppAPI checkStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error while Thunder Controller fetching status@".concat(plugin, " ").concat(JSON.stringify(err)), false, null);
          resolve(false);
        });
      });
    }
    configStatus() {
      //controller.1.configuration
      return new Promise(resolve => {
        thunder$j.call('Controller', 'status').then(res => {
          //console.log("AppAPI configStatus ",JSON.stringify(res))
          resolve(res);
        }).catch(err => {
          console.error("AppAPI configStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Error while Thunder Controller fetching status ".concat(JSON.stringify(err)), false, null);
          resolve(false);
        });
      });
    }
    getAvCodeStatus() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.DeviceDiagnostics', 'getAVDecoderStatus').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getAvCodeStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error in Thunder fetching getAVDecoderStatus of DeviceDiagnostics' + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    setUILanguage(updatedLanguage) {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.UserPreferences', 'setUILanguage', {
          "ui_language": updatedLanguage
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI setUILanguage failed:' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error in Thunder setUILanguage of UserPreferences' + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    getUILanguage() {
      return new Promise(resolve => {
        thunder$j.call('org.rdk.UserPreferences', 'getUILanguage').then(result => {
          resolve(result.ui_language);
        }).catch(err => {
          console.error('AppAPI getUILanguage failed:' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", 'Error in Thunder getUILanguage of UserPreferences' + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }
    deeplinkToApp() {
      let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      let payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let launchLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "voice";
      let namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      return new Promise((resolve, reject) => {
        if (app === undefined || app === "" || payload == undefined) {
          console.error("AppApi: deeplinkToApp '" + app + "' not possible with payload '" + payload + "'.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppError", "AppApi: deeplinkToApp ".concat(app, " not possible with payload ").concat(payload), false, null);
          resolve(false);
        } else if (app.startsWith("YouTube")) {
          let url = Storage$1.get(app + "DefaultURL").toString();
          url = url.substring(0, url.indexOf('?'));
          if (!url.endsWith("?")) url += "?";
          url += GLOBALS.topmostApp === app ? "inApp=true" : "inApp=false";
          // For the timebeing Alexa alone. Revisit when we have other voice sysyems.
          url += "&launch=voice" + "&vs=" + (launchLocation === "alexa" ? 2 : 0);
          if (namespace === "ExternalMediaPlayer") {
            // Received sample : {"payload":{"playbackContextToken":"{deeplinkMethodType=PLAY, searchString='cat videos'}"}}
            url += "&va=" + (payload.playbackContextToken.includes("deeplinkMethodType=PLAY") ? "play" : "search");
            if (payload.playbackContextToken.includes("deeplinkMethodType")) {
              let searchString = payload.playbackContextToken.replace(/[{}]/g, '').split(',');
              for (let i = 0; i < searchString.length; i++) {
                if (searchString[i].includes("searchString")) {
                  let data = searchString[i].split('=').slice(1)[0].replace(/'/g, '');
                  url += "&vaa=" + encodeURI(data.trim());
                  break;
                }
              }
            }
          } else if (namespace === "Alexa.SeekController") {
            let time = payload.deltaPositionMilliseconds / 1000;
            let minutes = Math.abs(parseInt(time / 60));
            let seconds = Math.abs(parseInt(time % 60));
            url += "&va=" + (time < 0 ? "mediaRewind" : "mediaFastForward") + "&vaa=" + minutes + "m" + seconds + "s";
          } else if (namespace === "Alexa.PlaybackController") {
            let playbackOperations = new Set(["Play", "Pause", "FastForward", "Rewind", "Shuffle", "Repeat"]);
            if (playbackOperations.has(payload)) {
              url += "&va=media" + payload;
            } else if (payload === "Next" || payload === "Previous") {
              url += "&va=media" + payload + "Video";
            }
          }
          console.info("AppApi: deeplinkToApp " + app + " url - " + url);
          thunder$j.call(app, 'deeplink', url);
        } else if (app === "Amazon") {
          // TODO: no deeplink format support.
          console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppDeeplinkError", JSON.stringify(err), false, null);
          reject(false);
        } else if (app === "Netflix") {
          // TODO: no deeplink format support.
          console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppDeeplinkError", JSON.stringify(err), false, null);
          reject(false);
        } else {
          console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "AppDeeplinkError", JSON.stringify(err), false, null);
          reject(false);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var appListInfo = [{
    displayName: 'USB',
    applicationType: '',
    uri: 'USB',
    url: '/images/usb/USB_Featured_Item.jpg',
    appIdentifier: 'n:0'
  }, {
    displayName: 'Netflix',
    applicationType: 'Netflix',
    uri: '',
    url: '/images/apps/App_Netflix_454x255.png',
    appIdentifier: 'n:1'
  }, {
    displayName: 'Amazon Prime video',
    applicationType: 'Amazon',
    uri: '',
    url: '/images/apps/App_Amazon_Prime_454x255.png',
    appIdentifier: 'n:2'
  }, {
    displayName: 'YouTube',
    applicationType: 'YouTube',
    uri: 'https://www.youtube.com/tv',
    url: '/images/apps/App_YouTube_454x255.png',
    appIdentifier: 'n:3'
  }, {
    displayName: 'YouTubeTV',
    applicationType: 'YouTubeTV',
    uri: 'https://www.youtube.com/tv/upg',
    url: '/images/apps/App_YouTubeTV_454x255.png',
    appIdentifier: 'n:4'
  }, {
    displayName: 'Peacock',
    applicationType: 'Peacock',
    uri: '',
    url: '/images/apps/App_Peacock_454x255.png',
    appIdentifier: 'n:6'
  }, {
    displayName: 'Xumo',
    applicationType: 'HtmlApp',
    uri: 'https://x1box-app.xumo.com/index.html',
    url: '/images/apps/App_Xumo_454x255.png',
    appIdentifier: 'n:7'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for tv shows listings.
   */
  var tvShowsInfo = [{
    displayName: 'Fantasy-Island',
    url: '/images/tvShows/fantasy-island.jpg'
  }, {
    displayName: 'Onward',
    url: '/images/tvShows/onward.jpg'
  }, {
    displayName: 'Let it Snow',
    url: '/images/tvShows/let-it-snow.jpg'
  }, {
    displayName: 'FOG DASH',
    url: '/images/tvShows/do-little.jpg'
  }, {
    displayName: 'FOG HLS',
    url: '/images/tvShows/summerland.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for settings listings.
   */
  var settingsInfo = [{
    displayName: 'Bluetooth',
    url: '/images/settings/bluetooth.jpg'
  }, {
    displayName: 'Wi-Fi',
    url: '/images/settings/wifi.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for listings in side panel.
   */
  var sidePanelInfo = [{
    title: 'Apps',
    url: '/images/sidePanel/menu.png'
  }, {
    title: 'Metro Apps',
    url: '/images/sidePanel/metro.png'
  }, {
    title: 'TV Shows',
    url: '/images/sidePanel/video.png'
  }, {
    title: 'Settings',
    url: '/images/sidePanel/settings.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var rightArrowInfo = [{
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var leftArrowInfo = [{
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for UI selection.
   */
  var uiInfo = [{
    title: 'DEFAULT',
    url: '/images/splash/DefaultUI.png',
    uri: ''
  }, {
    title: 'LIVE',
    url: '/images/splash/LiveTv.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'TATA',
    url: '/images/splash/TataElxsi.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'NEW',
    url: '/images/splash/NewUi.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }, {
    title: 'COMINGSOON',
    url: '/images/splash/ComingSoon.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfo = [{
    displayName: 'GuessThatCity',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.GuessThatCity',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.GuessThatCity.png',
    appIdentifier: 'm:5'
  }, {
    displayName: 'FRacer',
    applicationType: 'LightningApp',
    uri: 'https://lightningjs.io/fracer/#main',
    url: '/images/metroApps/fracer-steerling.png',
    appIdentifier: 'm:8'
  }, {
    displayName: 'Aquarium',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aquarium',
    url: '/images/metroApps/Aquarium.png',
    appIdentifier: 'm:9'
  }, {
    displayName: 'Fireplace',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Fireplace',
    url: '/images/metroApps/Fireplace.png',
    appIdentifier: 'm:10'
  }, {
    displayName: 'Sudoku',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sudoku',
    url: '/images/metroApps/Sudoku.png',
    appIdentifier: 'm:13'
  }, {
    displayName: 'Sunrise',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sunrise',
    url: '/images/metroApps/Sunrise.png',
    appIdentifier: 'm:17'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfoOffline = [{
    displayName: 'Test-01',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-01.jpg',
    appIdentifier: 'm:0'
  }, {
    displayName: 'Test-03',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-03.jpg',
    appIdentifier: 'm:1'
  }, {
    displayName: 'Test-04',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-04.jpg',
    appIdentifier: 'm:2'
  }, {
    displayName: 'Test-05',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-05.jpg',
    appIdentifier: 'm:3'
  }, {
    displayName: 'Test-07',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-07.jpg',
    appIdentifier: 'm:4'
  }, {
    displayName: 'Test-08',
    applicationType: 'LightningApp',
    uri: 'about:blank',
    url: '/images/metroApps/Test-08.jpg',
    appIdentifier: 'm:5'
  }];

  /**
   * If not stated otherwise in this file or this component"s LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  var showCaseApps = [{
    displayName: 'Strike Benchmark',
    applicationType: 'LightningApp',
    uri: 'https://strike.lightningjs.io/es6/#home',
    url: '/images/lightningApps/strike_app.png',
    appIdentifier: 's:0'
  }, {
    displayName: 'TMBD App',
    applicationType: 'LightningApp',
    uri: 'https://lightningjs.io/tmdb/#splash',
    url: '/images/lightningApps/tmbd.png',
    appIdentifier: 's:1'
  }, {
    displayName: 'FCA',
    applicationType: 'FireboltApp',
    appId: "comcast.test.firecert",
    intent: {
      "action": "home",
      "context": {
        "source": "device"
      }
    },
    url: '/images/lightningApps/fb_cert.png',
    appIdentifier: 's:2'
  }];

  var lib = {};

  var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  var defaultOptions = {
    aloneValueName: '_@attribute'
  };
  /**
   * Main function. Clears the given xml and then starts the recursion
   * @param xmlStr
   * @param options the options
   */
  function xml2json(xmlStr, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var opt = __assign(__assign({}, defaultOptions), options);
    xmlStr = cleanXML(xmlStr, opt.aloneValueName);
    return xml2jsonRecurse(xmlStr, opt);
  }
  var _default = lib.default = xml2json;
  /**
   * Recursive function that creates a JSON object with a given XML string.
   *
   * @param xmlStr
   * @param options the options
   */
  function xml2jsonRecurse(xmlStr, options) {
    var obj = {};
    var startTagMatch;
    while (startTagMatch = xmlStr.match(/<[^\/][^>]*>/)) {
      var openingTag = startTagMatch[0];
      var tagName = openingTag.substring(1, openingTag.length - 1);
      var indexClosingTag = xmlStr.indexOf(openingTag.replace('<', '</'));
      // account for case where additional information in the opening tag
      var closingTagMatch = void 0;
      if (indexClosingTag == -1 && (closingTagMatch = openingTag.match(/[^<][\S+$]*/))) {
        tagName = closingTagMatch[0];
        indexClosingTag = xmlStr.indexOf('</' + tagName);
        if (indexClosingTag == -1) {
          indexClosingTag = xmlStr.indexOf('<\\/' + tagName);
        }
      }
      var inner_substring = xmlStr.substring(openingTag.length, indexClosingTag);
      var tempVal = inner_substring.match(/<[^\/][^>]*>/) ? xml2json(inner_substring, options) : inner_substring;
      // account for array or obj
      if (obj[tagName] === undefined) {
        obj[tagName] = tempVal;
      } else if (Array.isArray(obj[tagName])) {
        obj[tagName].push(tempVal);
      } else {
        obj[tagName] = [obj[tagName], tempVal];
      }
      xmlStr = xmlStr.substring(openingTag.length * 2 + 1 + inner_substring.length);
    }
    return obj;
  }
  /**
   * Removes some characters that would break the recursive function.
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function cleanXML(xmlStr, aloneValueName) {
    xmlStr = xmlStr.replace(/<!--[\s\S]*?-->/g, ''); // remove commented lines
    xmlStr = xmlStr.replace(/[\n\t\r]/g, ''); // replace special characters
    xmlStr = xmlStr.replace(/>[ \t]+</g, '><'); // replace leading spaces and tabs betweet elements
    xmlStr = xmlStr.replace(/<\?[^>]*\?>/g, ''); // delete docType tags
    xmlStr = replaceSelfClosingTags(xmlStr); // replace self closing tags
    xmlStr = replaceAloneValues(xmlStr, aloneValueName); // replace the alone tags values
    xmlStr = replaceAttributes(xmlStr); // replace attributes
    return xmlStr;
  }
  /**
   * Replaces all the self closing tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   * Example : '<tagName attrName="attrValue" />' becomes
   *           '<tagName><attrName>attrValue</attrName></tagName>'
   * @param xmlStr
   * @returns {*}
   */
  function replaceSelfClosingTags(xmlStr) {
    var selfClosingTags = xmlStr.match(/<[^/][^>]*\/>/g);
    if (!selfClosingTags) {
      return xmlStr;
    }
    for (var i = 0; i < selfClosingTags.length; i++) {
      var oldTag = selfClosingTags[i];
      var match = oldTag.match(/[^<][\S+$]*/);
      if (match) {
        var tagName = match[0];
        var closingTag = "</" + tagName + ">";
        var newTag = extractAttributeValue(tagName, oldTag) + closingTag;
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }
  /**
   *  Replaces all the tags with attributes and a value with a new tag.
   *
   *  Example : '<tagName attrName="attrValue">tagValue</tagName>' becomes
   *  '<tagName><attrName>attrValue</attrName><_@attribute>tagValue</_@attribute></tagName>'
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function replaceAloneValues(xmlStr, aloneValueName) {
    var tagsWithAttributesAndValue = xmlStr.match(/<[^\/][^>][^<]+\s+.[^<]+[=][^<]+>([^<]+)/g);
    if (!tagsWithAttributesAndValue) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributesAndValue.length; i++) {
      var oldTag = tagsWithAttributesAndValue[i];
      var oldTagName = oldTag.substring(0, oldTag.indexOf(">") + 1);
      var oldTagValue = oldTag.substring(oldTag.indexOf(">") + 1);
      var newTag = oldTagName + "<" + aloneValueName + ">" + oldTagValue + "</" + aloneValueName + ">";
      xmlStr = xmlStr.replace(oldTag, newTag);
    }
    return xmlStr;
  }
  function extractAttributeValue(tagName, oldTag) {
    var newTag = "<" + tagName + ">";
    var attrs = oldTag.match(/(\S+)\s?=\s?((?:"[^"]+")|(?:'[^']+'))/g);
    if (!attrs) {
      return newTag;
    }
    for (var j = 0; j < attrs.length; j++) {
      var attr = attrs[j];
      var attrName = attr.substring(0, attr.indexOf('=')).trim();
      var quote = attr[attr.length - 1];
      var attrValue = attr.substring(attr.indexOf(quote) + 1, attr.lastIndexOf(quote));
      newTag += "<" + attrName + ">" + attrValue + "</" + attrName + ">";
    }
    return newTag;
  }
  /**
   * Replaces all the tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   *
   * Example : '<tagName attrName="attrValue"></tagName>' becomes '<tagName><attrName>attrValue</attrName></tagName>'
   *
   * @param xmlStr
   * @returns {*}
   */
  function replaceAttributes(xmlStr) {
    var tagsWithAttributes = xmlStr.match(/<[^\/><]\S+\s+[^<]+[=][^<]+>/g);
    if (!tagsWithAttributes) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributes.length; i++) {
      var oldTag = tagsWithAttributes[i];
      var match = oldTag.match(/[^<]\S*/);
      if (match) {
        var tagName = match[0];
        var newTag = extractAttributeValue(tagName, oldTag);
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2024 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class PersistentStoreApi {
    constructor() {
      if (PersistentStoreApi.instance) {
        return PersistentStoreApi.instance;
      }
      this._events = new Map();
      this.callsign = "org.rdk.PersistentStore";
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.INFO = function () {};
      this.LOG = function () {};
      this.ERR = console.error;
      PersistentStoreApi.instance = this;
    }
    static get() {
      if (!PersistentStoreApi.instance) {
        PersistentStoreApi.instance = new PersistentStoreApi();
      }
      return PersistentStoreApi.instance;
    }
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: activate.");
        this.thunder.Controller.activate({
          callsign: this.callsign
        }).then(() => {
          this.thunder.on(this.callsign, 'onStorageExceeded', notification => {
            if (this._events.has('onStorageExceeded')) {
              this._events.get('onStorageExceeded')(notification);
            } else {
              this.INFO('PersistentStoreApi: onStorageExceeded ' + JSON.stringify(notification));
            }
          });
          this.thunder.on(this.callsign, 'onValueChanged', notification => {
            if (this._events.has('onValueChanged')) {
              this._events.get('onValueChanged')(notification);
            } else {
              this.INFO('PersistentStoreApi: onValueChanged ' + JSON.stringify(notification));
            }
          });
          resolve(true);
        }).catch(err => {
          this.ERR('PersistentStoreApi: Error Activation ', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error while Thunder Controller PersistentStore activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.Controller.deactivate({
          callsign: this.callsign
        }).then(() => {
          this.INFO("PersistentStoreApi: deactivated successfully.");
          resolve(true);
        }).catch(err => {
          this.ERR('PersistentStoreApi: Error deactivation ' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error while Thunder Controller PersistentStore deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deleteKey(namespace, key) {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: deleteKey:" + namespace + " & " + key);
        this.thunder.call(this.callsign, 'deleteKey', {
          namespace: namespace,
          key: key
        }).then(result => {
          this.LOG("PersistentStoreApi: deleteKey result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: deleteKey error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore deleteKey " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deleteNamespace(namespace) {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: deleteNamespace params:", namespace);
        this.thunder.call(this.callsign, 'deleteNamespace', {
          namespace: namespace
        }).then(result => {
          this.LOG("PersistentStoreApi: deleteNamespace result:" + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: deleteNamespace error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore deleteNamespace " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    flushCache() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'flushCache').then(result => {
          this.LOG("PersistentStoreApi: flushCache result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: flushCache error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore flushCache " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getKeys(namespace) {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: getKeys params:", namespace);
        this.thunder.call(this.callsign, 'getKeys', {
          namespace: namespace
        }).then(result => {
          this.LOG("PersistentStoreApi: getKeys result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: getKeys error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore getKeys " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getNamespaces() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getNamespaces').then(result => {
          this.LOG("PersistentStoreApi: getNamespaces result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: getNamespaces error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore getNamespaces " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getStorageSize() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getStorageSize').then(result => {
          this.LOG("PersistentStoreApi: getStorageSize result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: getStorageSize error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore getStorageSize " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getValue(namespace, key) {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: getValue " + namespace + " & " + key);
        this.thunder.call(this.callsign, 'getValue', {
          namespace: namespace,
          key: key
        }).then(result => {
          this.LOG("PersistentStoreApi: getValue result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: getValue error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore getValue " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setValue(namespace, key, value) {
      return new Promise((resolve, reject) => {
        this.INFO("PersistentStoreApi: setValue:" + namespace + " & " + key + " & " + value);
        this.thunder.call(this.callsign, 'setValue', {
          namespace: namespace,
          key: key,
          value: value
        }).then(result => {
          this.LOG("PersistentStoreApi: setValue result: " + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("PersistentStoreApi: setValue error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PersistentStoreApiError", "Error in Thunder PersistentStore setValue " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let partnerApps = [];

  /**
   * Get the ip address.
   */
  let IpAddress1 = "";
  let IpAddress2 = "";
  Network.get().getStbIp().then(ip => {
    IpAddress1 = ip;
    Storage$1.set("ipAddress", IpAddress1);
  }).catch(() => {
    Storage$1.set("ipAddress", null);
  });
  let appApi$d = new AppApi();
  appApi$d.getIP().then(ip => {
    IpAddress2 = ip;
  });

  /**
   * Class that returns the data required for home screen.
   */
  class HomeApi {
    /**
     * Function to get details for app listing.
     */
    getAppListInfo() {
      let appsMetaData = appListInfo;
      return JSON.parse(JSON.stringify(appsMetaData));
    }

    /**
     * Function to get details for tv shows listings.
     */
    getTVShowsInfo() {
      return tvShowsInfo;
    }

    /**
     * Function to get details for settings listings.
     */
    getSettingsInfo() {
      return settingsInfo;
    }

    /**
     * Function to get details for lightning showcase apps.
     */
    getShowCaseApps() {
      return JSON.parse(JSON.stringify(showCaseApps));
    }

    /**
     * Function to get details for all apps.
     */
    getAllApps() {
      return [...this.getAppListInfo(), ...this.getMetroInfo(), ...this.getShowCaseApps()];
    }

    /**
     * Function to get details for side panel.
     */
    getSidePanelInfo() {
      return sidePanelInfo;
    }

    /**
     * Function to get details of different UI
     */
    getUIInfo() {
      return uiInfo;
    }

    /**
     * Function to details of metro apps
     */
    getMetroInfo() {
      let metroAppsMetaData;
      if (IpAddress1 || IpAddress2) {
        metroAppsMetaData = metroAppsInfo;
      } else {
        metroAppsMetaData = metroAppsInfoOffline;
      }
      return metroAppsMetaData;
    }
    getOnlineMetroApps() {
      return JSON.parse(JSON.stringify(metroAppsInfo));
    }

    /**
     * Function to store partner app details.
     * @param {obj} data Partner app details.
     */
    setPartnerAppsInfo(data) {
      partnerApps = data;
    }

    /**
     *Function to return partner app details.
     */
    getPartnerAppsInfo() {
      return partnerApps;
    }
    /**
     * Function to details of right arrow
     */
    getRightArrowInfo() {
      return rightArrowInfo;
    }
    /**
     * Function to details of left arrow
     */
    getLeftArrowInfo() {
      return leftArrowInfo;
    }
    getMovieSubscriptions(id) {
      return new Promise(resolve => {
        PersistentStoreApi.get().getValue('gracenote', 'apiKey').then(res => {
          if (res && res.value && res.value !== undefined && res.value !== "") {
            try {
              fetch("http://feeds.tmsapi.com/v2/movies/" + id + ".xml?api_key=" + res.value).then(response => response.text()).then(res => {
                resolve(_default(res));
              });
            } catch (err) {
              console.log("API key not defined." + JSON.stringify(err));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", JSON.stringify(err), false, null);
            }
          }
        }).catch(err => {
          console.log("Gracenote Info not found." + JSON.stringify(err));
        });
      });
    }
    getAPIKey() {
      return new Promise(resolve => {
        PersistentStoreApi.get().getValue('gracenote', 'apiKey').then(res => {
          if (res && res.value && res.value !== undefined && res.value !== "") {
            let [day, month, year] = [new Date().getUTCDate(), new Date().getUTCMonth(), new Date().getUTCFullYear()];
            month += 1;
            day = day.toString();
            month = month.toString();
            //fetch date time from the thunder plugins and pass it to the url
            try {
              fetch("http://data.tmsapi.com/v1.1/movies/airings?lineupId=USA-TX42500-X&startDateTime=" + year + "-" + month + "-" + day + "T08%3A00Z&includeAdult=false&imageSize=Lg&imageAspectTV=16x9&imageText=true&api_key=" + res.value).then(response => response.json()).then(response => {
                const ids = response.map(id => id.program.rootId);
                const filtered = response.filter((_ref, index) => {
                  let {
                    program
                  } = _ref;
                  return !ids.includes(program.rootId, index + 1);
                });
                resolve({
                  key: res.value,
                  data: filtered.slice(0, 20)
                });
              }).catch(err => {
                console.log("Gracenote: Incorrect API key or no data available" + JSON.stringify(err));
                Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", JSON.stringify(err), false, null);
                resolve({
                  key: res.value,
                  data: []
                });
              });
            } catch (err) {
              console.error("Gracenote fetch failed." + JSON.stringify(err));
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", JSON.stringify(err), false, null);
              resolve({
                key: res.value,
                data: []
              });
            }
          } else {
            console.error("Gracenote apiKey is invalid in PersistentStore.");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "ApiError", JSON.stringify(err), false, null);
            resolve({
              key: "",
              data: []
            });
          }
        }).catch(err => {
          console.error("Gracenote apiKey not found in PersistentStore." + JSON.stringify(err));
          resolve({
            key: "",
            data: []
          });
        });
      });
    }
    async checkChannelComapatability(items) {
      for (let i = 0; i < items.length; i++) {
        let callsign = null;
        if (items[i].dvburi === "OTT") {
          callsign = items[i].callsign;
          if (items[i].callsign === "YouTube" || items[i].callsign === "YouTubeTV") {
            callsign = "Cobalt";
          }
          await appApi$d.getPluginStatus(callsign).catch(err => {
            console.log("Error:", err);
            items.splice(i, 1);
            i--;
          });
        }
      }
      return items;
    }
    async checkAppCompatability(items) {
      for (let i = 0; i < items.length; i++) {
        let callsign = items[i].applicationType;
        if (items[i].applicationType !== '') {
          if (items[i].applicationType === "FireboltApp" && GLOBALS.selfClientName === "FireboltMainApp-refui") {
            callsign = "HtmlApp";
          } else if (items[i].applicationType === "YouTube" || items[i].applicationType === "YouTubeTV") {
            callsign = "Cobalt";
          }
          await appApi$d.getPluginStatus(callsign).catch(err => {
            console.log("Error:", err);
            items.splice(i, 1);
            i--;
          });
        }
      }
      return items;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */
  var COLORS = {
    textColor: 0xffffffff,
    titleColor: 0xffffffff,
    hightlightColor: 0xffc0c0c0,
    headingColor: 0xffffffff
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class SettingsItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SettingsMainItem extends SettingsItem {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$i = thunderJS$1(CONFIG.thunderConfig);
  let playerID = -1; //set to -1 to indicate nothing is currently playing

  let customServiceList = []; //list containing all channel details
  let customEventList = {}; //object with dvduri mapping to eventlist on that channel
  const getCustomServiceList = async () => {
    try {
      let response = await fetch("http://127.0.0.1:50050/lxresui/static/moreChannels/ChannelData.json");
      response = await response.json();
      customServiceList = response.serviceList;
      customEventList = response.eventList;
      console.log("customServiceList: ", customServiceList);
      console.log("customEventList: ", customEventList);
    } catch (err) {
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", JSON.stringify(err), false, null);
      console.log("Failed to read Custom Channel Data: ", err);
    }
  };
  getCustomServiceList(); //call this method in activate

  //plugin is activated by default, no need to call explicitly
  class DTVApi {
    activate() {
      return new Promise((resolve, reject) => {
        thunder$i.Controller.activate({
          callsign: "DTV"
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Activation", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error while Thunder Controller DTV activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        thunder$i.Controller.deactivate({
          callsign: "DTV"
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Deactivation", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error while Thunder Controller DTV deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    //gets the number of available countries
    noOfCountries() {
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "numberOfCountries").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: noOfCountries: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV numberOfCountries " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    //returns the list of the available countries
    countryList() {
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "countryList").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: countryList: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV countryList " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    //returns the list of services(channels with name, uri and other details)
    serviceList() {
      let arr = [{
        shortname: "Amazon Prime",
        callsign: "Amazon",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "Netflix",
        callsign: "Netflix",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "YouTube",
        callsign: "YouTube",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "YouTubeTV",
        callsign: "YouTubeTV",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }];
      if (customServiceList) {
        arr = arr.concat(JSON.parse(JSON.stringify(customServiceList)));
      }
      console.log("arr from serviceList: ", arr);
      return new Promise(resolve => {
        thunder$i.call("DTV", "serviceList@dvbs").then(result => {
          arr = arr.concat(result);
          console.log("serviceListResult: ", JSON.stringify(arr));
          resolve(arr);
        }).catch(err => {
          console.log("Error: serviceList: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV serviceList@dvbs " + JSON.stringify(err), false, null);
          resolve(arr);
        });
      });
    }
    getEvents(dvburi) {
      return customEventList[dvburi];
    }

    //returns the schedule for the given channel with provided dvburi
    scheduleEvents(dvburi) {
      let method = 'scheduleEvents@' + dvburi;
      return new Promise((resolve, reject) => {
        if (dvburi.startsWith("C_")) {
          let data = customEventList[dvburi];
          if (data) {
            // resolve([]); //need to pass actual data here
            data = JSON.parse(JSON.stringify(data));
            for (let show of data) {
              show.starttime *= 1000;
              show.duration *= 1000;
            }
            resolve(data);
          } else {
            console.log("Error: getting schedule from custom channels");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error: getting schedule from custom channels", false, null);
            resolve([]);
          }
        } else {
          thunder$i.call("DTV", method).then(result => {
            console.log("scheduleEventsResult: ", JSON.stringify(result));
            for (let show of result) {
              show.starttime *= 1000;
              show.duration *= 1000;
            }
            resolve(result);
          }).catch(err => {
            console.log("Error: scheduleEvents: ", JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV scheduleEvents@dvbs " + JSON.stringify(err), false, null);
            reject(err);
          });
        }
      });
    }

    //lists the satellites available
    satelliteList() {
      return new Promise((resolve, reject) => {
        // resolve([{name: "Satellite 1",longitude: 282,lnb: "Universal" },{name: "Satellite 2",longitude: 282,lnb: "Universal" }]) //#forTesting
        thunder$i.call("DTV", "satelliteList").then(result => {
          if (result.length === 0) {
            result = [{
              "name": "Astra 28.2E",
              "longitude": 282,
              "lnb": "Universal"
            }];
          }
          resolve(result);
        }).catch(err => {
          console.log("Error: satelliteList: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV satelliteList " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    //returns the available polarity options for dvb-s scan, returns a list of static values
    polarityList() {
      return new Promise(resolve => {
        resolve(["horizontal", "vertical", "left", "right"]);
      });
    }

    //returns the available symbolRate options for dvb-s scan, returns a list of static values
    symbolRateList() {
      return new Promise(resolve => {
        resolve(["22000", "23000", "27500", "29500"]); //values can be edited/entered custom from UI, no need to mention custom here
      });
    }
    //returns the available FEC options for dvb-s scan, returns a list of static values
    fecList() {
      return new Promise(resolve => {
        resolve(["fecauto", "fec1_2", "fec2_3", "fec3_4", "fec5_6", "fec7_8", "fec1_4", "fec1_3", "fec2_5", "fec8_9", "fec9_10", "fec3_5", "fec4_5"]);
      });
    }
    //returns the available modulation options for dvb-s scan, returns a list of static values
    modulationList() {
      return new Promise(resolve => {
        resolve(["auto", "qpsk", "8psk", "16qam"]);
      });
    }
    //returns the available searchtype(searchmode) options for dvb-s scan, returns a list of static values
    searchtypeList() {
      return new Promise(resolve => {
        resolve(["frequency", "network"]);
      });
    }
    //initiates a service search for the provided params
    startServiceSearch(params) {
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "startServiceSearch", params).then(result => {
          //console.log("serviceSearchResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("serviceSearchError: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV startServiceSearch " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    //returns the number of available services(channels)
    noOfServices() {
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "numberOfServices").then(result => {
          //console.log("numberOfServicesResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: numberOfServices: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV numberOfServices " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    //returns the current and next event details for the given channel with provided dvburi
    nowNextEvents(dvburi) {
      let method = "nowNextEvents@" + dvburi;
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", method).then(result => {
          //console.log("nowNextEventsResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: nowNextEvents: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV nowNextEvents@dvbs " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    startPlaying(params) {
      //params contains dvburi and lcn
      console.log("PARAMS: startPlaying: ", JSON.stringify(params));
      if (playerID !== -1) {
        this.stopPlaying();
        return Promise.reject("something is still playing Please retry");
      }
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "startPlaying", params).then(result => {
          console.log("RESULT: startPlaying: ", JSON.stringify(result));
          if (result === -1) {
            reject("Can't be played");
          } else {
            playerID = result; //to be used in stopPlaying method
            resolve(result);
          }
        }).catch(err => {
          console.log("ERROR: startPlaying: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV startPlaying " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    stopPlaying() {
      return new Promise((resolve, reject) => {
        thunder$i.call("DTV", "stopPlaying", playerID).then(result => {
          //playerID is retuned from startPlaying method
          console.log("RESULT: stopPlaying: ", JSON.stringify(result)); //result is always null
          playerID = -1; //to set that nothing is being played currently
          resolve(true);
        }).catch(err => {
          console.log("ERROR: stopPlaying: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", "Error in Thunder DTV stopPlaying " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    launchChannel(dvburi) {
      console.log("PARAMS: launchChannel: ", JSON.stringify(dvburi));
      if (playerID !== -1) {
        this.exitChannel();
        console.log("launchChannel: FAIL: something is still playing, trying to call exitChannel");
        return Promise.reject("Fail: something is still playing");
      }
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "open"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "openRequest": {
            "type": "main",
            "locator": "dtv://" + dvburi,
            "playerParams": {
              "subContentType": "live",
              "window": "0,0,1920,1080",
              "videoBlank": false
            }
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("launchChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("launchChannel: SUCCESS: ", JSON.stringify(result));
          playerID = result.openStatus.sessionId;
          console.log("launchChannel: SESSIONID: ", playerID);
          resolve(result);
        }).catch(err => {
          console.log("launchChannel: FAILED: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    exitChannel() {
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "close"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "closeRequest": {
            "sessionId": playerID
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("exitChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("exitChannel: SUCCESS: ", JSON.stringify(result));
          playerID = -1;
          resolve(result);
        }).catch(err => {
          console.log("exitChannel: FAILED: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DTVApiError", JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var thunder$h = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class for settings screen.
   */
  class SettingsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SettingsScreenContents: {
          x: 200,
          y: 275,
          NetworkConfiguration: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Configuration'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Bluetooth: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Pair Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Video: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Video'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Audio: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OtherSettings: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Other Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NFRStatus: {
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Native Frame Rate'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          DTVSettings: {
            alpha: 0.3,
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Live TV'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          VoiceRemoteControl: {
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Voice Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('NetworkConfiguration');
    }
    _focus() {
      this._setState(this.state);
    }
    _firstActive() {
      if (Storage$1.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      if (Storage$1.get("deviceType") != "IpStb") {
        this.dtvApi.activate().then(() => {
          this.dtvPlugin = true;
          this.tag("DTVSettings").alpha = 1;
        });
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('menu');
      }
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag('NetworkConfiguration')._focus();
        }
        $exit() {
          this.tag('NetworkConfiguration')._unfocus();
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network');
          }
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkConfiguration');
        }
        _handleDown() {
          this._setState('Video');
        }
        _handleLeft() {}
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/bluetooth');
          }
        }
      }, class Video extends this {
        $enter() {
          this.tag('Video')._focus();
        }
        $exit() {
          this.tag('Video')._unfocus();
        }
        _handleUp() {
          this._setState('Bluetooth');
        }
        _handleDown() {
          this._setState('Audio');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/video');
          }
        }
      }, class Audio extends this {
        $enter() {
          this.tag('Audio')._focus();
        }
        $exit() {
          this.tag('Audio')._unfocus();
        }
        _handleUp() {
          this._setState('Video');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio');
          }
        }
        _handleDown() {
          this._setState('OtherSettings');
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag('OtherSettings')._focus();
        }
        $exit() {
          this.tag('OtherSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Audio');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other');
          }
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          this._setState('VoiceRemoteControl');
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage$1.get("NFRStatus")) {
            thunder$h.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage$1.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              console.error(nerr);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'PluginError', "Thunder Netflix.1 nfrstatus disabling error" + JSON.stringify(nerr), false, null);
            });
          } else {
            thunder$h.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage$1.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              console.error(nerr);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'PluginError', "Thunder Netflix.1 nfrstatus enabling error" + JSON.stringify(nerr), false, null);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag('DTVSettings')._focus();
        }
        $exit() {
          this.tag('DTVSettings')._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            Router.navigate('settings/livetv');
          }
        }
      }, class VoiceRemoteControl extends this {
        $enter() {
          this.tag('VoiceRemoteControl')._focus();
        }
        $exit() {
          this.tag('VoiceRemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/bluetooth/RCVolumeInfoScreen');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class ListItem extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {},
          DefaultImage: {
            src: Utils.asset('/images/metroApps/offline.png'),
            alpha: 0
          }
        }
      };
    }
    _init() {
      this.tag('Image').on('txError', () => {
        this.tag('DefaultImage').patch({
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          alpha: 1
        });
      });
      this.tag('Image').on('txLoaded', () => {
        this.tag('DefaultImage').alpha = 0;
      });
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      if (!this.data.url) {
        console.log("data from app carousal: ", this.data);
      }
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      if (this.tag('DefaultImage').alpha) {
        this.tag('DefaultImage').patch({
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          zIndex: 1,
          scale: this.focus
        });
      }
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      if (this.tag('DefaultImage').alpha) {
        this.tag('DefaultImage').patch({
          w: this.w,
          h: this.h,
          scale: this.unfocus,
          zIndex: 0
        });
      }
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        zIndex: 0
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var imageListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var musicListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var videoListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var UsbInnerFolderListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let thunder$g = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class that contains functions which commuicates with thunder API's
   */
  class UsbApi {
    /**
    *  Function to activate USB Access Plugin
    */
    activate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$g.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Activation Failed: ' + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error while Thunder Controller usbAccess activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    /**
    *  Function to deactivate USB Access Plugin
    */
    deactivate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$g.Controller.deactivate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Deactivation Failed: ' + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error while Thunder Controller usbAccess deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    clearLink() {
      return new Promise(resolve => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$g.call(systemcCallsign, 'clearLink').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('UsbAccess Plugin ClearLink Failed: ' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error in Thunder usbAccess clearLink " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    createLink() {
      return new Promise(resolve => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$g.call(systemcCallsign, 'createLink').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('UsbAccess Plugin CreateLink Failed: ' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error in Thunder usbAccess createLink " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    /**
    *  Function to get getUsbList
    */
    getUsbFileList() {
      if (arguments.length === 0) {
        return new Promise(resolve => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$g.call(systemcCallsign, 'getFileList').then(result => {
            resolve(result.contents);
          }).catch(err => {
            console.error('UsbAccess Plugin getFileList Failed: ' + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error in Thunder usbAccess getFileList " + JSON.stringify(err), false, null);
            resolve(false);
          });
        });
      } else {
        return new Promise(resolve => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$g.call(systemcCallsign, 'getFileList', {
            "path": arguments[0]
          }).then(result => {
            resolve(result.contents);
          }).catch(err => {
            console.error('UsbAccess Plugin getFileList Failed: ' + JSON.stringify(err));
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error in Thunder usbAccess getFileList " + JSON.stringify(err), false, null);
            resolve(false);
          });
        });
      }
    }
    retrieUsb() {
      this.usbLink = "";
      let self = this;
      return new Promise((resolve, reject) => {
        self.clearLink().then(() => {
          self.createLink().then(res => {
            if (res.success) {
              self.usbLink = res.baseURL;
              self.getUsbFileList().then(result1 => {
                self.getUsbContentList(result1);
                resolve(true);
              }).catch(err => {
                reject(err);
              });
            }
          }).catch(err => {
            reject(err);
          });
        }).catch(err => {
          reject(err);
        });
      });
    }
    destroy() {
      imageListInfo.length = 0;
      videoListInfo.length = 0;
      musicListInfo.length = 0;
      UsbInnerFolderListInfo.length = 0;
    }
    cd(dname) {
      return new Promise((resolve, reject) => {
        this.getUsbFileList(dname).then(result1 => {
          this.getUsbContentList(result1, dname);
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getMountedDevices() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = "org.rdk.UsbAccess";
        thunder$g.call(systemcCallsign, 'getMounted').then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
          console.error("Error while getting the mounted device ".concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "UsbApiError", "Error in Thunder usbAccess getMounted " + JSON.stringify(err), false, null);
        });
      });
    }
    getUsbContentList(result) {
      this.destroy();
      let cwd = this.usbLink;
      if (arguments[1]) {
        cwd = cwd + '/' + arguments[1];
      }
      // to add support for more formats, extension can be added same as below
      let extensionForImage = ['.png', '.jpg', '.PNG', '.jpeg', '.JPEG', '.jpg', '.JPG'];
      let extensionForVideo = ['.mp4', '.MP4', '.mov', '.MOV', '.avi', '.AVI', '.m3u8', '.M3U8', '.mpeg2', '.MPEG2'];
      let extensionForAudio = ['.mp3', '.mpeg', '.MP3', '.MPEG'];
      this._discoveredC = result;
      //   console.log("Discovered result :: " + JSON.stringify(result));

      this._discoveredC.filter(device => {
        for (let i in extensionForImage) {
          if (device.name.indexOf(extensionForImage[i]) !== -1) {
            let obj1 = {
              displayName: device.name,
              uri: cwd + '/' + device.name,
              url: cwd + '/' + device.name
              // url: '/images/usb/picture-default-tile.jpg',
              // url: '/images/usb/USB_Photo_Placeholder.jpg',
              // uri: this.usbLink + '/' + device.name,
            };
            imageListInfo.push(obj1);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForVideo) {
          if (device.name.indexOf(extensionForVideo[i]) !== -1) {
            let obj2 = {
              displayName: device.name,
              //  url: '/images/usb/video-default-tile.jpg',
              url: '/images/usb/USB_Video_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            videoListInfo.push(obj2);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForAudio) {
          if (device.name.indexOf(extensionForAudio[i]) !== -1) {
            let obj3 = {
              displayName: device.name,
              //  url: '/images/usb/music-default-tile.jpg',
              url: '/images/usb/USB_Audio_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            musicListInfo.push(obj3);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        if (device.t === 'd') {
          if (!(device.name === '.' || device.name === "..")) {
            let obj4 = {
              displayName: device.name,
              url: "/images/usb/USB_Folder.jpg",
              uri: cwd + "/" + device.name
            };
            UsbInnerFolderListInfo.push(obj4);
            return device;
          }
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Xcast thunder plugin apis.
   */
  class XcastApi {
    constructor() {
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
      console.log('Xcast constructor');
      this._events = new Map();
    }

    /**
     * Function to activate the Xcast plugin
     */
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Xcast';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Xcast activation success ' + result);
          this._thunder.call('org.rdk.Xcast', 'setEnabled', {
            enabled: true
          }).then(result => {
            if (result.success) {
              console.log('Xcast enabled');
              this._thunder.on(this.callsign, 'onApplicationLaunchRequest', notification => {
                console.log('onApplicationLaunchRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationLaunchRequest')) {
                  this._events.get('onApplicationLaunchRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationHideRequest', notification => {
                console.log('onApplicationHideRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationHideRequest')) {
                  this._events.get('onApplicationHideRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationResumeRequest', notification => {
                console.log('onApplicationResumeRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationResumeRequest')) {
                  this._events.get('onApplicationResumeRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStopRequest', notification => {
                console.log('onApplicationStopRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStopRequest')) {
                  this._events.get('onApplicationStopRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStateRequest', notification => {
                // console.log('onApplicationStateRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStateRequest')) {
                  this._events.get('onApplicationStateRequest')(notification);
                }
              });
              resolve(true);
            } else {
              console.log('Xcast enabled failed');
            }
          }).catch(err => {
            console.error('Enabling failure', err);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error in Thunder Xcast enable  " + JSON.stringify(err), false, null);
            reject('Xcast enabling failed', err);
          });
        }).catch(err => {
          console.error('Activation failure', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error in Thunder Controller Xcast activate " + JSON.stringify(err), false, null);
          reject('Xcast activation failed', err);
        });
      });
    }
    getEnabled() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'getEnabled').then(res => {
          resolve(res);
        }).catch(err => {
          console.log('Xdial error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error while fetching Thunder Xcast enable status" + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getFriendlyName() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'getFriendlyName').then(res => {
          resolve(res);
        }).catch(err => {
          console.log('Xdial getFriendlyName error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error while getting Thunder Xcast FriendlyName " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setFriendlyName(name) {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Xcast', 'setFriendlyName', {
          friendlyname: name
        }).then(result => {
          console.log("Xcast setFriendlyName: " + name + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.error(err);
          resolve(false);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error while setting Thunder Xcast FriendlyName " + JSON.stringify(err), false, null);
        });
      }).then(val => {
        console.log("The resolved value is:", val);
      }).catch(error => {
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "An error occurred: " + JSON.stringify(err), false, null);
        console.error("An error occurred:", error);
      });
    }
    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Xcast plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Xcast plugin.
     */
    deactivate() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Xcast', 'setEnabled', {
          enabled: false
        }).then(res => {
          resolve(res.success);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error while setting Thunder Xcast enable " + JSON.stringify(err), false, null);
          console.log('Failed to close Xcast', err);
        });
      });
    }

    /**
     * Function to notify the state of the app.
     */
    onApplicationStateChanged(params) {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Xcast.1', 'onApplicationStateChanged', params).then(result => {
          //console.log("XCastAPI onApplicationStateChanged Updating: "+ JSON.stringify(params) +" result: ",JSON.stringify(result))
          resolve(result);
        }).catch(err => {
          console.error(err);
          resolve(false);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "XcastApiError", "Error in Thunder Xcast.1 onApplicationStateChange " + JSON.stringify(err), false, null);
        });
      });
    }
    static supportedApps() {
      let xcastApps = {
        AmazonInstantVideo: 'Amazon',
        YouTube: 'YouTube',
        NetflixApp: 'Netflix',
        YouTubeTV: "YouTubeTV"
      };
      return xcastApps;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class GracenoteItem extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      let imgUrl = this.data.program.preferredImage.uri.replace("w=1280&", "w=480&").replace("&h=720", "&h=270");
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      this.tag('Image').patch({
        rtt: true,
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        src: Utils.proxyUrl('http://developer.tmsimg.com/' + imgUrl + '&api_key=' + this.key),
        scale: this.unfocus
      });

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 20,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.program.title,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CollectionWrapper extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {}
      };
    }
    _construct() {
      this._direction = CollectionWrapper.DIRECTION.row;
      this._scrollTransitionSettings = this.stage.transitions.createSettings({});
      this._spacing = 0;
      this._autoResize = false;
      this._requestingItems = false;
      this._requestThreshold = 1;
      this._requestsEnabled = false;
      this._gcThreshold = 5;
      this._gcIncrement = 0;
      this._forceLoad = false;
      this.clear();
    }
    _setup() {
      this._updateScrollTransition();
    }
    _updateScrollTransition() {
      const axis = this._direction === 1 ? 'y' : 'x';
      this.wrapper.transition(axis, this._scrollTransitionSettings);
      this._scrollTransition = this.wrapper.transition(axis);
    }
    _indexChanged(obj) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let {
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        target = mainIndex;
        max = lines;
      }
      if (this._requestsEnabled && !this._requestingItems) {
        if (target + this._requestThreshold >= max) {
          this.requestItems(false, obj);
        }
      }
      this._refocus();
      this.scrollCollectionWrapper(obj, options);
      if (obj.previousIndex !== obj.index) {
        this.signal('onIndexChanged', obj);
      }
    }
    requestItems() {
      let reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (obj === undefined) {
        obj = {
          previousIndex: 0,
          index: this._index,
          mainIndex: this._mainIndex || 0,
          previousMainIndex: this._mainIndex || 0,
          crossIndex: this._crossIndex || 0,
          previousCrossIndex: this._crossIndex || 0,
          lines: this._lines && this._lines.length || 0,
          dataLength: this._items && this._items.length || 0
        };
      }
      this._requestingItems = true;
      this._request(obj).then(response => {
        this._requestingItems = false;
        if (reload) {
          this.clear();
        }
        const type = typeof response;
        if (Array.isArray(response) && response.length > 0 || type === 'object' || type === 'string' || type === 'number') {
          this.add(response);
          obj.dataLength = this._items && this._items.length || 0;
          this.signal('onRequestItemsAdded', obj);
        }
      });
    }
    _request(obj) {
      return new Promise(resolve => {
        this.signal('onRequestItems', obj).then(response => {
          if (response === undefined || response === false || Array.isArray(response) && response.length === 0) {
            this.enableRequests = false;
          }
          resolve(response);
        });
      });
    }
    _requestMore(index) {
      var _this = this;
      let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      let options = arguments.length > 2 ? arguments[2] : undefined;
      const obj = {
        previousIndex: this._index,
        index,
        mainIndex: this._mainIndex || 0,
        previousMainIndex: this._previous && this._previous.mainIndex || 0,
        crossIndex: this._crossIndex || 0,
        previousCrossIndex: this._previous && this._previous.crossIndex || 0,
        lines: this._lines && this._lines.length || 0,
        dataLength: data.length + (this._items && this._items.length || 0)
      };
      this._requestingItems = true;
      return new Promise(resolve => {
        this._request(obj).then(function () {
          let response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          if (response) {
            const newData = [...data, ...response];
            if (index > _this._items.length + newData.length) {
              _this._requestMore(index, newData).then(resolve);
            } else {
              _this.add(newData);
              obj.dataLength = _this._items && _this._items.length || 0;
              _this.signal('onRequestItemsAdded', obj);
              _this._requestingItems = false;
              _this.setIndex(index, options);
              resolve(true);
            }
          } else {
            _this._requestingItems = false;
            resolve(false);
          }
        });
      });
    }
    setIndex(index) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._requestsEnabled && index > this._items.length - 1) {
        if (!this._requestingItems) {
          this._requestMore(index, [], options);
        }
        return true;
      }
      if (this._items.length === 0) {
        this._index = 0;
        return false;
      }
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        dataLength: this._items.length
      }, options);
      return previousIndex !== targetIndex;
    }
    clear() {
      this._uids = [];
      this._items = [];
      this._index = 0;
      if (this._scrollTransition && this._scrollTransition.isRunning()) {
        this._scrollTransition.reset(0, 1);
      }
      if (this.wrapper) {
        const hadChildren = this.wrapper.children.length > 0;
        this.wrapper.patch({
          x: 0,
          y: 0,
          children: []
        });
        if (hadChildren) {
          this._collectGarbage(true);
        }
      }
    }
    add(item) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.addAt(item, this._items.length, options);
    }
    addAt(item) {
      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._items.length;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (index >= 0 && index <= this._items.length) {
        if (!Array.isArray(item)) {
          item = [item];
        }
        const items = this._normalizeDataItems(item);
        this._items.splice(index, 0, ...items);
        this.plotItems(options);
        const targetIndex = index < this._index ? this._index + items.length : this._index;
        this.setIndex(targetIndex, options);
      } else {
        throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
    }
    remove(target) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this.hasItems && target.assignedID) {
        for (let i = 0; i < this._items.length; i++) {
          let item = this._items[i];
          if (target.assignedID === item.assignedID) {
            if (i === this._items.length - 1 && this._index === this._items.length - 1) {
              this._index = this._index - 1;
            }
            return this.removeAt(i, 1, options);
          }
        }
      } else {
        throw new Error('remove: item not found');
      }
    }
    removeAt(index) {
      let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (index < 0 && index >= this._items.length) {
        throw new Error('removeAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
      const item = this._items[index];
      this._items.splice(index, amount);
      if (this._items.length > 0) {
        this.plotItems(options);
      }
      this.setIndex(this.index);
      return item;
    }
    reload(item) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.clear();
      this.add(item, options);
    }
    plotItems() {
    } //placeholder
    reposition() {
      let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 70;
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._repositionDebounce = setTimeout(() => {
        this.repositionItems();
      }, time);
    }
    repositionItems() {
      //placeHolder
      this.signal('onItemsRepositioned');
    }
    up() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(-1, 1, options);
    }
    down() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(1, 1, options);
    }
    left() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(-1, 0, options);
    }
    right() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(1, 0, options);
    }
    first() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(0, options);
    }
    last() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._items.length - 1, options);
    }
    next() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._index + 1, options);
    }
    previous() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._index - 1, options);
    }
    _attemptNavigation(shift, direction) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (this.hasItems) {
        return this.navigate(shift, direction, options);
      }
      return false;
    }
    navigate(shift) {
      let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._direction;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (direction !== this._direction) {
        return false;
      }
      return this.setIndex(this._index + shift, options);
    }
    scrollCollectionWrapper(obj) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        immediate = false
      } = options;
      let {
        previousIndex: previous,
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        previous = previousMainIndex;
        target = mainIndex;
        max = lines;
      }
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginFrom,
        mainMarginTo
      } = this._getPlotProperties(this._direction);
      const cw = this.currentItemWrapper;
      let bound = this[mainDim];
      if (bound === 0) {
        bound = directionIsRow ? 1920 : 1080;
      }
      const offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
      const sizes = this._getItemSizes(cw);
      const marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
      const marginTo = sizes[mainMarginTo] || sizes.margin || 0;
      let scroll = this._scroll;
      if (!isNaN(scroll)) {
        if (scroll >= 0 && scroll <= 1) {
          scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
        } else {
          scroll = scroll - cw[main];
        }
      } else if (typeof scroll === 'function') {
        scroll = scroll.apply(this, [cw, obj]);
      } else if (typeof scroll === 'object') {
        const {
          jump = false,
          after = false,
          backward = 0.0,
          forward = 1.0
        } = scroll;
        if (jump) {
          let mod = target % jump;
          if (mod === 0) {
            scroll = marginFrom - cw[main];
          }
          if (mod === jump - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = mod * actualSize + marginFrom - cw[main];
          }
        } else if (after) {
          scroll = 0;
          if (target >= after - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = (after - 1) * actualSize + marginFrom - cw[main];
          }
        } else {
          const backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
          const forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
          if (target < max - 1 && previous < target && offset + cw[main] + cw[mainDim] > forwardBound) {
            scroll = forwardBound - (cw[main] + cw[mainDim]);
          } else if (target > 0 && target < previous && offset + cw[main] < backwardBound) {
            scroll = backwardBound - cw[main];
          } else if (target === max - 1) {
            scroll = bound - (cw[main] + cw[mainDim]);
          } else if (target === 0) {
            scroll = marginFrom - cw[main];
          }
        }
      } else if (isNaN(scroll)) {
        if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
          scroll = bound - (cw[main] + cw[mainDim]);
        } else if (target < previous && offset + cw[main] < 0) {
          scroll = marginFrom - cw[main];
        }
      }
      if (this.active && !isNaN(scroll) && this._scrollTransition) {
        if (immediate) {
          this._scrollTransition.reset(scroll, 1);
        } else {
          if (this._scrollTransition.isRunning()) {
            this._scrollTransition.reset(scroll, 0.05);
          } else {
            this._scrollTransition.start(scroll);
          }
        }
      } else if (!isNaN(scroll)) {
        this.wrapper[main] = scroll;
        if (this._scrollTransition) {
          this._scrollTransition.reset(scroll, 1);
        }
      }
    }
    $childInactive(_ref) {
      let {
        child
      } = _ref;
      if (typeof child === 'object') {
        const index = child.componentIndex;
        for (let key in this._items[index]) {
          if (child.component[key] !== undefined) {
            this._items[index][key] = child.component[key];
          }
        }
      }
      this._collectGarbage();
    }
    $getChildComponent(_ref2) {
      let {
        index
      } = _ref2;
      return this._items[index];
    }
    _resizeWrapper(crossSize) {
      let obj = crossSize;
      if (!isNaN(crossSize)) {
        const {
          main,
          mainDim,
          crossDim
        } = this._getPlotProperties(this._direction);
        const lastItem = this.wrapper.childList.last;
        obj = {
          [mainDim]: lastItem[main] + lastItem[mainDim],
          [crossDim]: crossSize
        };
      }
      this.wrapper.patch(obj);
      if (this._autoResize) {
        this.patch(obj);
      }
    }
    _generateUniqueID() {
      let id = '';
      while (this._uids[id] || id === '') {
        id = Math.random().toString(36).substring(2, 9);
      }
      this._uids[id] = true;
      return id;
    }
    _getPlotProperties(direction) {
      const directionIsRow = direction === 0;
      return {
        directionIsRow: directionIsRow ? true : false,
        mainDirection: directionIsRow ? 'rows' : 'columns',
        main: directionIsRow ? 'x' : 'y',
        mainDim: directionIsRow ? 'w' : 'h',
        mainMarginTo: directionIsRow ? 'marginRight' : 'marginBottom',
        mainMarginFrom: directionIsRow ? 'marginLeft' : 'marginTop',
        crossDirection: !directionIsRow ? 'columns' : 'rows',
        cross: directionIsRow ? 'y' : 'x',
        crossDim: directionIsRow ? 'h' : 'w',
        crossMarginTo: directionIsRow ? 'marginBottom' : 'marginRight',
        crossMarginFrom: directionIsRow ? 'marginTop' : 'marginLeft'
      };
    }
    _getItemSizes(item) {
      const itemType = item.type;
      if (item.component && item.component.__attached) {
        item = item.component;
      }
      return {
        w: item.w || itemType && itemType['width'],
        h: item.h || itemType && itemType['height'],
        margin: item.margin || itemType && itemType['margin'] || 0,
        marginLeft: item.marginLeft || itemType && itemType['marginLeft'],
        marginRight: item.marginRight || itemType && itemType['marginRight'],
        marginTop: item.marginTop || itemType && itemType['marginTop'],
        marginBottom: item.marginBottom || itemType && itemType['marginBottom']
      };
    }
    _collectGarbage(immediate) {
      this._gcIncrement++;
      if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
        this._gcIncrement = 0;
        this.stage.gc();
      }
    }
    _normalizeDataItems(array) {
      return array.map((item, index) => {
        return this._normalizeDataItem(item) || index;
      }).filter(item => {
        if (!isNaN(item)) {
          console.warn("Item at index: ".concat(item, ", is not a valid item. Removing it from dataset"));
          return false;
        }
        return true;
      });
    }
    _normalizeDataItem(item, index) {
      if (typeof item === 'string' || typeof item === 'number') {
        item = {
          label: item.toString()
        };
      }
      if (typeof item === 'object') {
        let id = this._generateUniqueID();
        return {
          assignedID: id,
          type: this.itemType,
          collectionWrapper: this,
          isAlive: false,
          ...item
        };
      }
      return index;
    }
    _normalizePixelToPercentage(value, max) {
      if (value && value > 1) {
        return value / max;
      }
      return value || 0;
    }
    _getFocused() {
      if (this.hasItems) {
        return this.currentItemWrapper;
      }
      return this;
    }
    _handleRight() {
      return this.right();
    }
    _handleLeft() {
      return this.left();
    }
    _handleUp() {
      return this.up();
    }
    _handleDown() {
      return this.down();
    }
    _inactive() {
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._collectGarbage(true);
    }
    static get itemType() {
      return undefined;
    }
    set forceLoad(bool) {
      this._forceLoad = bool;
    }
    get forceLoad() {
      return this._forceLoad;
    }
    get requestingItems() {
      return this._requestingItems;
    }
    set requestThreshold(num) {
      this._requestThreshold = num;
    }
    get requestThreshold() {
      return this._requestThreshold;
    }
    set enableRequests(bool) {
      this._requestsEnabled = bool;
    }
    get enableRequests() {
      return this._requestsEnabled;
    }
    set gcThreshold(num) {
      this._gcThreshold = num;
    }
    get gcThreshold() {
      return this._gcThreshold;
    }
    get wrapper() {
      return this.tag('Wrapper');
    }
    get hasItems() {
      return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
    }
    get currentItemWrapper() {
      return this.wrapper.children[this._index];
    }
    get currentItem() {
      return this.currentItemWrapper && this.currentItemWrapper.component || undefined;
    }
    set direction(string) {
      this._direction = CollectionWrapper.DIRECTION[string] || CollectionWrapper.DIRECTION.row;
    }
    get direction() {
      return Object.keys(CollectionWrapper.DIRECTION)[this._direction];
    }
    set items(array) {
      this.clear();
      this.add(array);
    }
    get items() {
      const itemWrappers = this.itemWrappers;
      return this._items.map((item, index) => {
        if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
          return itemWrappers[index].component;
        }
        return item;
      });
    }
    get length() {
      return this._items.length;
    }
    set index(index) {
      this.setIndex(index);
    }
    get itemWrappers() {
      return this.wrapper.children;
    }
    get index() {
      return this._index;
    }
    set scrollTransition(obj) {
      this._scrollTransitionSettings.patch(obj);
      if (this.active) {
        this._updateScrollTransition();
      }
    }
    get scrollTransition() {
      return this._scrollTransition;
    }
    set scroll(value) {
      this._scroll = value;
    }
    get scroll() {
      return this._scroll;
    }
    set autoResize(bool) {
      this._autoResize = bool;
    }
    get autoResize() {
      return this._autoResize;
    }
    set spacing(num) {
      this._spacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  }
  CollectionWrapper.DIRECTION = {
    row: 0,
    column: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Cursor extends lng$1.Component {
    static _template() {
      return {
        alpha: 0
      };
    }
    _construct() {
      this._blink = true;
    }
    _init() {
      this._blinkAnimation = this.animation({
        duration: 1,
        repeat: -1,
        actions: [{
          p: 'alpha',
          v: {
            0: 0,
            0.5: 1,
            1: 0
          }
        }]
      });
    }
    show() {
      if (this._blink) {
        this._blinkAnimation.start();
      } else {
        this.alpha = 1;
      }
    }
    hide() {
      if (this._blink) {
        this._blinkAnimation.stop();
      } else {
        this.alpha = 0;
      }
    }
    set blink(bool) {
      this._blink = bool;
      if (this.active) {
        if (bool) {
          this.show();
        } else {
          this.hide();
        }
      }
    }
    get blink() {
      return this._blink;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ItemWrapper extends lng$1.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    create() {
      if (this.children.length > 0) {
        return;
      }
      const component = this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
      component.isAlive = true;
      const {
        w,
        h,
        margin,
        marginTop,
        marginBottom,
        marginRight,
        marginLeft
      } = this;
      this.children = [{
        ...component,
        w,
        h,
        margin,
        marginTop,
        marginRight,
        marginLeft,
        marginBottom
      }];
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    get component() {
      return this.children[0] || this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
    }
    _setup() {
      if (this.forceLoad) {
        this.create();
      }
    }
    _active() {
      this.create();
    }
    _inactive() {
      if (!this.forceLoad) {
        this.children[0].isAlive = false;
        this.fireAncestors('$childInactive', {
          child: this
        });
        this.childList.clear();
      }
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class KeyWrapper extends lng$1.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    _update() {
      let currentKey = this.children && this.children[0];
      if (currentKey && currentKey.action === this._key.data.action) {
        currentKey.patch({
          ...this._key
        });
      } else {
        this.children = [{
          type: this._key.keyType,
          ...this._key
        }];
      }
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    set key(obj) {
      this._key = obj;
      if (this.active) {
        this._update();
      }
    }
    get key() {
      return this._key;
    }
    _active() {
      this._update();
    }
    _inactive() {
      this.childList.clear();
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const limitWithinRange = (num, min, max) => {
    return Math.min(Math.max(num, min), max);
  };
  const defineProperties = (component, props) => {
    props.forEach(prop => {
      Object.defineProperty(component, prop, {
        set: function (value) {
          component["_".concat(prop)] = value;
        },
        get: function () {
          return component["_".concat(prop)];
        }
      });
    });
  };
  const findIndexOfObject = (array, search, targetProp) => {
    for (let i = 0; i < array.length; i++) {
      if (array[i][targetProp] === search) {
        return i;
      }
    }
    return -1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Grid extends CollectionWrapper {
    _construct() {
      this._crossSpacing = 5;
      this._mainSpacing = 5;
      this._rows = 0;
      this._columns = 0;
      super._construct();
    }
    clear() {
      super.clear();
      this._mainIndex = 0;
      this._crossIndex = 0;
      this._previous = undefined;
    }
    setIndex(index) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._requestsEnabled && index > this._items.length - 1) {
        if (!this._requestingItems) {
          this._requestMore(index, [], options);
        }
        return true;
      }
      if (this._items.length === 0) {
        this._mainIndex = 0;
        this._crossIndex = 0;
        this._index = 0;
        return false;
      }
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      const {
        mainIndex: previousMainIndex,
        crossIndex: previousCrossIndex
      } = this._findLocationOfIndex(previousIndex);
      const {
        mainIndex,
        crossIndex
      } = this._findLocationOfIndex(targetIndex);
      this._mainIndex = mainIndex;
      this._crossIndex = crossIndex;
      this._previous = {
        mainIndex,
        crossIndex,
        realIndex: previousIndex
      };
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        mainIndex,
        previousMainIndex,
        crossIndex,
        previousCrossIndex,
        lines: this._lines.length,
        dataLength: this._items.length
      }, options);
      return previousIndex !== targetIndex;
    }
    _findLocationOfIndex(index) {
      for (let i = 0; i < this._lines.length; i++) {
        if (this._lines[i].includes(index)) {
          return {
            mainIndex: i,
            crossIndex: this._lines[i].indexOf(index)
          };
        }
      }
      return {
        mainIndex: -1,
        crossIndex: -1
      };
    }
    plotItems() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        immediate = false
      } = options;
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        mainDirection,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      this._lines = [[]];
      //create empty line array
      let cl = [];
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        const ref = "IW-".concat(item.assignedID);
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        const newItem = {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(newItem);
        return newItem;
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        if (immediate) {
          item.patch({
            x: item.assignedX,
            y: item.assignedY
          });
        } else {
          item.patch({
            smooth: {
              x: item.assignedX,
              y: item.assignedY
            }
          });
        }
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;

      //create empty line array
      let cl = [];
      this.lines = [[]];
      wrapper.children.forEach((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: mainPos,
          [cross]: crossPos
        });
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(item);
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
      super.repositionItems();
    }
    _getBiggestInLine(line) {
      const {
        mainDim
      } = this._getPlotProperties(this._direction);
      return line.reduce((biggestItem, newItem) => {
        if (newItem[mainDim] > biggestItem[mainDim]) {
          return newItem;
        }
        return biggestItem;
      });
    }
    navigate(shift, direction) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const {
        directionIsRow,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      const overCross = directionIsRow && direction === CollectionWrapper.DIRECTION.column || !directionIsRow && direction === CollectionWrapper.DIRECTION.row;
      let targetMainIndex = this._mainIndex + !!!overCross * shift;
      let targetCrossIndex = this._crossIndex + !!overCross * shift;
      let targetIndex = this._index;
      if (overCross && targetCrossIndex > -1 && targetCrossIndex <= this._lines[targetMainIndex].length) {
        if (this._lines[targetMainIndex][targetCrossIndex] !== undefined) {
          targetIndex = this._lines[targetMainIndex][targetCrossIndex];
          this._previous = undefined;
        }
      } else if (!overCross && targetMainIndex < this._lines.length && targetMainIndex > -1) {
        const targetLine = this._lines[targetMainIndex];
        if (this._previous && this._previous.mainIndex === targetMainIndex) {
          targetIndex = this._previous.realIndex;
          targetCrossIndex = this._previous.crossIndex;
        } else if (targetLine) {
          const currentItem = this.currentItemWrapper;
          const m = targetLine.map(item => {
            const targetItem = this.wrapper.children[item];
            if (targetItem[cross] <= currentItem[cross] && currentItem[cross] <= targetItem[cross] + targetItem[crossDim]) {
              return targetItem[cross] + targetItem[crossDim] - currentItem[cross];
            }
            if (targetItem[cross] >= currentItem[cross] && targetItem[cross] <= currentItem[cross] + currentItem[crossDim]) {
              return currentItem[cross] + currentItem[crossDim] - targetItem[cross];
            }
            return -1;
          });
          let acc = -1;
          let t = -1;
          for (let i = 0; i < m.length; i++) {
            if (m[i] === -1 && acc > -1) {
              break;
            }
            if (m[i] > acc) {
              acc = m[i];
              t = i;
            }
          }
          if (t > -1) {
            targetCrossIndex = t;
            targetIndex = targetLine[t];
          }
        }
        this._previous = {
          mainIndex: this._mainIndex,
          crossIndex: this._crossIndex,
          realIndex: this._index
        };
      }
      if (this._index !== targetIndex) {
        this.setIndex(targetIndex, options);
        return true;
      }
      return false;
    }
    set rows(num) {
      this._rows = num;
      this.direction = 'row';
    }
    get rows() {
      return this._rows;
    }
    set columns(num) {
      this._columns = num;
      this.direction = 'column';
    }
    get columns() {
      return this._columns;
    }
    set crossSpacing(num) {
      this._crossSpacing = num;
    }
    get crossSpacing() {
      return this._crossSpacing;
    }
    set mainSpacing(num) {
      this._mainSpacing = num;
    }
    get mainSpacing() {
      return this._mainSpacing;
    }
    set spacing(num) {
      this._spacing = num;
      this._mainSpacing = num;
      this._crossSpacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class InputField extends lng$1.Component {
    static _template() {
      return {
        PreLabel: {
          renderOffscreen: true
        },
        PostLabel: {
          renderOffscreen: true
        },
        Cursor: {
          type: Cursor,
          rect: true,
          w: 4,
          h: 54,
          x: 0,
          y: 0
        }
      };
    }
    _construct() {
      this._input = '';
      this._previousInput = '';
      this._description = '';
      this._cursorX = 0;
      this._cursorIndex = 0;
      this._passwordMask = '*';
      this._passwordMode = false;
      this._autoHideCursor = true;
      this._labelPositionStatic = true;
      this._maxLabelWidth = 0;
    }
    _init() {
      this.tag('PreLabel').on('txLoaded', () => {
        this._labelTxLoaded();
      });
      this.tag('PostLabel').on('txLoaded', () => {
        this._labelTxLoaded;
      });
    }
    onInputChanged(_ref) {
      let {
        input = ''
      } = _ref;
      let targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
      this._input = input;
      this._update(targetIndex);
    }
    toggleCursor() {
      let bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this._cursorVisible;
      this._cursorVisible = bool;
      this.cursor[bool ? 'show' : 'hide']();
    }
    _labelTxLoaded() {
      const preLabel = this.tag('PreLabel');
      const cursor = this.tag('Cursor');
      const postLabel = this.tag('PostLabel');
      this.h = preLabel.renderHeight || postLabel.renderHeight;
      cursor.x = preLabel.renderWidth + this._cursorX;
      postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
      this.setSmooth('x', this._labelOffset);
      if (!this.autoHideCursor) {
        this.toggleCursor(true);
      }
    }
    _update() {
      let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const hasInput = this._input.length > 0;
      let pre = this._description + '';
      let post = '';
      if (hasInput) {
        pre = this._input.substring(0, index);
        post = this._input.substring(index, this._input.length);
        if (this._passwordMode) {
          pre = this._passwordMask.repeat(pre.length);
          post = this._passwordMask.repeat(post.length);
        }
        this.toggleCursor(true);
      } else if (this._autoHideCursor) {
        this.toggleCursor(false);
      }
      this.patch({
        PreLabel: {
          text: {
            text: pre
          }
        },
        PostLabel: {
          text: {
            text: post
          }
        }
      });
      if (this.h === 0) {
        this.tag('PreLabel').loadTexture();
        this.h = this.tag('PreLabel').renderHeight;
      }
      this._cursorIndex = index;
    }
    _handleRight() {
      this._update(Math.min(this._input.length, this._cursorIndex + 1));
    }
    _handleLeft() {
      this._update(Math.max(0, this._cursorIndex - 1));
    }
    _firstActive() {
      this._labelTxLoaded();
      this._update();
    }
    get input() {
      return this._input;
    }
    get hasInput() {
      return this._input.length > 0;
    }
    get cursorIndex() {
      return this._cursorIndex;
    }
    set inputText(obj) {
      this._inputText = obj;
      this.tag('PreLabel').patch({
        text: obj
      });
      this.tag('PostLabel').patch({
        text: obj
      });
    }
    get inputText() {
      return this._inputText;
    }
    set description(str) {
      this._description = str;
    }
    get description() {
      return this._description;
    }
    set cursor(obj) {
      if (obj.x) {
        this._cursorX = obj.x;
        delete obj.x;
      }
      this.tag('Cursor').patch(obj);
    }
    get cursor() {
      return this.tag('Cursor');
    }
    get cursorVisible() {
      return this._cursorVisible;
    }
    set autoHideCursor(bool) {
      this._autoHideCursor = bool;
    }
    get autoHideCursor() {
      return this._autoHideCursor;
    }
    set passwordMode(val) {
      this._passwordMode = val;
    }
    get passwordMode() {
      return this._passwordMode;
    }
    set passwordMask(str) {
      this._passwordMask = str;
    }
    get passwordmask() {
      return this._passwordMask;
    }

    // the width at which the text start scrolling
    set maxLabelWidth(val) {
      this._maxLabelWidth = val;
    }
    get maxLabelWidth() {
      return this._maxLabelWidth;
    }
    set labelPositionStatic(val) {
      this._labelPositionStatic = val;
    }
    get labelPositionStatic() {
      return this._labelPositionStatic;
    }
    get _labelOffset() {
      if (this._labelPositionStatic) return 0;
      let offset = this.maxLabelWidth - this.tag('Cursor').x;
      return offset < 0 ? offset : 0;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Key$1 extends lng$1.Component {
    static _template() {
      return {
        Background: {
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._backgroundColors = {};
      this._labelColors = {};
    }
    set data(obj) {
      this._data = obj;
      this._update();
    }
    get data() {
      return this._data;
    }
    set labelText(obj) {
      this._labelText = obj;
      this.tag('Label').patch({
        text: obj
      });
    }
    get labelText() {
      return this._labelText;
    }
    set label(obj) {
      this.tag('Label').patch(obj);
    }
    get label() {
      return this.tag('Label');
    }
    set labelColors(obj) {
      this._labelColors = obj;
      this._update();
    }
    get labelColors() {
      return this._labelColors;
    }
    set backgroundColors(obj) {
      this._backgroundColors = obj;
      this._update();
    }
    get backgroundColors() {
      return this._backgroundColors;
    }
    set background(obj) {
      this.tag('Background').patch(obj);
    }
    get background() {
      return this.tag('Background');
    }
    _update() {
      if (!this.active) {
        return;
      }
      const {
        label = ''
      } = this._data;
      const hasFocus = this.hasFocus();
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          color: hasFocus && focused ? focused : unfocused
        },
        Label: {
          text: {
            text: label
          },
          color: hasFocus && labelFocused ? labelFocused : labelUnfocused
        }
      });
    }
    _firstActive() {
      this._update();
    }
    _focus() {
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: focused || unfocused
          }
        },
        Label: {
          smooth: {
            color: labelFocused || labelUnfocused
          }
        }
      });
    }
    _unfocus() {
      let {
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: unfocused
          }
        },
        Label: {
          smooth: {
            color: labelUnfocused
          }
        }
      });
    }
    static get width() {
      return 80;
    }
    static get height() {
      return 80;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Keyboard$2 extends lng$1.Component {
    static _template() {
      return {
        Keys: {
          w: w => w
        }
      };
    }
    _construct() {
      this._input = '';
      this._inputField = undefined;
      this._maxCharacters = 56;
      this.navigationWrapAround = false;
      this._snapToRow = false;
      this.resetFocus();
    }
    resetFocus() {
      this._columnIndex = 0;
      this._rowIndex = 0;
      this._previousKey = null;
    }
    _setup() {
      this._keys = this.tag('Keys');
      this._update();
    }
    _update() {
      const {
        layouts,
        buttonTypes = {},
        styling = {}
      } = this._config;
      if (!this._layout || this._layout && layouts[this._layout] === undefined) {
        console.error("Configured layout \"".concat(this._layout, "\" does not exist. Picking first available: \"").concat(Object.keys(layouts)[0], "\""));
        this._layout = Object.keys(layouts)[0];
      }
      const {
        horizontalSpacing = 0,
        verticalSpacing = 0,
        align = 'left'
      } = styling;
      let rowPosition = 0;
      const isEvent = /^[A-Z][A-Za-z0-9]{1}/;
      const hasLabel = /\:/;
      if (buttonTypes.default === undefined) {
        buttonTypes.default = Key$1;
      }
      this._keys.children = layouts[this._layout].map((row, rowIndex) => {
        const {
          x = 0,
          margin = 0,
          marginRight,
          marginLeft,
          marginTop,
          marginBottom,
          spacing: rowHorizontalSpacing = horizontalSpacing || 0,
          align: rowAlign = align
        } = styling["Row".concat(rowIndex + 1)] || {};
        let keyPosition = 0;
        let rowHeight = 0;
        const rowKeys = row.map((key, keyIndex) => {
          const origin = key;
          let keyType = buttonTypes.default;
          let action = 'Input';
          let label = key;
          if (isEvent.test(key)) {
            if (hasLabel.test(key)) {
              key = key.split(':');
              label = key[1].toString();
              key = key[0];
            }
            if (buttonTypes[key]) {
              keyType = buttonTypes[key];
              action = key.action || key;
            }
          }
          let keySpacing = keyType && keyType.margin || 0;
          let w = 0;
          let h = 0;
          let marginLeft = 0;
          let marginRight = rowHorizontalSpacing;
          if (keyType.type) {
            keySpacing = keyType.type.margin || keySpacing;
            w = keyType.type.width || w;
            h = keyType.type.height || h;
            marginLeft = keyType.type.marginLeft || marginLeft;
            marginRight = keyType.type.marginRight || marginRight;
          }
          w = keyType.w || w;
          h = keyType.h || h;
          rowHeight = h > rowHeight ? h : rowHeight;
          const currentPosition = keyPosition + marginLeft;
          keyPosition += marginLeft + w + marginRight;
          return {
            ref: "Key-{".concat(keyIndex + 1, "}"),
            type: KeyWrapper,
            keyboard: this,
            x: currentPosition,
            w,
            h,
            key: {
              data: {
                origin,
                key,
                label,
                action
              },
              w,
              h,
              ...keyType
            }
          };
        });
        let rowOffset = x + (marginLeft || margin);
        let rowMount = 0;
        if (this.w && rowAlign === 'center') {
          rowOffset = this.w / 2;
          rowMount = 0.5;
        }
        if (this.w && rowAlign === 'right') {
          rowOffset = this.w - (marginRight || margin);
          rowMount = 1;
        }
        const currentPosition = rowPosition + (marginTop || margin);
        rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
        return {
          ref: "Row-".concat(rowIndex + 1),
          x: rowOffset,
          mountX: rowMount,
          w: keyPosition,
          y: currentPosition,
          children: rowKeys
        };
      });
      this._refocus();
    }
    _getFocused() {
      return this.currentKeyWrapper || this;
    }
    _handleRight() {
      return this.navigate('row', 1);
    }
    _handleLeft() {
      return this.navigate('row', -1);
    }
    _handleUp() {
      return this.navigate('column', -1);
    }
    _handleDown() {
      return this.navigate('column', 1);
    }
    _handleKey(_ref) {
      let {
        key,
        code = 'CustomKey'
      } = _ref;
      if (code === 'Backspace' && this._input.length === 0) {
        return false;
      }
      if (key === ' ') {
        key = 'Space';
      }
      const targetFound = this._findKey(key);
      if (targetFound) {
        this._handleEnter();
      }
      return targetFound;
    }
    _findKey(str) {
      const rows = this._config.layouts[this._layout];
      let i = 0,
        j = 0;
      for (; i < rows.length; i++) {
        for (j = 0; j < rows[i].length; j++) {
          let key = rows[i][j];
          if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
            this._rowIndex = i;
            this._columnIndex = j;
            return true;
          }
        }
      }
      return false;
    }
    _handleEnter() {
      const {
        origin,
        action
      } = this.currentKey.data;
      const event = {
        index: this._input.length,
        key: origin
      };
      if (this._inputField && this._inputField.cursorIndex) {
        event.index = this._inputField.cursorIndex;
      }
      if (action !== 'Input') {
        const split = event.key.split(':');
        const call = "on".concat(split[0]);
        const eventFunction = this[call];
        event.key = split[1];
        if (eventFunction && eventFunction.apply && eventFunction.call) {
          eventFunction.call(this, event);
        }
        this.signal(call, {
          input: this._input,
          keyboard: this,
          ...event
        });
      } else {
        this.addAt(event.key, event.index);
      }
    }
    _changeInput(input) {
      if (input.length > this._maxCharacters) {
        return;
      }
      const eventData = {
        previousInput: this._input,
        input: this._input = input
      };
      if (this._inputField && this._inputField.onInputChanged) {
        this._inputField.onInputChanged(eventData);
      }
      this.signal('onInputChanged', eventData);
    }
    focus(str) {
      this._findKey(str);
    }
    add(str) {
      this._changeInput(this._input + str);
    }
    addAt(str, index) {
      if (index > this._input.length - 1) {
        this.add(str);
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
      }
    }
    remove() {
      this._changeInput(this._input.substring(0, this._input.length - 1));
    }
    removeAt(index) {
      if (index > this._input.length - 1) {
        this.remove();
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
      }
    }
    clear() {
      this._changeInput('');
    }
    layout(key) {
      if (key === this._layout) {
        return;
      }
      this._layout = key;
      if (this.attached) {
        this.resetFocus();
        this._update();
      }
    }
    inputField(component) {
      if (component && component.isComponent) {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = component.input !== undefined ? component.input : '';
        this._inputField = component;
      } else {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = '';
        this._inputField = undefined;
      }
    }
    _findKeyInRow(currentKey, currentRow, targetRow) {
      const currentX = currentRow.x - currentRow.w * currentRow.mountX + currentKey.x;
      const m = targetRow.children.map(key => {
        const keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
        if (keyX <= currentX && (this._snapToRow || currentX < keyX + key.w)) {
          return keyX + key.w - currentX;
        }
        if (keyX >= currentX && (this._snapToRow || keyX < currentX + currentKey.w)) {
          return currentX + currentKey.w - keyX;
        }
        return -1;
      });
      if (!this._snapToRow) {
        let acc = -1;
        let t = -1;
        for (let i = 0; i < m.length; i++) {
          if (m[i] === -1 && acc > -1) {
            break;
          }
          if (m[i] > acc) {
            acc = m[i];
            t = i;
          }
        }
        return t;
      }
      let t = m.indexOf(currentKey.w);
      if (t === -1 && m.length > 0) {
        let acc = this.w;
        for (let i = 0; i < m.length; i++) {
          if (m[i] >= 0) {
            const cutoff = currentX + currentKey.w - currentX - m[i];
            if (cutoff < acc) {
              acc = cutoff;
              t = i;
            }
          }
        }
        if (t === -1) {
          acc = this.w;
          for (let i = 0; i < m.length; i++) {
            if (Math.abs(m[i]) < acc) {
              acc = Math.abs(m[i]);
              t = i;
            }
          }
        }
      }
      return t;
    }
    navigate(direction, shift) {
      const targetIndex = (direction === 'row' ? this._columnIndex : this._rowIndex) + shift;
      const currentRow = this.rows[this._rowIndex];
      if (direction === 'row' && targetIndex > -1 && targetIndex < currentRow.children.length) {
        this._previous = null;
        return this._columnIndex = targetIndex;
      } else if (direction === 'row' && this.navigationWrapAround) {
        this._previous = null;
        let rowLen = currentRow.children.length;
        return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
      }
      if (direction === 'column' && targetIndex > -1 && targetIndex < this.rows.length) {
        const currentRowIndex = this._rowIndex;
        const currentColumnIndex = this._columnIndex;
        if (this._previous && this._previous.row === targetIndex) {
          const tmp = this._previous.column;
          this._previous.column = this._columnIndex;
          this._columnIndex = tmp;
          this._rowIndex = this._previous.row;
        } else {
          const targetRow = this.rows[targetIndex];
          const currentKey = this.currentKeyWrapper;
          const currentRow = this.rows[this._rowIndex];
          let t = this._findKeyInRow(currentKey, currentRow, targetRow);
          if (t > -1) {
            this._rowIndex = targetIndex;
            this._columnIndex = t;
          } // if no next row found and wraparound is on, loop back to first row
          else if (this.navigationWrapAround) {
            t = this._findKeyInRow(currentKey, currentRow, this.rows[0]);
            this._columnIndex = t > -1 ? t : Math.min(this.rows[0].children.length - 1, this._columnIndex);
            return this._rowIndex = 0;
          }
        }
        if (this._rowIndex !== currentRowIndex) {
          this._previous = {
            column: currentColumnIndex,
            row: currentRowIndex
          };
          return this._rowIndex = targetIndex;
        }
      } else if (direction === 'column' && this.navigationWrapAround) {
        this._previous = {
          column: this._columnIndex,
          row: this._rowIndex
        };
        let nrRows = this.rows.length;
        this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
        this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
      }
      return false;
    }
    onSpace(_ref2) {
      let {
        index
      } = _ref2;
      this.addAt(' ', index);
    }
    onBackspace(_ref3) {
      let {
        index
      } = _ref3;
      this.removeAt(index);
    }
    onClear() {
      this.clear();
    }
    onLayout(_ref4) {
      let {
        key
      } = _ref4;
      this.layout(key);
    }
    set config(obj) {
      this._config = obj;
      if (this.active) {
        this._update();
      }
    }
    get config() {
      return this._config;
    }
    set currentInputField(component) {
      this.inputField(component);
    }
    get currentInputField() {
      return this._inputField;
    }
    set currentLayout(str) {
      this.layout(str);
    }
    get currentLayout() {
      return this._layout;
    }
    set maxCharacters(num) {
      this._maxCharacters = num;
    }
    get maxCharacters() {
      return this._maxCharacters;
    }
    set snapToRow(bool) {
      this._snapToRow = bool;
    }
    get snapToRow() {
      return true;
    }
    get rows() {
      return this._keys && this._keys.children;
    }
    get currentKeyWrapper() {
      return this.rows && this.rows[this._rowIndex] && this.rows[this._rowIndex].children[this._columnIndex];
    }
    get currentKey() {
      return this.currentKeyWrapper && this.currentKeyWrapper.key;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class List extends CollectionWrapper {
    plotItems() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        immediate = false
      } = options;
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const ref = "IW-".concat(item.assignedID);
        let mainPos = position;
        crossPos = item[cross] || crossPos;
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        return {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        if (immediate) {
          item.patch({
            x: item.assignedX,
            y: item.assignedY
          });
        } else {
          item.patch({
            smooth: {
              x: item.assignedX,
              y: item.assignedY
            }
          });
        }
      });
      this._resizeWrapper(crossSize);
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      wrapper.children.forEach(item => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        crossPos = item[cross] || crossPos;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const mainPos = position;
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: 0,
          [main]: mainPos,
          [cross]: crossPos,
          ...sizes
        });
      });
      this._resizeWrapper(crossSize);
      super.repositionItems();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScrollingLabel extends lng$1.Component {
    static _template() {
      return {
        LabelClipper: {
          w: w => w,
          rtt: true,
          shader: {
            type: lng$1.shaders.FadeOut
          },
          LabelWrapper: {
            Label: {
              renderOffscreen: true
            },
            LabelCopy: {
              renderOffscreen: true
            }
          }
        }
      };
    }
    _construct() {
      this._autoStart = true;
      this._scrollAnimation = false;
      this._fade = 30;
      this._spacing = 30;
      this._label = {};
      this._align = 'left';
      this._animationSettings = {
        delay: 0.7,
        repeat: -1,
        stopMethod: 'immediate'
      };
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this._update(label);
        this._updateAnimation(label);
        if (this._autoStart) {
          this.start();
        }
      });
    }
    _update() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      const renderWidth = label.renderWidth;
      const noScroll = renderWidth <= this.renderWidth;
      let labelPos = 0;
      if (noScroll && this._align !== 'left') {
        labelPos = (this.renderWidth - renderWidth) * ScrollingLabel.ALIGN[this._align];
      }
      this.tag('LabelClipper').patch({
        h: label.renderHeight,
        shader: {
          right: noScroll ? 0 : this._fade
        },
        LabelWrapper: {
          x: 0,
          Label: {
            x: labelPos
          },
          LabelCopy: {
            x: renderWidth + this._spacing
          }
        }
      });
    }
    _updateAnimation() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
      }
      if (label.renderWidth > this.renderWidth) {
        if (!this._animationSettings.duration) {
          this._animationSettings.duration = label.renderWidth / 50;
        }
        this._scrollAnimation = this.animation({
          ...this._animationSettings,
          actions: [{
            t: 'LabelWrapper',
            p: 'x',
            v: {
              sm: 0,
              0: 0,
              1.0: -(label.renderWidth + this._spacing)
            }
          }, {
            t: 'LabelClipper',
            p: 'shader.left',
            v: {
              0: 0,
              0.2: this._fade,
              0.8: this._fade,
              1.0: 0
            }
          }]
        });
      }
    }
    start() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').patch({
          text: this._label
        });
        this._scrollAnimation.start();
      }
    }
    stop() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').text = '';
      }
    }
    set label(obj) {
      if (typeof obj === 'string') {
        obj = {
          text: obj
        };
      }
      this._label = {
        ...this._label,
        ...obj
      };
      this.tag('Label').patch({
        text: obj
      });
    }
    get label() {
      return this.tag('Label');
    }
    set align(pos) {
      this._align = pos;
    }
    get align() {
      return this._align;
    }
    set autoStart(bool) {
      this._autoStart = bool;
    }
    get autoStart() {
      return this._autoStart;
    }
    set repeat(num) {
      this.animationSettings = {
        repeat: num
      };
    }
    get repeat() {
      return this._animationSettings.repeat;
    }
    set delay(num) {
      this.animationSettings = {
        delay: num
      };
    }
    get delay() {
      return this._animationSettings.delay;
    }
    set duration(num) {
      this.animationSettings = {
        duration: num
      };
    }
    get duration() {
      return this._animationSettings.duration;
    }
    set animationSettings(obj) {
      this._animationSettings = {
        ...this._animationSettings,
        ...obj
      };
      if (this._scrollAnimation) {
        this._updateAnimation();
      }
    }
    get animationSettings() {
      return this._animationSettings;
    }
  }
  ScrollingLabel.ALIGN = {
    left: 0,
    center: 0.5,
    right: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const calcCarouselNavigation = (dir, current, min, max) => {
    let target = current + dir;
    if (target < min) {
      target = max;
    }
    if (target > max) {
      target = min;
    }
    return target;
  };
  class Stepper extends lng$1.Component {
    static _template() {
      return {
        h: 80,
        w: 574,
        Focus: {
          alpha: 0,
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          x: 30,
          y: h => h * 0.5,
          mountY: 0.5,
          text: {
            text: '',
            fontSize: 22
          }
        },
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 30;
      this._max = 100;
      this._min = 0;
      this._value = 50;
      this._options = undefined;
      this._label = 'label';
      this._focusAnimation = null;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding', 'max', 'min', 'focusAnimation']);
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'Label',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this._update();
    }
    _navigate(dir) {
      this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
      const event = {
        value: this._value
      };
      if (this._options) {
        event.options = this._options;
      }
      this.fireAncestors('$onValueChanged', event);
      this.signal('onValueChanged', event);
    }
    _handleLeft() {
      this._navigate(-1);
    }
    _handleRight() {
      this._navigate(1);
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set label(str) {
      this._label = str;
      if (this.active) {
        this.tag('Label').text.text = str;
      }
    }
    get label() {
      return this._label;
    }
    set value(str) {
      this._value = str;
      if (this.active) {
        this.tag('Value').text.text = this.optionValue || this._value;
      }
    }
    get value() {
      return this._value;
    }
    get optionValue() {
      return this._options && this._options[this._value] && this._options[this._value].label || undefined;
    }
    set options(arr) {
      const refactor = arr.map(option => {
        if (typeof option === 'string') {
          return {
            label: option
          };
        }
        return option;
      });
      this._value = 0;
      this._options = refactor;
      this._max = refactor.length - 1;
      this._update();
    }
    get options() {
      return this._options;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ArrowStepper extends Stepper {
    static _template() {
      return {
        ...super._template(),
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          ArrowLeft: {
            y: h => h * 0.5,
            mountY: 0.5
          },
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          },
          ArrowRight: {
            y: h => h * 0.5,
            x: w => w,
            mountY: 0.5,
            mountX: 1
          }
        }
      };
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          ArrowLeft: {
            color: this._labelColor
          },
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          },
          ArrowRight: {
            color: this._labelColor
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'ValueWrapper.ArrowLeft',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.ArrowRight',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      const arrowLeft = this.tag('ArrowLeft');
      const arrowRight = this.tag('ArrowRight');
      if (!(arrowLeft.src !== undefined && arrowLeft.text !== null)) {
        arrowLeft.text = {
          text: '\u25c0',
          fontSize: 18
        };
      }
      if (!(arrowRight.src !== undefined && arrowRight.text !== null)) {
        arrowRight.text = {
          text: '\u25b6',
          fontSize: 18
        };
      }
      this._update();
    }
  }

  class ColorShift extends lng$1.Component {
    static _template() {
      return {
        w: 574,
        h: 240,
        List: {
          type: List,
          w: w => w,
          h: h => h,
          forceLoad: true,
          spacing: 0,
          direction: 'column'
        }
      };
    }
    _construct() {
      this._autoColorShift = true;
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._options = [{
        type: 'neutral',
        label: 'normal'
      }, {
        type: 'protanopia',
        label: 'Protanopia'
      }, {
        type: 'deuteranopia',
        label: 'Deuteranopia'
      }, {
        type: 'tritanopia',
        label: 'Tritanopia'
      }, {
        type: 'monochromacy',
        label: 'Achromatopsia'
      }];
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'options', 'autoColorShift']);
    }
    _getFocused() {
      return this.tag('List');
    }
    _shiftColors() {
      if (this._autoColorShift && this.application && this.application.colorshift) {
        this.application.colorshift(this._settings.correction, this._settings);
      }
    }
    $onValueChanged() {
      const listItems = this.tag('List').items;
      const correction = listItems[0];
      this._settings = {
        correction: correction.options[correction.value].type,
        brightness: listItems[1].value,
        contrast: listItems[2].value,
        gamma: listItems[3].value
      };
      if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
        const steppers = listItems.slice(1);
        steppers.forEach(stepper => {
          stepper.value = 50;
        });
      }
      this._currentCorrection = this._settings.correction;
      this._shiftColors();
      this.signal('onColorShift', this._settings);
    }
    _update() {
      const list = this.tag('List');
      const steppers = ['Brightness', 'Contrast', 'Gamma'];
      const options = this._options;
      const settings = this._settings;
      const colors = {
        focusColor: this._focusColor,
        labelColor: this._labelColor,
        labelColorFocused: this._labelColorFocused
      };
      this._shiftColors();
      const settingItems = steppers.map(stepper => {
        const lowerC = stepper.toLocaleLowerCase();
        return {
          type: this["".concat(lowerC, "Component")],
          label: stepper,
          value: settings[lowerC],
          w: this.finalW,
          h: 80,
          ...colors
        };
      });
      settingItems.unshift({
        type: this.correctionComponent,
        options,
        value: findIndexOfObject(options, settings.correction, 'type'),
        label: 'Color adjustment',
        w: this.finalW,
        h: 80,
        ...colors
      });
      list.clear();
      list.add(settingItems);
    }
    _firstActive() {
      if (!this._settings) {
        this._settings = {
          correction: 'neutral',
          brightness: 50,
          contrast: 50,
          gamma: 50
        };
      }
      this._update();
    }
    set settings(obj) {
      this._settings = obj;
      if (this.active) {
        const listItems = this.tag('List').items;
        listItems[0] = findIndexOfObject(this._options, obj.correction, 'type');
        listItems[1] = obj.brightness || 50;
        listItems[2] = obj.contrast || 50;
        listItems[3] = obj.gamma || 50;
      }
    }
    get settings() {
      return this._settings;
    }
    get correctionTag() {
      return this.tag('List').items[0];
    }
    get brightnessTag() {
      return this.tag('List').items[1];
    }
    get contrastTag() {
      return this.tag('List').items[2];
    }
    get gammaTag() {
      return this.tag('List').items[3];
    }
    get adjustmentTags() {
      return this.tag('List').items;
    }
    set stepperComponent(component) {
      this._stepperComponent = component;
    }
    get stepperComponent() {
      return this._stepperComponent || ArrowStepper;
    }
    set correctionComponent(component) {
      this._correctionComponent = component;
    }
    get correctionComponent() {
      return this._correctionComponent || this.stepperComponent;
    }
    set brightnessComponent(component) {
      this._brightnessComponent = component;
    }
    get brightnessComponent() {
      return this._brightnessComponent || this.stepperComponent;
    }
    set contrastComponent(component) {
      this._contrastComponent = component;
    }
    get contrastComponent() {
      return this._contrastComponent || this.stepperComponent;
    }
    set gammaComponent(component) {
      this._gammaComponent = component;
    }
    get gammaComponent() {
      return this._gammaComponent || this.stepperComponent;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CarouselItem extends lng$1.Component {
    static _template() {
      return {
        Focus: {
          alpha: 0,
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          w: 120,
          h: 50,
          rect: true,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 25
          }
        },
        Label: {
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          renderOffscreen: true,
          text: {
            text: '',
            fontSize: 22
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 40;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding']);
    }
    set label(str) {
      this.tag('Label').text.text = str;
      this._label = str;
    }
    get label() {
      return this._label;
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this.patch({
          w: label.renderWidth,
          Focus: {
            w: label.renderWidth + this._padding * 2
          }
        });
        if (this.collectionWrapper) {
          this.collectionWrapper.reposition();
        }
      });
    }
    _focus() {
      this.patch({
        Focus: {
          smooth: {
            alpha: 1
          }
        },
        Label: {
          smooth: {
            color: this._labelColorFocused
          }
        }
      });
    }
    _unfocus(target) {
      if (target.isCarouselItem === true) {
        this.patch({
          Focus: {
            smooth: {
              alpha: 0
            }
          },
          Label: {
            smooth: {
              color: this._labelColor
            }
          }
        });
      }
    }
    _firstActive() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          color: this._labelColor
        }
      });
      if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
        this._focus();
      }
    }
    get isCarouselItem() {
      return true;
    }
    static get width() {
      return 120;
    }
    static get height() {
      return 50;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ProgressBar$1 extends lng$1.Component {
    static _template() {
      return {
        w: 300,
        h: 10,
        Background: {
          w: w => w,
          h: h => h,
          rect: true,
          rtt: true,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 5
          },
          Progress: {
            h: h => h,
            w: 10,
            rect: true,
            shader: {
              type: lng$1.shaders.RoundedRectangle,
              radius: 0
            }
          }
        }
      };
    }
    _construct() {
      this._progressColor = 0xff009245;
      this._progressColorFocused = undefined;
      this._backgroundColor = 0xff9d9d9d;
      this._backgroundColorFocused = undefined;
      this._backgroundRadius = 5;
      this._progressRadius = 0;
      this.value = 0.5;
      defineProperties(this, ['progressColor', 'backgroundColor', 'progressColorFocused', 'backgroundColorFocused']);
    }
    progress(p) {
      if (p > 1) {
        p = p / 100;
      }
      this._value = p;
      this.tag('Progress').w = this.w * p;
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Background',
          p: 'color',
          v: {
            0: this._backgroundColor,
            1: this._backgroundColorFocused || this._backgroundColor
          }
        }, {
          t: 'Background.Progress',
          p: 'color',
          v: {
            0: this._progressColor,
            1: this._progressColorFocused || this._progressColor
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this.patch({
        Background: {
          color: this._backgroundColor,
          shader: {
            radius: this._backgroundRadius
          },
          Progress: {
            color: this._progressColor,
            shader: {
              radius: this._progressRadius
            }
          }
        }
      });
      this.progress(this._value);
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set value(p) {
      this._value = p;
      if (this.active) {
        this.progress(p);
      }
    }
    get value() {
      return this._value;
    }
    set backgroundRadius(num) {
      this._backgroundRadius = num;
      if (this.active) {
        this.tag('Background').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    set progressRadius(num) {
      this._progressRadius = num;
      if (this.active) {
        this.tag('Progress').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    get backgroundTag() {
      return this.tag('Background');
    }
    get progressTag() {
      return this.tag('Progress');
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTDeviceInfo {
    getaudio() {
      return new Promise((resolve, reject) => {
        Device.audio().then(supportedAudioProfiles => {
          console.log(supportedAudioProfiles);
          resolve(supportedAudioProfiles);
        }).catch(err => {
          console.error('firebolt getaudio error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get audio error " + err, false, null);
          reject(err);
        });
      });
    }
    getdistributor() {
      return new Promise((resolve, reject) => {
        Device.distributor().then(distributorId => {
          console.log(distributorId);
          resolve(distributorId);
        }).catch(err => {
          console.error('firebolt getdistributor error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get distributor error " + err, false, null);
          reject(err);
        });
      });
    }
    gethdcp() {
      return new Promise((resolve, reject) => {
        Device.hdcp().then(supportedHdcpProfiles => {
          console.log(supportedHdcpProfiles);
          resolve(supportedHdcpProfiles);
        }).catch(err => {
          console.error('firebolt gethdcp error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get hdcp error " + err, false, null);
          reject(err);
        });
      });
    }
    gethdr() {
      return new Promise((resolve, reject) => {
        Device.hdr().then(supportedHdrProfiles => {
          console.log(supportedHdrProfiles);
          resolve(supportedHdrProfiles);
        }).catch(err => {
          console.error('firebolt gethdr error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get hdr error " + err, false, null);
          reject(err);
        });
      });
    }
    getid() {
      return new Promise((resolve, reject) => {
        Device.id().then(id => {
          console.log(id);
          resolve(id);
        }).catch(err => {
          console.error('firebolt getid error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get Id error " + err, false, null);
          reject(err);
        });
      });
    }
    getmake() {
      return new Promise((resolve, reject) => {
        Device.make().then(make => {
          console.log(make);
          resolve(make);
        }).catch(err => {
          console.error('firebolt getmake error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get make error " + err, false, null);
          reject(err);
        });
      });
    }
    getmodel() {
      return new Promise((resolve, reject) => {
        Device.model().then(model => {
          console.log(model);
          resolve(model);
        }).catch(err => {
          console.error('firebolt getmodel error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get model error " + err, false, null);
          reject(err);
        });
      });
    }
    getname() {
      return new Promise((resolve, reject) => {
        Device.name().then(value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt getname error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get name error " + err, false, null);
          reject(err);
        });
      });
    }
    getnetwork() {
      return new Promise((resolve, reject) => {
        Device.network().then(networkInfo => {
          console.log(networkInfo);
          resolve(networkInfo);
        }).catch(err => {
          console.error('firebolt getnetwork error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get network error " + err, false, null);
          reject(err);
        });
      });
    }
    getplatform() {
      return new Promise((resolve, reject) => {
        Device.platform().then(platformId => {
          console.log(platformId);
          resolve(platformId);
        }).catch(err => {
          console.error('firebolt getplatform error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get platform error " + err, false, null);
          reject(err);
        });
      });
    }
    getscreenresolution() {
      return new Promise((resolve, reject) => {
        Device.screenResolution().then(screenResolution => {
          console.log(screenResolution);
          resolve(screenResolution);
        }).catch(err => {
          console.error('firebolt getscreenresolution error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get screen resolution error " + err, false, null);
          reject(err);
        });
      });
    }
    getsku() {
      return new Promise((resolve, reject) => {
        Device.sku().then(sku => {
          console.log(sku);
          resolve(sku);
        }).catch(err => {
          console.error('firebolt getsku error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get sku error " + err, false, null);
          reject(err);
        });
      });
    }
    gettype() {
      return new Promise((resolve, reject) => {
        Device.type().then(deviceType => {
          console.log(deviceType);
          resolve(deviceType);
        }).catch(err => {
          console.error('firebolt gettype error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get type error " + err, false, null);
          reject(err);
        });
      });
    }
    getuid() {
      return new Promise((resolve, reject) => {
        Device.uid().then(uniqueId => {
          console.log(uniqueId);
          resolve(uniqueId);
        }).catch(err => {
          console.error('firebolt getuid error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get uid error" + err, false, null);
          reject(err);
        });
      });
    }
    getversion() {
      return new Promise((resolve, reject) => {
        Device.version().then(versions => {
          console.log(versions);
          resolve(versions);
        }).catch(err => {
          console.error('firebolt getversion error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginErrorr", "firebolt get version error " + err, false, null);
          reject(err);
        });
      });
    }
    getvideoresolution() {
      return new Promise((resolve, reject) => {
        Device.videoResolution().then(videoResolution => {
          console.log(videoResolution);
          resolve(videoResolution);
        }).catch(err => {
          console.error('firebolt getvideoresolution error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt get video resolution error " + err, false, null);
          reject(err);
        });
      });
    }
    listen(event) {
      return new Promise((resolve, reject) => {
        Device.listen(event, value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt listen error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt listen error " + err, false, null);
          reject(err);
        });
      });
    }
    once(event) {
      return new Promise((resolve, reject) => {
        Device.once(event, value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt listen error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "FireboltDevicePluginError", "firebolt once error " + err, false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTLifecycle {
    constructor() {
      this._events = new Map();
      Lifecycle.listen('background', value => {
        console.log('Fireboltapi background ' + JSON.stringify(value));
        if (this._events.has('background')) {
          this._events.get('background')(value);
        }
      });
      Lifecycle.listen('foreground', value => {
        console.log('Fireboltapi foreground ' + JSON.stringify(value));
        if (this._events.has('foreground')) {
          this._events.get('foreground')(value);
        }
      });
      Lifecycle.listen('inactive', value => {
        console.log('Fireboltapi inactive ' + JSON.stringify(value));
        if (this._events.has('inactive')) {
          this._events.get('inactive')(value);
        }
      });
      Lifecycle.listen('suspended', value => {
        console.log('Fireboltapi suspended ' + JSON.stringify(value));
        if (this._events.has('suspended')) {
          this._events.get('suspended')(value);
        }
      });
      Lifecycle.listen('unloading', value => {
        console.log('Fireboltapi unloading ' + JSON.stringify(value));
        if (this._events.has('unloading')) {
          this._events.get('unloading')(value);
        }
      });
    }
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    close() {
      return new Promise((resolve, reject) => {
        Lifecycle.close("remoteButton").then(success => {
          console.log(success);
          resolve(success);
        }).catch(err => {
          console.error('firebolt Lifecycle.close error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LifecycleError", err, false, null);
          reject(err);
        });
      });
    }
    finished() {
      return new Promise((resolve, reject) => {
        Lifecycle.finished().then(results => {
          console.log(results);
          resolve(results);
        }).catch(err => {
          console.error('firebolt Lifecycle.finished error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LifecycleError", err, false, null);
          reject(err);
        });
      });
    }
    ready() {
      return new Promise((resolve, reject) => {
        Lifecycle.ready().then(result => {
          console.log("getting result");
          console.log(result);
          resolve(result);
        }).catch(err => {
          console.error('firebolt Lifecycle.ready error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LifecycleError", err, false, null);
          reject(err);
        });
      });
    }
    state() {
      return new Promise(resolve => {
        const state = Lifecycle.state();
        console.log(state);
        resolve(state);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTDiscovery {
    launch(appId, intent) {
      return new Promise((resolve, reject) => {
        Discovery.launch(appId, intent).then(success => {
          console.log("Discovery.launch result:" + success);
          resolve(success);
        }).catch(err => {
          console.error('firebolt Discovery.launch error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "fireboltDiscoveryError", "Discovery.launch error" + err, false, null);
          reject(err);
        });
      });
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const win$2 = typeof window !== 'undefined' ? window : {};

  let listener;
  const setMockListener = (func) => {
    listener = func;
  };

  let mock$1;
  const pending = [];
  const eventMap = {};

  let callback;
  let testHarness;

  if (win$2.__firebolt && win$2.__firebolt.testHarness) {
    testHarness = win$2.__firebolt.testHarness;
  }

  function send(message) {
    console.debug('Sending message to transport: ' + message);
    let json = JSON.parse(message);

    // handle bulk sends
    if (Array.isArray(json)) {
      json.forEach((j) => send(JSON.stringify(j)));
      return
    }

    let [module, method] = json.method.split('.');

    if (testHarness && testHarness.onSend) {
      testHarness.onSend(module, method, json.params, json.id);
    }

    // store the ID of the first listen for each event
    if (method.match(/^on[A-Z]/)) {
      if (json.params.listen) {
        eventMap[json.id] =
          module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3);
      } else {
        Object.keys(eventMap).forEach((key) => {
          if (
            eventMap[key] ===
            module.toLowerCase() +
              '.' +
              method[2].toLowerCase() +
              method.substr(3)
          ) {
            delete eventMap[key];
          }
        });
      }
    }

    if (mock$1) handle(json);
    else pending.push(json);
  }

  function handle(json) {
    let result;
    try {
      result = getResult(json.method, json.params);
    } catch (error) {
      setTimeout(() =>
        callback(
          JSON.stringify({
            jsonrpc: '2.0',
            error: {
              code: -32602,
              message:
                'Invalid params (this is a mock error from the mock transport layer)',
            },
            id: json.id,
          }),
        ),
      );
    }

    setTimeout(() =>
      callback(
        JSON.stringify({
          jsonrpc: '2.0',
          result: result,
          id: json.id,
        }),
      ),
    );
  }

  function receive(_callback) {
    callback = _callback;

    if (testHarness && typeof testHarness.initialize === 'function') {
      testHarness.initialize({
        emit: event$1,
        listen: function (...args) {
          listener(...args);
        },
      });
    }
  }

  function event$1(module, event, value) {
    const listener = Object.entries(eventMap).find(
      ([k, v]) =>
        v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase(),
    );
    if (listener) {
      let message = JSON.stringify({
        jsonrpc: '2.0',
        id: parseInt(listener[0]),
        result: value,
      });
      callback(message);
    }
  }

  function dotGrab$1(obj = {}, key) {
    const keys = key.split('.');
    let ref = obj;
    for (let i = 0; i < keys.length; i++) {
      ref = (Object.entries(ref).find(
        ([k, v]) => k.toLowerCase() === keys[i].toLowerCase(),
      ) || [null, {}])[1];
    }
    return ref
  }

  function getResult(method, params) {
    let api = dotGrab$1(mock$1, method);

    if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
      api = {
        event: method,
        listening: true,
      };
    }

    if (typeof api === 'function') {
      return params == null ? api() : api(params)
    } else return api
  }

  function setMockResponses(m) {
    mock$1 = m;

    pending.forEach((json) => handle(json));
    pending.length = 0;
  }

  var mock$2 = {
    send: send,
    receive: receive,
    event: event$1,
  };

  function router (params, callbackOrValue, contextParameterCount) {
    const numArgs = params ? Object.values(params).length : 0;

    if (numArgs === contextParameterCount && callbackOrValue === undefined) {
      // getter
      return 'getter'
    } else if (
      numArgs === contextParameterCount &&
      typeof callbackOrValue === 'function'
    ) {
      // subscribe
      return 'subscriber'
    } else if (numArgs === 0 && typeof callbackOrValue === 'function') {
      // for x-subscriber-type: global
      return 'subscriber'
    } else if (
      numArgs === contextParameterCount &&
      callbackOrValue !== undefined
    ) {
      // setter
      return 'setter'
    }

    return null
  }

  const mocks = {};

  function mock(module, method, params, value, contextParameterCount, def) {
    const type = router(params, value, contextParameterCount);
    const hash = contextParameterCount
      ? '.' +
        Object.keys(params)
          .filter((key) => key !== 'value')
          .map((key) => params[key])
          .join('.')
      : '';
    const key = `${module}.${method}${hash}`;

    if (type === 'getter') {
      const value = mocks.hasOwnProperty(key) ? mocks[key] : def;
      return value
    } else if (type === 'subscriber') ; else if (type === 'setter') {
      mocks[key] = value;
      mock$2.event(module, `${method}Changed`, { value });
      return null
    }
  }

  var MockProps = {
    mock: mock,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Localization = {
    locality: function (params) {
      return MockProps.mock(
        'Localization',
        'locality',
        params,
        undefined,
        0,
        'Philadelphia',
      )
    },
    postalCode: function (params) {
      return MockProps.mock(
        'Localization',
        'postalCode',
        params,
        undefined,
        0,
        '19103',
      )
    },
    countryCode: function (params) {
      return MockProps.mock(
        'Localization',
        'countryCode',
        params,
        undefined,
        0,
        'US',
      )
    },
    language: function (params) {
      return MockProps.mock(
        'Localization',
        'language',
        params,
        undefined,
        0,
        'en',
      )
    },
    preferredAudioLanguages: function (params) {
      return MockProps.mock(
        'Localization',
        'preferredAudioLanguages',
        params,
        undefined,
        0,
        ['spa', 'eng'],
      )
    },
    locale: function (params) {
      return MockProps.mock(
        'Localization',
        'locale',
        params,
        undefined,
        0,
        'en-US',
      )
    },
    additionalInfo: {},
    addAdditionalInfo: null,
    removeAdditionalInfo: null,
    timeZone: function (params) {
      return MockProps.mock(
        'Localization',
        'timeZone',
        params,
        undefined,
        0,
        'America/New_York',
      )
    },
    setLocality: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'locality',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setPostalCode: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'postalCode',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setCountryCode: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'countryCode',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setLanguage: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'language',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setPreferredAudioLanguages: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'preferredAudioLanguages',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setLocale: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'locale',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setTimeZone: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Localization',
        'timeZone',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Metrics = {
    event: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Wifi = {
    scan: {
      list: [
        { ssid: 'DND', security: 'wpa2Psk', signalStrength: -70, frequency: 2.4 },
        {
          ssid: 'Fortnite',
          security: 'WPA2_ENTERPRISE_AES',
          signalStrength: -70,
          frequency: 5,
        },
        {
          ssid: 'Guardian',
          security: 'none',
          signalStrength: -70,
          frequency: 2.4,
        },
      ],
    },
    connect: {
      ssid: 'DND',
      security: 'wpa2Psk',
      signalStrength: -70,
      frequency: 2.4,
    },
    disconnect: null,
    wps: {
      ssid: 'DND',
      security: 'wpa2Psk',
      signalStrength: -70,
      frequency: 2.4,
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _ClosedCaptions = {
    enabled: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'enabled',
        params,
        undefined,
        0,
        true,
      )
    },
    fontFamily: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'fontFamily',
        params,
        undefined,
        0,
        'monospaced_sanserif',
      )
    },
    fontSize: function (params) {
      return MockProps.mock('ClosedCaptions', 'fontSize', params, undefined, 0, 1)
    },
    fontColor: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'fontColor',
        params,
        undefined,
        0,
        '#ffffff',
      )
    },
    fontEdge: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'fontEdge',
        params,
        undefined,
        0,
        'none',
      )
    },
    fontEdgeColor: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'fontEdgeColor',
        params,
        undefined,
        0,
        '#000000',
      )
    },
    fontOpacity: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'fontOpacity',
        params,
        undefined,
        0,
        99,
      )
    },
    backgroundColor: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'backgroundColor',
        params,
        undefined,
        0,
        '#000000',
      )
    },
    backgroundOpacity: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'backgroundOpacity',
        params,
        undefined,
        0,
        99,
      )
    },
    textAlign: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'textAlign',
        params,
        undefined,
        0,
        'center',
      )
    },
    textAlignVertical: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'textAlignVertical',
        params,
        undefined,
        0,
        'middle',
      )
    },
    windowColor: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'windowColor',
        params,
        undefined,
        0,
        '#000000',
      )
    },
    windowOpacity: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'windowOpacity',
        params,
        undefined,
        0,
        99,
      )
    },
    preferredLanguages: function (params) {
      return MockProps.mock(
        'ClosedCaptions',
        'preferredLanguages',
        params,
        undefined,
        0,
        ['spa', 'eng'],
      )
    },
    setEnabled: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'enabled',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontFamily: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontFamily',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontSize: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontSize',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontColor: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontColor',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontEdge: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontEdge',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontEdgeColor: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontEdgeColor',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setFontOpacity: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'fontOpacity',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setBackgroundColor: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'backgroundColor',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setBackgroundOpacity: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'backgroundOpacity',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setTextAlign: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'textAlign',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setTextAlignVertical: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'textAlignVertical',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setWindowColor: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'windowColor',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setWindowOpacity: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'windowOpacity',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setPreferredLanguages: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'ClosedCaptions',
        'preferredLanguages',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _AudioDescriptions = {
    enabled: function (params) {
      return MockProps.mock(
        'AudioDescriptions',
        'enabled',
        params,
        undefined,
        0,
        true,
      )
    },
    setEnabled: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'AudioDescriptions',
        'enabled',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _VoiceGuidance = {
    enabled: function (params) {
      return MockProps.mock(
        'VoiceGuidance',
        'enabled',
        params,
        undefined,
        0,
        true,
      )
    },
    speed: function (params) {
      return MockProps.mock('VoiceGuidance', 'speed', params, undefined, 0, 1)
    },
    setEnabled: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'VoiceGuidance',
        'enabled',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setSpeed: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'VoiceGuidance',
        'speed',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Device = {
    name: function (params) {
      return MockProps.mock('Device', 'name', params, undefined, 0, 'Living Room')
    },
    provision: null,
    setName: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock('Device', 'name', params, callbackOrValue, 0, null)
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _UserGrants = {
    app: [
      {
        app: { id: 'certapp', title: 'Firebolt Certification' },
        state: 'granted',
        capability: 'xrn:firebolt:capability:data:app-usage',
        role: 'use',
        lifespan: 'seconds',
        expires: '2022-12-14T20:20:39+00:00',
      },
      {
        app: { id: 'certapp', title: 'Firebolt Certification' },
        state: 'denied',
        capability: 'xrn:firebolt:capability:localization:postal-code',
        role: 'use',
        lifespan: 'appActive',
      },
    ],
    device: [
      {
        state: 'granted',
        capability: 'xrn:firebolt:capability:localization:postal-code',
        role: 'use',
        lifespan: 'powerActive',
      },
    ],
    capability: [
      {
        state: 'granted',
        capability: 'xrn:firebolt:capability:localization:postal-code',
        role: 'use',
        lifespan: 'powerActive',
      },
    ],
    grant: null,
    deny: null,
    clear: null,
    request: [
      {
        app: { id: 'certapp', title: 'Certification App' },
        state: 'granted',
        capability: 'xrn:firebolt:capability:localization:postal-code',
        role: 'use',
        lifespan: 'powerActive',
      },
    ],
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Privacy = {
    allowResumePoints: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowResumePoints',
        params,
        undefined,
        0,
        true,
      )
    },
    allowUnentitledResumePoints: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowUnentitledResumePoints',
        params,
        undefined,
        0,
        true,
      )
    },
    allowWatchHistory: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowWatchHistory',
        params,
        undefined,
        0,
        true,
      )
    },
    allowProductAnalytics: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowProductAnalytics',
        params,
        undefined,
        0,
        true,
      )
    },
    allowPersonalization: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowPersonalization',
        params,
        undefined,
        0,
        true,
      )
    },
    allowUnentitledPersonalization: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowUnentitledPersonalization',
        params,
        undefined,
        0,
        true,
      )
    },
    allowRemoteDiagnostics: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowRemoteDiagnostics',
        params,
        undefined,
        0,
        true,
      )
    },
    allowPrimaryContentAdTargeting: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowPrimaryContentAdTargeting',
        params,
        undefined,
        0,
        true,
      )
    },
    allowPrimaryBrowseAdTargeting: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowPrimaryBrowseAdTargeting',
        params,
        undefined,
        0,
        true,
      )
    },
    allowAppContentAdTargeting: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowAppContentAdTargeting',
        params,
        undefined,
        0,
        true,
      )
    },
    allowACRCollection: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowACRCollection',
        params,
        undefined,
        0,
        true,
      )
    },
    allowCameraAnalytics: function (params) {
      return MockProps.mock(
        'Privacy',
        'allowCameraAnalytics',
        params,
        undefined,
        0,
        true,
      )
    },
    settings: {
      allowACRCollection: true,
      allowResumePoints: false,
      allowAppContentAdTargeting: false,
      allowCameraAnalytics: true,
      allowPersonalization: true,
      allowPrimaryBrowseAdTargeting: false,
      allowPrimaryContentAdTargeting: false,
      allowProductAnalytics: true,
      allowRemoteDiagnostics: true,
      allowUnentitledPersonalization: true,
      allowUnentitledResumePoints: false,
      allowWatchHistory: true,
    },
    setAllowResumePoints: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowResumePoints',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowUnentitledResumePoints: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowUnentitledResumePoints',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowWatchHistory: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowWatchHistory',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowProductAnalytics: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowProductAnalytics',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowPersonalization: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowPersonalization',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowUnentitledPersonalization: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowUnentitledPersonalization',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowRemoteDiagnostics: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowRemoteDiagnostics',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowPrimaryContentAdTargeting: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowPrimaryContentAdTargeting',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowPrimaryBrowseAdTargeting: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowPrimaryBrowseAdTargeting',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowAppContentAdTargeting: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowAppContentAdTargeting',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowACRCollection: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowACRCollection',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAllowCameraAnalytics: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Privacy',
        'allowCameraAnalytics',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Advertising = {
    skipRestriction: function (params) {
      return MockProps.mock(
        'Advertising',
        'skipRestriction',
        params,
        undefined,
        0,
        'none',
      )
    },
    resetIdentifier: null,
    setSkipRestriction: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'Advertising',
        'skipRestriction',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Account = {
    session: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Keyboard = {
    standardFocus: null,
    passwordFocus: null,
    emailFocus: null,
    standardResponse: null,
    standardError: null,
    passwordResponse: null,
    passwordError: null,
    emailResponse: null,
    emailError: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _AcknowledgeChallenge = {
    challengeFocus: null,
    challengeResponse: null,
    challengeError: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _PinChallenge = {
    challengeFocus: null,
    challengeResponse: null,
    challengeError: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecureStorage = {
    setForApp: null,
    removeForApp: null,
    clearForApp: null,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Discovery = {};

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _HDMIInput = {
    ports: [
      {
        port: 'HDMI1',
        connected: true,
        signal: 'stable',
        arcCapable: true,
        arcConnected: true,
        edidVersion: '2.0',
        autoLowLatencyModeCapable: true,
        autoLowLatencyModeSignalled: true,
      },
    ],
    port: {
      port: 'HDMI1',
      connected: true,
      signal: 'stable',
      arcCapable: true,
      arcConnected: true,
      edidVersion: '2.0',
      autoLowLatencyModeCapable: true,
      autoLowLatencyModeSignalled: true,
    },
    open: null,
    close: null,
    lowLatencyMode: function (params) {
      return MockProps.mock(
        'HDMIInput',
        'lowLatencyMode',
        params,
        undefined,
        0,
        true,
      )
    },
    autoLowLatencyModeCapable: function (params) {
      return MockProps.mock(
        'HDMIInput',
        'autoLowLatencyModeCapable',
        params,
        undefined,
        1,
        true,
      )
    },
    edidVersion: function (params) {
      return MockProps.mock(
        'HDMIInput',
        'edidVersion',
        params,
        undefined,
        1,
        '2.0',
      )
    },
    setLowLatencyMode: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'HDMIInput',
        'lowLatencyMode',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setAutoLowLatencyModeCapable: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'HDMIInput',
        'autoLowLatencyModeCapable',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
    setEdidVersion: function (params) {
      const callbackOrValue = params.value;
      delete params.value;
      return MockProps.mock(
        'HDMIInput',
        'edidVersion',
        params,
        callbackOrValue,
        0,
        null,
      )
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Queue {
    constructor() {
      this._callback = null;
      this._queue = [];
    }

    send(json) {
      this._queue.push(json);
    }

    receive(_callback) {
      this._callback = _callback;
    }

    flush(transport) {
      transport.receive(this._callback);
      this._queue.forEach((item) => transport.send(item));
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const settings = {};
  const subscribers = {};

  const initSettings = (appSettings, platformSettings) => {
    settings['app'] = appSettings;
    settings['platform'] = {
      logLevel: 'WARN',
      ...platformSettings,
    };
    settings['user'] = {};
  };

  const publish = (key, value) => {
    subscribers[key] &&
      subscribers[key].forEach((subscriber) => subscriber(value));
  };

  const dotGrab = (obj = {}, key) => {
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object'
      ? Object.keys(obj).length
        ? obj
        : undefined
      : obj
  };

  var Settings = {
    get(type, key, fallback = undefined) {
      const val = dotGrab(settings[type], key);
      return val !== undefined ? val : fallback
    },
    has(type, key) {
      return !!this.get(type, key)
    },
    set(key, value) {
      settings['user'][key] = value;
      publish(key, value);
    },
    subscribe(key, callback) {
      subscribers[key] = subscribers[key] || [];
      subscribers[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index =
          subscribers[key] && subscribers[key].findIndex((cb) => cb === callback);
        index > -1 && subscribers[key].splice(index, 1);
      } else {
        if (key in subscribers) {
          subscribers[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers)) {
        delete subscribers[key];
      }
    },
    setLogLevel(logLevel) {
      settings.platform.logLevel = logLevel;
    },
    getLogLevel() {
      return settings.platform.logLevel
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const win$1 = typeof window !== 'undefined' ? window : {};

  class LegacyTransport {
    constructor(bridge) {
      this.bridge = bridge;
    }

    send(msg) {
      this.bridge.JSMessageChanged(msg, () => {});
    }

    receive(callback) {
      win$1.$badger = win$1.$badger || {};
      /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
      const badgerCallback = win$1.$badger.callback
        ? win$1.$badger.callback.bind(win$1.$badger)
        : null;
      const badgerEvent = win$1.$badger.event
        ? win$1.$badger.event.bind(win$1.$badger)
        : null;
      win$1.$badger.callback = (pid, success, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerCallback) {
          badgerCallback(pid, success, json);
        }
      };
      win$1.$badger.event = (handlerId, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerEvent) {
          badgerEvent(handlerId, json);
        }
      };
    }

    static isLegacy(transport) {
      return (
        LegacyTransport.isXREProxy(transport) ||
        (transport.send === undefined && transport.JSMessageChanged)
      )
    }

    static isXREProxy(transport) {
      /** Set top boxes running XRE has a "Proxy" transport
       * native object that intercepts ALL method calls, so we
       * cannot test for transport.send existence because it will return true
       * even though it actually is not supported. Check if some obscure method
       * name like "proxyObjectTest" is defined. If it is then we know we are using a
       * Proxy object and thus is legacy transport.
       */
      return transport.proxyObjectTest !== undefined
    }
  }

  const MAX_QUEUED_MESSAGES = 100;

  class WebsocketTransport {
    constructor(endpoint) {
      this._endpoint = endpoint;
      this._ws = null;
      this._connected = false;
      this._queue = [];
      this._callbacks = [];
    }

    send(msg) {
      this._connect();

      if (this._connected) {
        this._ws.send(msg);
      } else {
        if (this._queue.length < MAX_QUEUED_MESSAGES) {
          this._queue.push(msg);
        }
      }
    }

    receive(callback) {
      if (!callback) return
      this._connect();
      this._callbacks.push(callback);
    }

    _notifyCallbacks(message) {
      for (let i = 0; i < this._callbacks.length; i++) {
        setTimeout(() => this._callbacks[i](message), 1);
      }
    }

    _connect() {
      if (this._ws) return
      this._ws = new WebSocket(this._endpoint, ['jsonrpc']);
      this._ws.addEventListener('message', (message) => {
        this._notifyCallbacks(message.data);
      });
      this._ws.addEventListener('error', (message) => {});
      this._ws.addEventListener('close', (message) => {
        this._ws = null;
        this._connected = false;
      });
      this._ws.addEventListener('open', (message) => {
        this._connected = true;
        for (let i = 0; i < this._queue.length; i++) {
          this._ws.send(this._queue[i]);
        }
        this._queue = [];
      });
    }
  }

  /*
  methods = Map<string, {
      x-this-param: 'accessory',
      x-additional-params: ['timeout'],
      x-method: 'Accessory.pair'
  }>
  */

  function transform(result, transforms) {
    if (!transforms || !transforms.methods) {
      return result
    }

    const { methods } = transforms;
    const transformed = JSON.parse(JSON.stringify(result));

    Object.keys(methods).forEach((key) => {
      const method_info = methods[key];
      const rpc_method = method_info['x-method'];
      const [module, method] = rpc_method.split('.');
      const params = {};
      params[method_info['x-this-param']] = transformed;
      transformed[key] = (...args) => {
        // copy the args into the correct RPC param names
        for (var i = 0; i < args.length; i++) {
          params[method_info['x-additional-params'][i]] = args[i];
        }
        return Transport.send(module.toLowerCase(), method, params)
      };
    });
    return transformed
  }

  var Results = {
    transform,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const LEGACY_TRANSPORT_SERVICE_NAME = 'com.comcast.BridgeObject_1';
  let moduleInstance = null;

  const isEventSuccess = (x) =>
    x && typeof x.event === 'string' && typeof x.listening === 'boolean';

  const win = typeof window !== 'undefined' ? window : {};

  class Transport {
    constructor() {
      this._promises = [];
      this._transport = null;
      this._id = 1;
      this._eventEmitters = [];
      this._eventIds = [];
      this._queue = new Queue();
      this._deprecated = {};
      this.isMock = false;
    }

    static addEventEmitter(emitter) {
      Transport.get()._eventEmitters.push(emitter);
    }

    static registerDeprecatedMethod(module, method, alternative) {
      Transport.get()._deprecated[
        module.toLowerCase() + '.' + method.toLowerCase()
      ] = {
        alternative: alternative || '',
      };
    }

    _endpoint() {
      if (win.__firebolt && win.__firebolt.endpoint) {
        return win.__firebolt.endpoint
      }
      return null
    }

    constructTransportLayer() {
      let transport;
      const endpoint = this._endpoint();
      if (
        endpoint &&
        (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))
      ) {
        transport = new WebsocketTransport(endpoint);
        transport.receive(this.receiveHandler.bind(this));
      } else if (
        typeof win.ServiceManager !== 'undefined' &&
        win.ServiceManager &&
        win.ServiceManager.version
      ) {
        // Wire up the queue
        transport = this._queue;
        // get the default bridge service, and flush the queue
        win.ServiceManager.getServiceForJavaScript(
          LEGACY_TRANSPORT_SERVICE_NAME,
          (service) => {
            if (LegacyTransport.isLegacy(service)) {
              transport = new LegacyTransport(service);
            } else {
              transport = service;
            }
            this.setTransportLayer(transport);
          },
        );
      } else {
        this.isMock = true;
        transport = mock$2;
        transport.receive(this.receiveHandler.bind(this));
      }
      return transport
    }

    setTransportLayer(tl) {
      this._transport = tl;
      this._queue.flush(tl);
    }

    static send(module, method, params, transforms) {
      /** Transport singleton across all SDKs to keep single id map */
      return Transport.get()._send(module, method, params, transforms)
    }

    static listen(module, method, params, transforms) {
      return Transport.get()._sendAndGetId(module, method, params, transforms)
    }

    _send(module, method, params, transforms) {
      if (Array.isArray(module) && !method && !params) {
        return this._batch(module)
      } else {
        return this._sendAndGetId(module, method, params, transforms).promise
      }
    }

    _sendAndGetId(module, method, params, transforms) {
      const { promise, json, id } = this._processRequest(
        module,
        method,
        params,
        transforms,
      );
      const msg = JSON.stringify(json);
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return { id, promise }
    }

    _batch(requests) {
      const results = [];
      const json = [];

      requests.forEach(({ module, method, params, transforms }) => {
        const result = this._processRequest(module, method, params, transforms);
        results.push({
          promise: result.promise,
          id: result.id,
        });
        json.push(result.json);
      });

      const msg = JSON.stringify(json);
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return results
    }

    _processRequest(module, method, params, transforms) {
      const p = this._addPromiseToQueue(module, method, params, transforms);
      const json = this._createRequestJSON(module, method, params);

      const result = {
        promise: p,
        json: json,
        id: this._id,
      };

      this._id++;

      return result
    }

    _createRequestJSON(module, method, params) {
      return {
        jsonrpc: '2.0',
        method: module.toLowerCase() + '.' + method,
        params: params,
        id: this._id,
      }
    }

    _addPromiseToQueue(module, method, params, transforms) {
      return new Promise((resolve, reject) => {
        this._promises[this._id] = {};
        this._promises[this._id].promise = this;
        this._promises[this._id].resolve = resolve;
        this._promises[this._id].reject = reject;
        this._promises[this._id].transforms = transforms;

        const deprecated =
          this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()];
        if (deprecated) {
          console.warn(
            `WARNING: ${module}.${method}() is deprecated. ` +
              deprecated.alternative,
          );
        }

        // store the ID of the first listen for each event
        // TODO: what about wild cards?
        if (method.match(/^on[A-Z]/)) {
          if (params.listen) {
            this._eventIds.push(this._id);
          } else {
            this._eventIds = this._eventIds.filter((id) => id !== this._id);
          }
        }
      })
    }

    /**
     * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
     * @returns {Transport}
     */
    static get() {
      /** Set up singleton and initialize it */
      win.__firebolt = win.__firebolt || {};
      if (win.__firebolt.transport == null && moduleInstance == null) {
        const transport = new Transport();
        transport.init();
        if (transport.isMock) {
          /** We should use the mock transport built with the SDK, not a global */
          moduleInstance = transport;
        } else {
          win.__firebolt = win.__firebolt || {};
          win.__firebolt.transport = transport;
        }
        win.__firebolt.setTransportLayer =
          transport.setTransportLayer.bind(transport);
      }
      return win.__firebolt.transport ? win.__firebolt.transport : moduleInstance
    }

    receiveHandler(message) {
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Received message from transport: ' + message);
      }
      const json = JSON.parse(message);
      const p = this._promises[json.id];

      if (p) {
        if (json.error) p.reject(json.error);
        else {
          // Do any module-specific transforms on the result
          let result = json.result;

          if (p.transforms) {
            if (Array.isArray(json.result)) {
              result = result.map((x) => Results.transform(x, p.transforms));
            } else {
              result = Results.transform(result, p.transforms);
            }
          }

          p.resolve(result);
        }
        delete this._promises[json.id];
      }

      // event responses need to be emitted, even after the listen call is resolved
      if (this._eventIds.includes(json.id) && !isEventSuccess(json.result)) {
        this._eventEmitters.forEach((emit) => {
          emit(json.id, json.result);
        });
      }
    }

    init() {
      initSettings({}, { log: true });
      this._queue.receive(this.receiveHandler.bind(this));
      if (win.__firebolt) {
        if (win.__firebolt.mockTransportLayer === true) {
          this.isMock = true;
          this.setTransportLayer(mock$2);
        } else if (win.__firebolt.getTransportLayer) {
          this.setTransportLayer(win.__firebolt.getTransportLayer());
        }
      }
      if (this._transport == null) {
        this._transport = this.constructTransportLayer();
      }
    }
  }
  win.__firebolt = win.__firebolt || {};
  win.__firebolt.setTransportLayer = (transport) => {
    Transport.get().setTransportLayer(transport);
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let listenerId = 0;

  // holds two maps of ${module}.${event} => listenerId, e.g. callback method id
  // note that one callback can listen to multiple events, e.g. 'discovery.*'
  // internal is only available via a private export that we use to ensure our modules know about
  // events before the apps using the SDK (otherwise state errors can happen)
  const listeners = {
    internal: {},
    external: {},

    // Several convenience functions below for checking both internal & external lists w/ one operation

    // gets a merge list of ids for a single event key
    get: (key) => {
      return Object.assign(
        Object.assign({}, listeners.internal[key]),
        listeners.external[key],
      )
    },
    // adds a callback/id to a key on the external list only
    set: (key, id, value) => {
      listeners.external[key] = listeners.external[key] || {};
      listeners.external[key][id] = value;
    },
    // adds a callback/id to a key on the internal list only
    setInternal: (key, id, value) => {
      listeners.internal[key] = listeners.internal[key] || {};
      listeners.internal[key][id] = value;
    },
    // finds the key for an id in either list (it can only be in one)
    find: (id) => {
      let key
      ;[listeners.internal, listeners.external].find((group) => {
        key = Object.keys(group).find((key) => group[key][id]);
        if (key) return true
      });
      return key
    },
    // removes an id from either list
    remove: (id) => {
  [listeners.internal, listeners.external].forEach((group) => {
        Object.keys(group).forEach((key) => {
          if (group[key] && group[key][id]) {
            delete group[key][id];
            if (Object.values(group[key]).length === 0) {
              delete group[key];
            }
          }
        });
      });
    },
    // removes a key from both lists if _internal is true, otherwise only the external list
    removeKey: (key, _internal = false) => {
      _internal && listeners.internal[key] && delete listeners.internal[key];
      listeners.external[key] && delete listeners.external[key];
    },
    // gives a list of all keys
    keys: () => {
      return Array.from(
        new Set(
          Object.keys(listeners.internal).concat(Object.keys(listeners.external)),
        ),
      )
    },
    // counts how many listeners are in a key across both lists
    count: (key) => {
      return Object.values(listeners.get(key)).length
    },
  };

  // holds a map of RPC Ids => Context Key, e.g. the RPC id of an onEvent call mapped to the corresponding context parameters key for that RPC call
  const keys = {};

  // holds a map of ${module}.${event} => Transport.send calls (only called once per event)
  // note that the keys here MUST NOT contain wild cards
  const oncers = [];
  const validEvents = {};
  const validContext = {};

  let transportInitialized = false;

  const emit = (id, value) => {
    callCallbacks(listeners.internal[keys[id]], [value]);
    callCallbacks(listeners.external[keys[id]], [value]);
  };

  const registerEvents = (module, events) => {
    validEvents[module.toLowerCase()] = events.concat();
  };

  const registerEventContext = (module, event, context) => {
    validContext[module.toLowerCase()] = validContext[module.toLowerCase()] || {};
    validContext[module.toLowerCase()][event] = context.concat();
  };

  const callCallbacks = (cbs, args) => {
    cbs &&
      Object.keys(cbs).forEach((listenerId) => {
        let callback = cbs[listenerId];
        if (oncers.indexOf(parseInt(listenerId)) >= 0) {
          oncers.splice(oncers.indexOf(parseInt(listenerId)), 1);
          delete cbs[listenerId];
        }
        callback.apply(null, args);
      });
  };

  const doListen = function (
    module,
    event,
    callback,
    context,
    once,
    internal = false,
  ) {
    init();

    if (typeof callback !== 'function') {
      return Promise.reject('No valid callback function provided.')
    } else {
      if (module === '*') {
        return Promise.reject('No valid module name provided')
      }

      const wildcard = event === '*';
      const events = wildcard ? validEvents[module] : [event]; // explodes wildcards into an array
      const promises = [];
      const hasContext = Object.values(context).length > 0;
      const contextKey = Object.keys(context)
        .sort()
        .map((key) => key + '=' + JSON.stringify(context[key]))
        .join('&');

      listenerId++;

      if (once) {
        oncers.push(listenerId);
      }

      events.forEach((event) => {
        const key = module + '.' + event + (hasContext ? `.${contextKey}` : '');

        if (Object.values(listeners.get(key)).length === 0) {
          const args = Object.assign({ listen: true }, context);
          const { id, promise } = Transport.listen(
            module,
            'on' + event[0].toUpperCase() + event.substring(1),
            args,
          );
          keys[id] = key;
          promises.push(promise);
        }

        const setter = internal ? listeners.setInternal : listeners.set;

        if (wildcard) {
          setter(key, '' + listenerId, (value) => callback(event, value));
        } else {
          setter(key, '' + listenerId, callback);
        }
      });

      let resolve, reject;
      let p = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });

      if (promises.length) {
        Promise.all(promises)
          .then((responses) => {
            resolve(listenerId);
          })
          .catch((error) => {
            // Promise.all rejects if at least one promise rejects... we don't want that behavior here
            // TODO: Do something better than fail silently
            if (event === '*') {
              resolve(listenerId);
            } else {
              reject(error);
            }
          });
      } else {
        resolve(listenerId);
      }

      return p
    }
  };

  const getListenArgs = function (...args) {
    const callback = args.pop();
    const [module, event, context] = getClearArgs(...args);

    return [module, event, callback, context]
  };

  const getClearArgs = function (...args) {
    const module = (args.shift() || '*').toLowerCase();
    const event = args.shift() || '*';
    const context = {};

    for (let i = 0; args.length; i++) {
      context[validContext[module][event][i]] = args.shift();
    }

    return [module, event, context]
  };

  const once$1 = function (...args) {
    const [module, event, callback, context] = getListenArgs(...args);
    return doListen(module, event, callback, context, true)
  };

  const listen$1 = function (...args) {
    const [module, event, callback, context] = getListenArgs(...args);
    return doListen(module, event, callback, context, false)
  };

  const clear$1 = function (...args) {
    if (args && args.length && typeof args[0] === 'number') {
      return doClear(args[0])
    } else if (args && args.length && typeof args[1] === 'number') {
      return doClear(args[1])
    } else {
      const [moduleOrId, event, context] = getClearArgs(...args);
      return doClear(moduleOrId, event, context)
    }
  };

  const unsubscribe = (key, context) => {
    const [module, event] = key.split('.').slice(0, 2);
    const args = Object.assign({ listen: false }, context);
    Transport.send(module, 'on' + event[0].toUpperCase() + event.substr(1), args);
  };

  // TODO: clear needs to go through Transport Layer
  const doClear = function (moduleOrId = false, event = false, context) {
    if (event === '*') {
      event = false;
    }

    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString();
      const key = listeners.find(searchId);

      if (key) {
        listeners.remove(searchId);
        if (listeners.count(key) === 0) {
          unsubscribe(key);
        }
        return true
      }
      return false
    } else {
      if (!moduleOrId && !event) {
        listeners.keys().forEach((key) => {
          listeners.removeKey(key);
          unsubscribe(key);
        });
      } else if (!event) {
        listeners.keys().forEach((key) => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            listeners.removeKey(key);
            unsubscribe(key);
          }
        });
      } else {
        const hasContext = Object.values(context).length > 0;
        const contextKey = Object.keys(context)
          .sort()
          .map((key) => key + '=' + JSON.stringify(context[key]))
          .join('&');
        const key =
          moduleOrId + '.' + event + (hasContext ? `.${contextKey}` : '');

        listeners.removeKey(key);
        unsubscribe(key, context);
      }
    }
  };

  const init = () => {
    if (!transportInitialized) {
      Transport.addEventEmitter(emit);
      setMockListener(listen$1);
      transportInitialized = true;
    }
  };

  var Events = {
    listen: listen$1,
    once: once$1,
    clear: clear$1,
    broadcast(event, value) {
      emit(Object.entries(keys).find(([k, v]) => v === 'app.' + event)[0], value);
    },
  };

  function prop(
    moduleName,
    key,
    params,
    callbackOrValue = undefined,
    immutable,
    readonly,
    contextParameterCount,
  ) {
    const numArgs = Object.values(params).length;
    const type = router(params, callbackOrValue, contextParameterCount);

    if (type === 'getter') {
      return Transport.send(moduleName, key, params)
    } else if (type === 'subscriber') {
      // subscriber
      if (immutable) {
        throw new Error('Cannot subscribe to an immutable property')
      }
      return Events.listen(
        moduleName,
        key + 'Changed',
        ...Object.values(params),
        callbackOrValue,
      )
    } else if (type === 'setter') {
      // setter
      if (immutable) {
        throw new Error('Cannot set a value to an immutable property')
      }
      if (readonly) {
        throw new Error('Cannot set a value to a readonly property')
      }
      return Transport.send(
        moduleName,
        'set' + key[0].toUpperCase() + key.substring(1),
        Object.assign(
          {
            value: callbackOrValue,
          },
          params,
        ),
      )
    } else if (numArgs < contextParameterCount) {
      throw new Error(
        'Cannot get a value without all required context parameters.',
      )
    } else {
      throw new Error('Property accessed with unexpected number of parameters.')
    }
  }

  var Prop = {
    prop: prop,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Localization', [
    'countryCodeChanged',
    'languageChanged',
    'localeChanged',
    'localityChanged',
    'postalCodeChanged',
    'preferredAudioLanguagesChanged',
    'timeZoneChanged',
  ]);

  Transport.registerDeprecatedMethod(
    'Localization',
    'language',
    'Use Localization.locale instead.',
  );
  Transport.registerDeprecatedMethod(
    'Localization',
    'onLanguageChanged',
    'Use language instead.',
  );
  Transport.registerDeprecatedMethod(
    'Localization',
    'setLanguage',
    'Use Localization.locale instead.',
  );

  // onCountryCodeChanged is accessed via listen('countryCodeChanged, ...)

  // onLanguageChanged is accessed via listen('languageChanged, ...)

  // onLocaleChanged is accessed via listen('localeChanged, ...)

  // onLocalityChanged is accessed via listen('localityChanged, ...)

  // onPostalCodeChanged is accessed via listen('postalCodeChanged, ...)

  // onPreferredAudioLanguagesChanged is accessed via listen('preferredAudioLanguagesChanged, ...)

  // onTimeZoneChanged is accessed via listen('timeZoneChanged, ...)

  // Methods

  function addAdditionalInfo(key, value) {
    const transforms = null;

    return Transport.send(
      'Localization',
      'addAdditionalInfo',
      { key, value },
      transforms,
    )
  }

  function additionalInfo() {
    const transforms = null;

    return Transport.send('Localization', 'additionalInfo', {}, transforms)
  }
  function clear(...args) {
    return Events.clear('Localization', ...args)
  }

  function countryCode() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'countryCode',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }
  function language() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'language',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }
  function listen(...args) {
    return Events.listen('Localization', ...args)
  }

  function locale() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'locale',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }
  function locality() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'locality',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }
  function once(...args) {
    return Events.once('Localization', ...args)
  }

  function postalCode() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'postalCode',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }
  function preferredAudioLanguages() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'preferredAudioLanguages',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }

  function removeAdditionalInfo(key) {
    const transforms = null;

    return Transport.send(
      'Localization',
      'removeAdditionalInfo',
      { key },
      transforms,
    )
  }
  function timeZone() {
    let callbackOrValue = arguments[0];
    let params = {};

    // x-subscriber-type: global
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      callbackOrValue = arguments[0];
      params = {};
    }

    return Prop.prop(
      'Localization',
      'timeZone',
      params,
      callbackOrValue,
      false,
      false,
      0,
    )
  }

  var Localization = {
    events: {
      LOCALITY_CHANGED: 'localityChanged',
      POSTAL_CODE_CHANGED: 'postalCodeChanged',
      COUNTRY_CODE_CHANGED: 'countryCodeChanged',
      LANGUAGE_CHANGED: 'languageChanged',
      PREFERRED_AUDIO_LANGUAGES_CHANGED: 'preferredAudioLanguagesChanged',
      LOCALE_CHANGED: 'localeChanged',
      TIME_ZONE_CHANGED: 'timeZoneChanged',
    },

    addAdditionalInfo,
    additionalInfo,
    clear,
    countryCode,
    language,
    listen,
    locale,
    locality,
    once,
    postalCode,
    preferredAudioLanguages,
    removeAdditionalInfo,
    timeZone,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  // Methods

  function event(schema, data) {
    const transforms = null;

    return Transport.send('Metrics', 'event', { schema, data }, transforms)
  }

  var Metrics$2 = {
    event,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('ClosedCaptions', [
    'backgroundColorChanged',
    'backgroundOpacityChanged',
    'enabledChanged',
    'fontColorChanged',
    'fontEdgeChanged',
    'fontEdgeColorChanged',
    'fontFamilyChanged',
    'fontOpacityChanged',
    'fontSizeChanged',
    'preferredLanguagesChanged',
    'textAlignChanged',
    'textAlignVerticalChanged',
    'windowColorChanged',
    'windowOpacityChanged',
  ]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('AudioDescriptions', ['enabledChanged']);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('VoiceGuidance', ['enabledChanged', 'speedChanged']);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Device', ['deviceNameChanged', 'nameChanged']);

  Transport.registerDeprecatedMethod(
    'Device',
    'onDeviceNameChanged',
    'Use Device.name() instead.',
  );

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Privacy', [
    'allowACRCollectionChanged',
    'allowAppContentAdTargetingChanged',
    'allowCameraAnalyticsChanged',
    'allowPersonalizationChanged',
    'allowPrimaryBrowseAdTargetingChanged',
    'allowPrimaryContentAdTargetingChanged',
    'allowProductAnalyticsChanged',
    'allowRemoteDiagnosticsChanged',
    'allowResumePointsChanged',
    'allowUnentitledPersonalizationChanged',
    'allowUnentitledResumePointsChanged',
    'allowWatchHistoryChanged',
  ]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Advertising', ['skipRestrictionChanged']);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const providerInterfaces = {};

  const registerProviderInterface = (capability, module, methods) => {
    if (providerInterfaces[capability]) {
      throw `Capability ${capability} has multiple provider interfaces registered.`
    }

    methods.forEach((m) => (m.name = `${module}.${m.name}`));
    providerInterfaces[capability] = methods.concat();
  };

  const provide$3 = function (capability, provider) {
    const methods = [];
    const iface = providerInterfaces[capability];

    if (provider.constructor.name !== 'Object') {
      methods.push(
        ...Object.getOwnPropertyNames(Object.getPrototypeOf(provider)).filter(
          (item) =>
            typeof provider[item] === 'function' && item !== 'constructor',
        ),
      );
    } else {
      methods.push(
        ...Object.getOwnPropertyNames(provider).filter(
          (item) => typeof provider[item] === 'function',
        ),
      );
    }

    if (!iface) {
      throw 'Ignoring unknown provider capability.'
    }

    // make sure every interfaced method exists in the providers methods list
    const valid = iface.every((method) =>
      methods.find((m) => m === method.name.split('.').pop()),
    );

    if (!valid) {
      throw `Provider that does not fully implement ${capability}:\n\t${iface
      .map((m) => m.name.split('.').pop())
      .join('\n\t')}`
    }

    iface.forEach((imethod) => {
      const parts = imethod.name.split('.');
      const method = parts.pop();
      const module = parts.pop().toLowerCase();
      const defined = !!methods.find((m) => m === method);

      if (!defined) {
        return // returns from this cycle of iface.forEach
      }

      Events.listen(
        module,
        `request${method.charAt(0).toUpperCase() + method.substr(1)}`,
        function (request) {
          const providerCallArgs = [];

          // only pass in parameters object if schema exists
          if (imethod.parameters) {
            providerCallArgs.push(request.parameters);
          } else {
            providerCallArgs.push(null);
          }

          const session = {
            correlationId: () => {
              return request.correlationId
            },
          };

          // only pass in the focus handshake if needed
          if (imethod.focus) {
            session.focus = () => {
              Transport.send(module, `${method}Focus`, {
                correlationId: request.correlationId,
              });
            };
          }

          providerCallArgs.push(session);

          const response = {
            correlationId: request.correlationId,
          };
          let handleError = (error) => {
            response.error = {
              code: error.code || 1000, // todo: should be some reserved code for "Unknown"
              message:
                error.message ||
                `An error occured while calling provided ${method} method.`,
            };

            if (error.data) {
              response.error.data = JSON.parse(JSON.stringify(error.data));
            }

            Transport.send(module, `${method}Error`, response);
          };

          try {
            const result = provider[method].apply(provider, providerCallArgs);

            if (!(result instanceof Promise)) {
              throw `Provider method ${method} did not return a Promise.`
            }

            result
              .then((result) => {
                if (imethod.response) {
                  response.result = result;
                }

                Transport.send(module, `${method}Response`, response);
              })
              .catch((err) => handleError(err));
          } catch (error) {
            handleError(error);
          }
        },
      );
    });
  };

  var ProvideManager = {
    provide: provide$3,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerProviderInterface(
    'xrn:firebolt:capability:input:keyboard',
    'Keyboard',
    [
      { name: 'standard', focus: true, response: true, parameters: true },
      { name: 'password', focus: true, response: true, parameters: true },
      { name: 'email', focus: true, response: true, parameters: true },
    ],
  );

  // Methods
  function provide$2(capability, provider) {
    return ProvideManager.provide(capability, provider)
  }

  var Keyboard$1 = {
    provide: provide$2,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerProviderInterface(
    'xrn:firebolt:capability:usergrant:acknowledgechallenge',
    'AcknowledgeChallenge',
    [{ name: 'challenge', focus: true, response: true, parameters: true }],
  );

  // Methods
  function provide$1(capability, provider) {
    return ProvideManager.provide(capability, provider)
  }

  var AcknowledgeChallenge = {
    provide: provide$1,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerProviderInterface(
    'xrn:firebolt:capability:usergrant:pinchallenge',
    'PinChallenge',
    [{ name: 'challenge', focus: true, response: true, parameters: true }],
  );

  // Methods
  function provide(capability, provider) {
    return ProvideManager.provide(capability, provider)
  }

  var PinChallenge = {
    ResultReason: {
      NO_PIN_REQUIRED: 'noPinRequired',
      NO_PIN_REQUIRED_WINDOW: 'noPinRequiredWindow',
      EXCEEDED_PIN_FAILURES: 'exceededPinFailures',
      CORRECT_PIN: 'correctPin',
      CANCELLED: 'cancelled',
    },

    provide,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Discovery', ['signIn', 'signOut']);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('HDMIInput', [
    'autoLowLatencyModeCapableChanged',
    'autoLowLatencyModeSignalChanged',
    'connectionChanged',
    'edidVersionChanged',
    'lowLatencyModeChanged',
    'signalChanged',
  ]);

  // onAutoLowLatencyModeCapableChanged is accessed via listen('autoLowLatencyModeCapableChanged, ...)

  // onAutoLowLatencyModeSignalChanged is accessed via listen('autoLowLatencyModeSignalChanged, ...)

  // onConnectionChanged is accessed via listen('connectionChanged, ...)

  // onEdidVersionChanged is accessed via listen('edidVersionChanged, ...)

  registerEventContext('HDMIInput', 'edidVersionChanged', ['port']);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  setMockResponses({
    Localization: _Localization,
    Metrics: _Metrics,
    Wifi: _Wifi,
    ClosedCaptions: _ClosedCaptions,
    AudioDescriptions: _AudioDescriptions,
    VoiceGuidance: _VoiceGuidance,
    Device: _Device,
    UserGrants: _UserGrants,
    Privacy: _Privacy,
    Advertising: _Advertising,
    Account: _Account,
    Keyboard: _Keyboard,
    AcknowledgeChallenge: _AcknowledgeChallenge,
    PinChallenge: _PinChallenge,
    SecureStorage: _SecureStorage,
    Discovery: _Discovery,
    HDMIInput: _HDMIInput,
  });

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTLocalization {
    listen(event) {
      return new Promise((resolve, reject) => {
        Localization.listen(event, value => {
          console.log("Firebolt listening to ", JSON.stringify(value));
          resolve(value);
        }).catch(err => {
          console.error('firebolt listen error', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    additionalInfo() {
      return new Promise((resolve, reject) => {
        Localization.additionalInfo().then(info => {
          console.log(info);
          resolve(info);
        }).catch(err => {
          console.error('firebolt Localization.additionalInfo error', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    countryCode() {
      return new Promise((resolve, reject) => {
        Localization.countryCode().then(code => {
          console.log(code);
          resolve(code);
        }).catch(err => {
          console.error('firebolt Localization.countryCode error', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    locality() {
      return new Promise((resolve, reject) => {
        Localization.locality().then(locality => {
          console.log(locality);
        }).catch(err => {
          console.error('firebolt Localization.locality error', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    latlon() {
      return new Promise((resolve, reject) => {
        Localization.latlon().then(latlong => {
          console.log(latlong);
          resolve(latlong);
        }).catch(err => {
          console.error('firebolt Localization.latlon error', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    language() {
      return new Promise((resolve, reject) => {
        Localization.language().then(lang => {
          console.log('Localization.language :' + lang);
          resolve(lang);
        }).catch(err => {
          console.error('firebolt Localization.language error :', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    setlanguage(lang) {
      return new Promise((resolve, reject) => {
        Localization.language(lang).then(lang => {
          console.log('Localization.language :' + lang);
          resolve(lang);
        }).catch(err => {
          console.error('firebolt Localization.language error :', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    setTimeZone(zone) {
      return new Promise((resolve, reject) => {
        Localization.timeZone(zone).then(zone => {
          console.log('set Localization.timeZone :' + zone);
          resolve(zone);
        }).catch(err => {
          console.error('firebolt set Localization.timeZone error :', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
    getTimeZone() {
      return new Promise((resolve, reject) => {
        Localization.timeZone().then(zone => {
          console.log('get Localization.timeZone :' + zone);
          resolve(zone);
        }).catch(err => {
          console.error('firebolt get Localization.timeZone error :', err);
          Metrics$2.error(Metrics$2.ErrorType.OTHER, "LocalizationError", err, false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance$4 = null;
  class FireBoltApi {
    constructor() {
      this.deviceinfo = new FBTDeviceInfo();
      this.lifecycle = new FBTLifecycle();
      this.discovery = new FBTDiscovery();
      this.localization = new FBTLocalization();
    }
    /**
    *
    * @returns {FireBoltApi}
    */
    static get() {
      if (instance$4 == null) {
        instance$4 = new FireBoltApi();
      }
      return instance$4;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for main view component in home UI */
  class MainView extends lng$1.Component {
    /**
     * Function to render various elements in main view.
     */
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('home'));
    }
    static _template() {
      return {
        rect: true,
        color: CONFIG.theme.background,
        w: 1920,
        h: 1080,
        clipping: true,
        MainView: {
          w: 1720,
          h: 1200,
          xIndex: 2,
          y: 270,
          x: 200,
          clipping: false,
          Text0: {
            alpha: 0,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Popular Movies'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          Gracenote: {
            y: 50,
            x: -20,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            type: lng$1.components.ListComponent,
            w: 1745,
            h: 400,
            itemSize: 500,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -1,
            clipping: false
          },
          Inputs: {
            y: 0,
            visible: false,
            //false by default
            Title: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate('Input Select'),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Slider: {
              x: -20,
              y: 37,
              type: lng$1.components.ListComponent,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              w: 1745,
              h: 300,
              itemSize: 288,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          Text1: {
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Featured Content'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          AppList: {
            y: 37,
            x: 0,
            type: List,
            h: 400,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          Text2: {
            // x: 10 + 25,
            y: 395,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Lightning Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          MetroApps: {
            x: -20,
            y: 435,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 300,
            itemSize: 288,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text3: {
            // x: 10 + 25,
            y: 673,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Featured Video on Demand'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          TVShows: {
            x: -20,
            y: 710,
            w: 1745,
            h: 400,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            roll: true,
            itemSize: 277,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text4: {
            // x: 10 + 25,
            y: 938,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Lightning Showcase'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          ShowcaseApps: {
            x: -20,
            y: 978,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text5: {
            alpha: 0,
            // x: 10 + 25,
            y: 1203,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Partner Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          UsbApps: {
            x: -20,
            y: 1243,
            type: lng$1.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          }
        }
      };
    }
    pageTransition() {
      return 'up';
    }
    moveDownContent() {
      let inputSelectOffset = 0;
      if (this.inputSelect) {
        inputSelectOffset = 275;
      }
      this.tag('Text0').alpha = 1;
      this.tag("Inputs").y = 440;
      this.tag('Text1').y = 440 + inputSelectOffset;
      this.tag('AppList').y = 477 + inputSelectOffset;
      this.tag("Text2").y = 705 + inputSelectOffset;
      this.tag("MetroApps").y = 745 + inputSelectOffset;
      this.tag("Text3").y = 980 + inputSelectOffset;
      this.tag("TVShows").y = 1020 + inputSelectOffset;
      this.tag("Text4").y = 1248 + inputSelectOffset;
      this.tag("ShowcaseApps").y = 1288 + inputSelectOffset;
      this.tag("Text5").y = 1516 + inputSelectOffset;
      this.tag("UsbApps").y = 1556 + inputSelectOffset;
    }
    showInputSelect() {
      this.tag("Inputs").visible = true;
      let gracenoteOffset = 0;
      if (!this.gracenote) {
        gracenoteOffset = 440;
      }
      this.tag("Inputs").y = this.gracenote ? 440 : 0;
      this.tag('Text1').y = 440 + 275 - gracenoteOffset;
      this.tag('AppList').y = 477 + 275 - gracenoteOffset;
      this.tag("Text2").y = 705 + 275 - gracenoteOffset;
      this.tag("MetroApps").y = 745 + 275 - gracenoteOffset;
      this.tag("Text3").y = 980 + 275 - gracenoteOffset;
      this.tag("TVShows").y = 1020 + 275 - gracenoteOffset;
      this.tag("Text4").y = 1248 + 275 - gracenoteOffset;
      this.tag("ShowcaseApps").y = 1288 + 275 - gracenoteOffset;
      this.tag("Text5").y = 1516 + 275 - gracenoteOffset;
      this.tag("UsbApps").y = 1556 + 275 - gracenoteOffset;
    }

    /**
     * @param {any} data
     */
    setGracenoteData(data) {
      if (!this.gracenote) {
        this.gracenote = true;
        this.key = data.key;
        this.graceNoteItems = data.data;
        this.appItems = this.currentItems;
      }
    }
    _handleBack() {}
    async _init() {
      this.gracenote = false;
      this.inputSelect = false; //false by default
      this.settingsScreen = false;
      this.indexVal = 0;
      this.usbApi = new UsbApi();
      this.homeApi = new HomeApi();
      this.xcastApi = new XcastApi();
      this.hdmiApi = new HDMIApi();
      this.appApi = new AppApi();
      let thunder = thunderJS$1(CONFIG.thunderConfig);

      // for initially showing/hiding usb icon

      let appItems = this.homeApi.getAppListInfo();
      let data = this.homeApi.getPartnerAppsInfo();
      let metroApps = this.homeApi.getOnlineMetroApps();
      let showcaseApps = this.homeApi.getShowCaseApps();
      await this.homeApi.checkAppCompatability(appItems).then(res => {
        appItems = res;
      });
      let prop_apps = 'applications';
      let prop_displayname = 'displayName';
      let prop_uri = 'uri';
      let prop_apptype = 'applicationType';
      let appdetails = [];
      let appdetails_format = [];
      let usbAppsArr = [];
      try {
        if (data != null && Object.prototype.hasOwnProperty.call(JSON.parse(data), prop_apps)) {
          appdetails = JSON.parse(data).applications;
          for (let i = 0; i < appdetails.length; i++) {
            if (Object.prototype.hasOwnProperty.call(appdetails[i], prop_displayname) && Object.prototype.hasOwnProperty.call(appdetails[i], prop_uri) && Object.prototype.hasOwnProperty.call(appdetails[i], prop_apptype)) {
              usbAppsArr.push(appdetails[i]);
            }
          }
          for (let i = 0; i < appItems.length; i++) {
            appdetails_format.push(appItems[i]);
          }
        } else {
          appdetails_format = appItems;
        }
      } catch (e) {
        appdetails_format = appItems;
        console.log('Query data is not proper: ' + e);
      }
      this.firstRowItems = appdetails_format;
      this.tempRow = JSON.parse(JSON.stringify(this.firstRowItems));
      if (this.firstRowItems[0].uri === 'USB') {
        this.tempRow.shift();
      }
      this.appItems = this.tempRow;
      this.usbApps = usbAppsArr;
      this.hdmiApi.activate().then(() => {
        this.hdmiApi.registerEvent('onDevicesChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onDevicesChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onInputStatusChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onInputStatusChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onSignalChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onSignalChanged ', JSON.stringify(notification));
          if (notification.signalStatus !== 'stableSignal') {
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: Language$1.translate("Input disconnected")
            });
            Router.focusWidget('Fail');
          }
        });
        this.hdmiApi.registerEvent('videoStreamInfoUpdate', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('videoStreamInfoUpdate ', JSON.stringify(notification));
        });
        this.inputSelect = true; //set the inputSelect to true if the device is tv, here considering hdmiApi is only available on tv
        this.appItems = this.tempRow;
        this.hdmiApi.getHDMIDevices().then(res => {
          if (res.length > 0) this.inputItems = res;
        });
      }).catch(err => {
        console.log('HDMIInput Plugin not activated', err);
      });
      //get the available input methods from the api

      // for USB event
      const registerListener = () => {
        let listener;
        listener = thunder.on('org.rdk.UsbAccess', 'onUSBMountChanged', notification => {
          console.log('onUsbMountChanged notification: ', JSON.stringify(notification));
          Storage$1.set('UsbMountedStatus', notification.mounted ? 'mounted' : 'unmounted');
          const currentPage = window.location.href.split('#').slice(-1)[0];
          if (Storage$1.get('UsbMedia') === 'ON') {
            if (notification.mounted) {
              this.appItems = this.firstRowItems;
              this._setState('AppList.0');
            } else if (!notification.mounted) {
              this.appItems = this.tempRow;
              this._setState('AppList.0');
            }
            console.log("app items = ".concat(this.appItems, " ; "));
            if (currentPage === 'menu') {
              //refresh page to hide or show usb icon
              console.log('page refreshed on unplug/plug');
            }
            if (!notification.mounted) {
              //if mounted is false
              if (currentPage === 'usb' || currentPage === 'usb/image' || currentPage === 'usb/player') {
                // hot exit if we are on usb screen or sub screens
                // this.$changeHomeText('Home')
                Router.navigate('menu');
              }
            }
          }
          console.log("usb event successfully registered");
        });
        return listener;
      };
      Network.get()._thunder.on('org.rdk.Network.1', 'onInternetStatusChange', notification => {
        console.log('on InternetStatus Change', JSON.stringify(notification));
        this.refreshSecondRow();
      });
      await this.homeApi.checkAppCompatability(metroApps).then(res => {
        this.metroApps = res;
      });
      await this.homeApi.checkAppCompatability(showcaseApps).then(res => {
        this.showcaseApps = res;
      });
      this.fireAncestors("$mountEventConstructor", registerListener.bind(this));
      this.refreshFirstRow();
      // this._setState('AppList.0')
    }
    _firstActive() {
      if (!Storage$1.get('UsbMedia')) {
        this.usbApi.activate().then(() => {
          Storage$1.set('UsbMedia', 'ON');
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(() => {
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        // deactivate usb Plugin here
        this.usbApi.deactivate().then(() => {
          console.log("disabled the Usb Plugin");
        }).catch(err => {
          console.error("error while disabling the usb plugin = ".concat(err));
        });
      }
      if (this.gracenote) {
        this._setState("Gracenote");
      } else if (this.inputSelect) {
        this._setState("Inputs");
      } else {
        this._setState("AppList.0");
      }
    }
    _focus() {
      this._setState(this.state);
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Mainview Screen timer end - ', new Date().toUTCString());
      this.internetConnectivity = false;
    }
    scroll(val) {
      this.tag('MainView').patch({
        smooth: {
          y: [val, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
    refreshSecondRow() {
      this.metroApps = this.homeApi.getOnlineMetroApps();
    }
    refreshFirstRow() {
      if (Storage$1.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(() => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.appItems = this.tempRow;
      } else {
        Storage$1.set('UsbMedia', 'ON');
        this.usbApi.activate().then(() => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      }
    }

    /**
     * Function to set details of items in gracenote list.
     */
    set graceNoteItems(items) {
      this.moveDownContent();
      this.tag('Gracenote').items = items.map((info, idx) => {
        return {
          w: 480,
          h: 270,
          type: GracenoteItem,
          data: info,
          key: this.key,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 10
        };
      });
      this._setState('Gracenote');
    }
    set inputItems(items) {
      this.showInputSelect();
      this.tag("Inputs.Slider").items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: {
            ...info,
            displayName: "Port ".concat(info.id),
            url: "/images/inputs/HDMI.jpg"
          },
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
      this._setState("Inputs.0");
    }
    set showcaseApps(items) {
      this.tag('ShowcaseApps').items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in app list.
     */
    set appItems(items) {
      this.currentItems = items;
      this.tag('AppList').clear();
      this.tag('AppList').add(items.map((info, idx) => {
        return {
          w: this.gracenote || this.inputSelect ? 268 : 454,
          h: this.gracenote || this.inputSelect ? 151 : 255,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    set metroApps(items) {
      this.tag('MetroApps').items = items.map((info, index) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in tv shows list.
     */
    set tvShowItems(items) {
      this.tag('TVShows').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }
    set usbApps(items) {
      if (items.length > 0) {
        this.tag('Text5').alpha = 1;
      }
      this.tag('UsbApps').items = items.map((info, index) => {
        return {
          w: 257,
          h: 145,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }
    /**
     * Function to set the state in main view.
     */
    index(index) {
      if (index == 0) {
        this._setState('AppList');
      } else if (index == 1) {
        this._setState('MetroApps');
      } else if (index == 2) {
        this._setState('TVShows');
      } else if (index == 3) {
        if (this.tag('UsbApps').length) {
          this._setState('UsbApps');
        } else {
          this._setState('TVShows');
        }
      }
    }
    /**
     * Function to define various states needed for main view.
     */
    static _states() {
      return [class Gracenote extends this {
        $enter() {
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Text0').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text0').text.fontStyle = 'bold';
          if (this.tag('Gracenote').length) {
            return this.tag('Gracenote').element;
          }
        }
        _handleDown() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else {
            this._setState('AppList');
          }
        }
        _handleRight() {
          if (this.tag('Gracenote').length - 1 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setNext();
            return this.tag('Gracenote').element;
          }
        }
        _handleUp() {
          this.widgets.menu.notify('TopPanel');
        }
        _handleLeft() {
          this.tag('Text0').text.fontStyle = 'normal';
          if (0 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setPrevious();
            return this.tag('Gracenote').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleEnter() {
          Router.navigate('menu/details', {
            gracenoteItem: this.tag('Gracenote').element.data,
            key: this.key
          });
        }
      }, class Inputs extends this {
        $enter() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Inputs.Title').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          if (this.tag("Inputs.Slider").length) {
            return this.tag("Inputs.Slider").element;
          }
        }
        _handleDown() {
          this._setState('AppList');
        }
        _handleUp() {
          if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          if (0 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setPrevious();
            return this.tag('Inputs.Slider').element;
          } else {
            this.tag('Inputs.Title').text.fontStyle = 'normal';
            Router.focusWidget('Menu');
          }
        }
        _handleRight() {
          if (this.tag('Inputs.Slider').length - 1 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setNext();
            return this.tag('Inputs.Slider').element;
          }
        }
        _handleEnter() {
          console.log(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data);
          this.hdmiApi.setHDMIInput(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data).then(() => {
            console.log('completed');
            GLOBALS.topmostApp = 'HDMI';
            const currentInput = this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data;
            Storage$1.set("_currentInputMode", {
              id: currentInput.id,
              locator: currentInput.locator
            });
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
          }).catch(err => {
            console.log('failed', err);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: 'Select a different input.'
            });
            Router.focusWidget('Fail');
          });
        }
      }, class AppList extends this {
        $enter() {
          this.indexVal = 0;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-100);
          } else {
            this.scroll(270);
          }
        }
        $exit() {
          this.tag('Text1').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('AppList').length) {
            return this.tag('AppList');
          }
        }
        _handleDown() {
          this._setState('MetroApps');
        }
        _handleUp() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          Router.focusWidget('Menu');
        }
        async _handleEnter() {
          if (Router.isNavigating()) return;
          let applicationType = this.tag('AppList').items[this.tag('AppList').index].data.applicationType;
          let uri = this.tag('AppList').items[this.tag('AppList').index].data.uri;
          let appIdentifier = this.tag('AppList').items[this.tag('AppList').index].data.appIdentifier;
          if (uri === 'USB') {
            this.usbApi.getMountedDevices().then(result => {
              if (result.mounted.length === 1) {
                Router.navigate('usb');
              }
            });
          } else {
            let params = {
              url: uri,
              launchLocation: "mainView",
              appIdentifier: appIdentifier
            };
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", err);
            });
          }
        }
      }, class MetroApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-200);
          } else {
            this.scroll(-100);
          }
          this.indexVal = 1;
        }
        $exit() {
          this.tag('Text2').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('MetroApps').length) {
            return this.tag('MetroApps').element;
          }
        }
        _handleUp() {
          this._setState('AppList');
        }
        _handleDown() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('MetroApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setNext();
            return this.tag('MetroApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setPrevious();
            return this.tag('MetroApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          if (Router.isNavigating()) return;
          let applicationType = this.tag('MetroApps').items[this.tag('MetroApps').index].data.applicationType;
          let appIdentifier = this.tag('MetroApps').items[this.tag('MetroApps').index].data.appIdentifier;
          let params = {
            url: this.tag('MetroApps').items[this.tag('MetroApps').index].data.uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          await Network.get().isConnectedToInternet().then(result => {
            if (result) {
              this.appApi.launchApp(applicationType, params).catch(err => {
                console.log("ApplaunchError: ", JSON.stringify(err), err);
              });
            } else {
              this.widgets.fail.notify({
                title: 'Network State',
                msg: 'Offline'
              });
              Router.focusWidget('Fail');
            }
          }).catch(err => {
            console.log(err);
          });
        }
      }, class TVShows extends this {
        $enter() {
          this.indexVal = 2;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-600);
          } else {
            this.scroll(-400);
          }
        }
        _handleUp() {
          this.scroll(270);
          this._setState('MetroApps');
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('TVShows').length) {
            return this.tag('TVShows').element;
          }
        }
        _handleRight() {
          if (this.tag('TVShows').length - 1 != this.tag('TVShows').index) {
            this.tag('TVShows').setNext();
            return this.tag('TVShows').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('TVShows').index) {
            this.tag('TVShows').setPrevious();
            return this.tag('TVShows').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleDown() {
          // if (this.tag('UsbApps').length) {
          this._setState("ShowcaseApps");
          //}
        }
        async _handleEnter() {
          if (Router.isNavigating()) return;
          try {
            this.internetConnectivity = await Network.get().isConnectedToInternet();
          } catch {
            this.internetConnectivity = false;
          }
          console.log("MainView: internetConnectivity ", JSON.stringify(this.internetConnectivity));
          let displayName = this.tag('TVShows').items[this.tag('TVShows').index].data.displayName;
          if (this.internetConnectivity) {
            if (displayName === "FOG HLS") {
              let params = {
                url: "http://127.0.0.1:9080/tsb?clientId=FOG_AAMP&recordedUrl=https%3A%2F%2Fcph-p2p-msl.akamaized.net%2Fhls%2Flive%2F2000341%2Ftest%2Fmaster.m3u8"
              };
              Router.navigate("player", params);
            } else if (displayName === "FOG DASH") {
              let params = {
                url: "http://127.0.0.1:9080/tsb?clientId=FOG_AAMP&recordedUrl=https%3A%2F%2Flin001-gb-s8-tst-ll.cdn01.skycdp.com%2FSKYNEHD_HD_SUD_SKYUKD_4050_18_0000000000000018163.mpd"
              };
              Router.navigate("player", params);
            } else {
              //this.fireAncestors('$goToPlayer')
              Router.navigate('player');
            }
          }
        }
        $exit() {
          this.tag('Text3').text.fontStyle = 'normal';
        }
      }, class ShowcaseApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-750);
          } else {
            this.scroll(-550);
          }
        }
        $exit() {
          this.tag('Text4').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('ShowcaseApps').length) {
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleUp() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('ShowcaseApps').length - 1 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setNext();
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleDown() {
          if (this.tag('UsbApps').length) {
            this._setState("UsbApps");
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setPrevious();
            return this.tag('ShowcaseApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          if (Router.isNavigating()) return;
          let applicationType = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.applicationType;
          let appIdentifier = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.appIdentifier;
          let appId = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.appId;
          let intent = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.intent;
          let params = {
            url: this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          if (applicationType == "FireboltApp") {
            FireBoltApi.get().discovery.launch(appId, intent).then(res => {
              console.log(res);
              GLOBALS.topmostApp = "FireboltApp";
            });
          } else {
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", JSON.stringify(err), err);
            });
          }
        }
      }, class UsbApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-1000);
          } else {
            this.scroll(-750);
          }
        }
        $exit() {
          this.tag('Text5').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text5').text.fontStyle = 'bold';
          if (this.tag('UsbApps').length) {
            return this.tag('UsbApps').element;
          }
        }
        _handleUp() {
          this._setState('ShowcaseApps');
        }
        _handleRight() {
          if (this.tag('UsbApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('UsbApps').setNext();
            return this.tag('UsbApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text5').text.fontStyle = 'normal';
          if (0 != this.tag('UsbApps').index) {
            this.tag('UsbApps').setPrevious();
            return this.tag('UsbApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          if (Router.isNavigating()) return;
          let applicationType = this.tag('UsbApps').items[this.tag('UsbApps').index].data.applicationType;
          let params = {
            url: this.tag('UsbApps').items[this.tag('UsbApps').index].data.uri,
            launchLocation: "mainView"
          };
          if (applicationType === "CameraApp") {
            let cameraParams = {
              cameraUrl: this.tag('UsbApps').items[this.tag('UsbApps').index].data.uri
            };
            Router.navigate("camera/player", cameraParams);
          } else {
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", JSON.stringify(err), err);
            });
          }
        }
      }, class RightArrow extends this {
        //TODO
      }, class LeftArrow extends this {
        //TODO
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item$1;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen$1 extends lng$1.Component {
    set params(args) {
      if (args.bluetoothItem) {
        this.item(args.bluetoothItem);
      } else {
        Router.navigate('settings/bluetooth');
      }
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    item(item) {
      _item$1 = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Disconnect');
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Connect');
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item$1.connected) {
            // this.tag('Pairing').text = "Connecting to " + _item.name
            //this.fireAncestors('$pressEnter', 'Disconnect')
            Router.navigate('settings/bluetooth', {
              action: 'Disconnect'
            });
          } else {
            // this.tag('Pairing').text = "Disconnecting from " + _item.name
            // this.fireAncestors('$pressEnter', 'Connect')
            Router.navigate('settings/bluetooth', {
              action: 'Connect'
            });
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Unpair')
          Router.navigate('settings/bluetooth', {
            action: 'Unpair'
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Cancel')
          Router.navigate('settings/bluetooth', {
            action: 'Cancel'
          });
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for the item in the Bluetooth screen.
   */
  class BluetoothItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      this.connected = item.connected ? 'Connected' : 'Not Connected';
      this.status = item.paired ? Language$1.translate(this.connected) : Language$1.translate('Not Paired');
      this.tag('Item').patch({
        Left: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.name,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1600 - 200,
          y: 30,
          mountY: 0.5,
          mountX: 1,
          Text: {
            text: {
              text: this.status,
              fontSize: 25,
              fontFace: CONFIG.language.font,
              verticalAlign: "middle"
            }
          }
        }
        //  Debug:{
        //    x: 300,
        //    y:5,
        //    mountY: 0.5,
        //    mountX:1,
        //    Text: { text: { text: `item: ${JSON.stringify(item)}`, fontSize: 15,fontFace:CONFIG.language.font,verticalAlign:"middle" } },
        //  }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 10
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
    // _handleEnter() {
    //   // this.tag("Item").patch(
    //   //   {
    //   //     text: {
    //   //       text: "this works",
    //   //     }
    //   //   }
    //   // )
    //   this.fireAncestors('$connectBluetooth', this.tag('List').element.ref)
    // }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth thunder plugin apis.
   */

  class BluetoothApi {
    constructor() {
      this._events = new Map();
      this._devices = [];
      this._pairedDevices = [];
      this._connectedDevices = [];
      this.btStatus = false;
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
    }

    /**
     * Function to activate the Bluetooth plugin
     */

    btactivate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(() => {
          resolve(true);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Controller Bluetooth activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivateBluetooth() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(() => {
          resolve(true);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Controller Bluetooth deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(() => {
          this.btStatus = true;
          this._thunder.on(this.callsign, 'onDiscoveredDevice', notification => {
            // this.getDiscoveredDevices().then(() => {
            this._events.get('onDiscoveredDevice')(notification);
            // })
          });
          this._thunder.on(this.callsign, 'onStatusChanged', notification => {
            if (notification.newStatus === 'PAIRING_CHANGE') {
              this.getPairedDevices();
            } else if (notification.newStatus === 'CONNECTION_CHANGE') {
              this.getConnectedDevices().then(() => {
                this._events.get('onConnectionChange')(notification);
              });
            } else if (notification.newStatus === 'DISCOVERY_STARTED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryStarted')();
              });
            } else if (notification.newStatus === 'DISCOVERY_COMPLETED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryCompleted')();
              });
            }
          });
          this._thunder.on(this.callsign, 'onPairingRequest', notification => {
            this._events.get('onPairingRequest')(notification);
          });
          this._thunder.on(this.callsign, 'onRequestFailed', notification => {
            this._events.get('onRequestFailed')(notification);
          });
          this._thunder.on(this.callsign, 'onConnectionRequest', notification => {
            this._events.get('onConnectionRequest')(notification);
          });
          resolve('Blutooth activated');
        }).catch(err => {
          console.error('Activation failure', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Controller Bluetooth activate " + JSON.stringify(err), false, null);
          reject('Bluetooth activation failed', err);
        });
      });
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Bluetooth plugin.
     */
    deactivate() {
      this._events = new Map();
    }

    /**
     * Function to disable the Bluetooth stack.
     */
    disable() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Bluetooth', 'disable').then(result => {
          this.btStatus = false;
          resolve(result);
        }).catch(err => {
          console.error("Can't disable : ".concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth disable " + JSON.stringify(err), false, null);
        });
      });
    }

    /**
     * Function to enable the Bluetooth stack.
     */
    enable() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'enable').then(result => {
          resolve(result);
          this.btStatus = true;
        }).catch(err => {
          console.error("Can't enable : ".concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth enable " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function to start scanning for the Bluetooth devices.
     */
    startScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: 10,
          profile: "KEYBOARD,\n                    MOUSE,\n                    JOYSTICK,\n                    HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth startScan " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }
    startScanBluetooth() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: 1000,
          profile: "KEYBOARD,\n          MOUSE,\n          JOYSTICK,\n          HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth startScan " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }

    /**
     * Function to stop scanning for the Bluetooth devices.
     */
    stopScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'stopScan', {}).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth stopScan " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function returns the discovered Bluetooth devices.
     */
    getDiscoveredDevices() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Bluetooth', 'getDiscoveredDevices').then(result => {
          this._devices = result.discoveredDevices;
          resolve(result.discoveredDevices);
        }).catch(err => {
          console.error("Can't get discovered devices : ".concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth getDiscoveredDevices " + JSON.stringify(err), false, null);
        });
      });
    }
    get discoveredDevices() {
      return this._devices;
    }

    /**
     * Function returns the paired Bluetooth devices.
     */
    getPairedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getPairedDevices').then(result => {
          this._pairedDevices = result.pairedDevices;
          resolve(result.pairedDevices);
        }).catch(err => {
          console.error("Can't get paired devices : ".concat(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth getPairedDevices " + JSON.stringify(err), false, null);
          reject(false);
        });
      });
    }
    get pairedDevices() {
      return this._pairedDevices;
    }

    /**
     * Function returns the connected Bluetooth devices.
     */
    getConnectedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getConnectedDevices').then(result => {
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth getConnectedDevices " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }
    get connectedDevices() {
      return this._connectedDevices;
    }

    /**
     *
     * Function to connect a Bluetooth device.
     * @param {number} deviceID Device ID of the Bluetoth client.
     * @param {string} deviceType Device type of the Bluetooth client.
     */
    connect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'connect', {
          deviceID: deviceID,
          deviceType: deviceType,
          connectedProfile: deviceType
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('Connection failed', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth connect " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function to disconnect a Bluetooth device.
     *@param {number} deviceID Device ID of the Bluetoth client.
     *@param {string} deviceType Device type of the Bluetooth client.
     */
    disconnect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'disconnect', {
          deviceID: deviceID,
          deviceType: deviceType
        }).then(result => {
          if (result.success) resolve(true);else reject();
        }).catch(err => {
          console.error('disconnect failed', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth disconnect " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function to unpair a Bluetooth device.
     * @param {number} deviceId
     */
    unpair(deviceId) {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Bluetooth', 'unpair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result.success);else resolve(false);
        }).catch(err => {
          console.error('unpair failed', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth unpair " + JSON.stringify(err), false, null);
          resolve(false);
        });
      });
    }

    /**
     * Function to pair a Bluetooth device.
     * @param {number} deviceId
     */
    pair(deviceId) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'pair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error on pairing', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth pair " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function to respond to client the Bluetooth event.
     * @param {number} deviceID Device ID of the Bluetooth client.
     * @param {string} eventType Name of the event.
     * @param {string} responseValue Response sent to the Bluetooth client.
     */
    respondToEvent(deviceID, eventType, responseValue) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'respondToEvent', {
          deviceID: deviceID,
          eventType: eventType,
          responseValue: responseValue
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error on respondToEvent', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth respondToEvent " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }

    /**
     * Function to get the discoverable name of the Bluetooth plugin.
     */
    getName() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.Bluetooth', 'getName').then(result => {
          resolve(result.name);
        });
      });
    }
    setAudioStream(deviceID) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'setAudioStream', {
          "deviceID": deviceID,
          "audioStreamName": "AUXILIARY"
        }).then(result => {
          // console.log(JSON.stringify(result))
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "BluetoothError", "Error while Thunder Bluetooth setAudioStream " + JSON.stringify(err), false, null);
          reject();
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothConfirmation extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Title: {
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 40,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 0,
          y: 75,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        },
        Pairing: {
          x: 0,
          y: 125,
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        RectangleDefault: {
          x: 0,
          y: 200,
          w: 200,
          mountX: 0.5,
          h: 50,
          rect: true,
          color: CONFIG.theme.hex,
          Ok: {
            x: 100,
            y: 25,
            mount: 0.5,
            text: {
              text: "OK",
              fontFace: CONFIG.language.font,
              fontSize: 22
            }
          }
        },
        BorderBottom: {
          x: 0,
          y: 300,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        }
      };
    }
    set item(item) {
      this.tag('Title').text = item.name;
    }
    _handleEnter() {
      this.fireAncestors('$pressOK');
    }
    _handleBack() {
      this.fireAncestors('$pressOK');
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen$2 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Bluetooth On/Off'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Bluetooth: {
          y: 275,
          x: 200,
          Confirmation: {
            x: 780,
            y: 100,
            type: BluetoothConfirmation,
            visible: false
          },
          PairingScreen: {
            x: 780,
            y: 100,
            type: BluetoothPairingScreen$1,
            zIndex: 100,
            visible: false
          },
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }

    /**
     * @param {{ action: String; }} args
     */
    set params(args) {
      if (args.action) {
        this.pressEnter(args.action);
      }
    }
    _unfocus() {
      this._disable();
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      //this.switch()
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      if (this.scanTimer) {
        Registry.clearInterval(this.scanTimer);
      }
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    showPairingScreen() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    hidePairingScreen() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    showConfirmation() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    hideConfirmation() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.tag('List').rollMax = this._otherList.length * 90;
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('Switch');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Pairing Successful')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Pairing Failed')
            });
            Router.focusWidget('Fail');
          }
          this.hideAvailableDevices();
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            Router.focusWidget('Fail');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Failed to Disconnect')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Disconnected')
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Unpaired')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Unpairing Failed')
            });
            Router.focusWidget('Fail');
          }
        });
      }
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.hidePairingScreen();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class Confirmation extends this {
        $enter() {
          this.showConfirmation();
        }
        _getFocused() {
          return this.tag('Confirmation');
        }
        $pressOK() {
          this._setState('Switch');
          this.hideConfirmation();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          //this.showPairingScreen()
          //this.tag('PairingScreen').item = this._pairedNetworks.tag('List').element._item
          Router.navigate('settings/bluetooth/pairing', {
            bluetoothItem: this._pairedNetworks.tag('List').element._item
          });
          //this._setState('PairingScreen')
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
          //this.tag('Confirmation').item = this._availableNetworks.tag('List').element._item
        }
        _handleBack() {
          this.hideAvailableDevices();
          this._setState('Switch');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class PairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          return this.tag('PairingScreen');
        }
        _getFocused() {
          return this.tag('PairingScreen');
        }
        $exit() {
          this.tag('PairingScreen').visible = false;
          this._enable();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: Language$1.translate('Connected')
              });
              Router.focusWidget('Fail');
            }
          } else {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: Language$1.translate('Disconnected')
              });
              Router.focusWidget('Fail');
            }
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          if (this.widgets.fail) {
            this.widgets.fail.notify({
              title: notification.name,
              msg: notification.newStatus
            });
            Router.focusWidget('Fail');
          }
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Colors
   *
   * Contains global color style information to easily maintain consistency throughout components.
   */

  /**
   * Combines rgb hex string and alpha into argb hexadecimal number
   * @param {string} hex - 6 alphanumeric characters between 0-f
   * @param {number} [alpha] - number between 0-100 (0 is invisible, 100 is opaque)
   */
  function getHexColor$1(hex) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    if (!hex) {
      return 0x00;
    }
    let hexAlpha = Math.round(alpha / 100 * 255).toString(16);
    let str = "0x".concat(hexAlpha).concat(hex);
    return parseInt(Number(str), 10);
  }

  /**
   * Pair color values with color names in the "Neutral" palette
   */
  const COLORS_NEUTRAL = {
    dark1: '000000',
    dark2: '080808',
    dark3: '101010',
    light1: 'FFFFFF',
    light2: 'F5F5F5',
    light3: 'E8E8E8'
  };

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  /**
   * Returns a styles object for use by components
   * @param {Object|function} styles - Object or callback that takes theme as an argument, ultimately the returned value
   * @param {Object} theme - theme to be provided to styles
   */
  var createStyles = (styles, theme) => {
    return typeof styles === 'function' ? styles(theme) : styles;
  };

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Helpers for lng.Tools.getRoundRect
   */
  const RoundRect$1 = {
    /**
     * Returns a value that will render as the given width (w)
     * when passed to lng.Tools.getRoundRect
     * @param {number} w - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both left and right padding
     * @param {number} options.paddingLeft - px value for left padding, overrides options.padding
     * @param {number} options.paddingRight - px value for right padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getWidth(w) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingLeft,
        paddingRight,
        strokeWidth
      } = {
        padding: 0,
        paddingLeft: 0,
        paddingRight: 0,
        strokeWidth: 0,
        ...options
      };
      if (!w) return 0;
      return w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth;
    },
    /**
     * Returns a value that will render as the given height (h)
     * when passed to lng.Tools.getRoundRect
     * @param {number} h - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both bottom and top padding
     * @param {number} options.paddingBottom - px value for bottom padding, overrides options.padding
     * @param {number} options.paddingTop - px value for top padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getHeight(h) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingBottom,
        paddingTop,
        strokeWidth
      } = {
        padding: 0,
        paddingBottom: 0,
        paddingTop: 0,
        strokeWidth: 0,
        ...options
      };
      if (!h) return 0;
      return h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth;
    }
  };

  /**
   * Merges two objects together and returns the duplicate.
   *
   * @param {Object} target - object to be cloned
   * @param {Object} [object] - secondary object to merge into clone
   */
  function clone$1(target, object) {
    const _clone = {
      ...target
    };
    if (!object || target === object) return _clone;
    for (let key in object) {
      const value = object[key];
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        _clone[key] = getMergeValue$1(key, target, object);
      } else {
        _clone[key] = value;
      }
    }
    return _clone;
  }
  function getMergeValue$1(key, target, object) {
    const targetVal = target[key];
    const objectVal = object[key];
    const targetValType = typeof targetVal;
    const objectValType = typeof objectVal;
    if (targetValType !== objectValType || objectValType === 'function' || Array.isArray(objectVal)) {
      return objectVal;
    }
    if (objectVal && objectValType === 'object') {
      return clone$1(targetVal, objectVal);
    }
    return objectVal;
  }

  /**
   * Returns the rendered width of a given text texture
   * @param {Object} text - text texture properties
   * @param {string} text.text - text value
   * @param {string} text.fontStyle - css font-style property
   * @param {(string|number)} text.fontWeight - css font-weight property
   * @param {string} [fontSize=0] - css font-size property (in px)
   * @param {string} [text.fontFamily=sans-serif] - css font-weight property
   * @param {string} text.fontFace - alias for fontFamily
   *
   * @returns {number} text width
   * */
  function measureTextWidth$1() {
    let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily = text.fontFace || 'sans-serif'
    } = text;
    const fontCss = [fontStyle, fontWeight, fontSize ? "".concat(fontSize, "px") : '0', "'".concat(fontFamily, "'")].filter(Boolean).join(' ');
    ctx.font = fontCss;
    const textMetrics = ctx.measureText(text.text || '');
    return Math.round(textMetrics.width);
  }

  /**
   * Returns first argument that is a number. Useful for finding ARGB numbers. Does not convert strings to numbers
   * @param {...*} number - maybe a number
   **/
  function getFirstNumber$1() {
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    return numbers.find(Number.isFinite);
  }

  /**
   * Naively looks for dimensional prop (i.e. w, h, x, y, etc.), first searching for
   * a transition target value then defaulting to the current set value
   * @param {string} prop - property key
   * @param {lng.Component} component - Lightning component to operate against
   */
  function getDimension$1(prop, component) {
    if (!component) return 0;
    const transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    return component[prop];
  }
  const getX = getDimension$1.bind(null, 'x');
  const getY = getDimension$1.bind(null, 'y');
  const getW = component => getDimension$1('w', component) || component.renderWidth;
  const getH = component => getDimension$1('h', component) || component.renderHeight;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const gradientColor = COLORS_NEUTRAL.light2;
  ({
    duration: 0.6,
    actions: [{
      p: 'colorUl',
      v: {
        0: getHexColor$1(gradientColor, 72),
        1: getHexColor$1(gradientColor, 56)
      }
    }, {
      p: 'colorUr',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }, {
      p: 'colorBr',
      v: {
        0: 0x00,
        1: getHexColor$1(gradientColor, 0)
      }
    }, {
      p: 'colorBl',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }]
  });

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing. The function also has a property 'clear' 
   * that is a function which will clear the timer to prevent previously scheduled executions. 
   *
   * @source underscore.js
   * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
   * @param {Function} function to wrap
   * @param {Number} timeout in ms (`100`)
   * @param {Boolean} whether to execute at the beginning (`false`)
   * @api public
   */
  function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    var debounced = function () {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function () {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function () {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }

  // Adds compatibility for ES modules
  debounce.debounce = debounce;
  var debounce_1 = debounce;

  /**
  * Copyright 2020 Comcast Cable Communications Management, LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * SPDX-License-Identifier: Apache-2.0
  */
  function withStyles(Base, styles, theme) {
    const _theme = theme || Base.theme;
    const _styles = Base.styles ? clone$1(Base.styles, createStyles(styles, _theme)) : createStyles(styles, _theme);
    return class extends Base {
      static get name() {
        return Base.name;
      }
      static get styles() {
        return _styles;
      }
      get styles() {
        return _styles;
      }
    };
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Icon extends lng$1.Component {
    static _template() {
      return {
        color: 0xffffffff,
        w: 0,
        h: 0
      };
    }
    get icon() {
      return this._icon;
    }
    set icon(icon) {
      this._icon = icon;
      this._update();
    }
    _init() {
      this._update();
    }
    _update() {
      const {
        icon,
        w,
        h
      } = this;
      const template = getIconTemplate(icon, w, h);
      this.patch(template);
    }
  }
  const [isSvgTag, isSvgURI, isImageURI] = [/^<svg.*<\/svg\>$/, /\.svg$/, /\.(a?png|bmp|gif|ico|cur|jpe?g|pjp(eg)?|jfif|tiff?|webp)$/].map(regex => RegExp.prototype.test.bind(regex));
  function getIconTemplate(icon, w, h) {
    const template = {
      w,
      h
    };
    switch (true) {
      case isSvgTag(icon):
        template.texture = lng$1.Tools.getSvgTexture("data:image/svg+xml,".concat(encodeURIComponent(icon)), w, h);
        break;
      case isSvgURI(icon):
        template.texture = lng$1.Tools.getSvgTexture(icon, w, h);
        break;
      case isImageURI(icon):
        template.src = icon;
        break;
    }
    return template;
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const styles = {
    w: 113,
    //150
    h: 90,
    //40
    radius: 0,
    background: {
      color: 0xffffffff
    },
    // 0xff1f1f1f
    icon: {
      color: 0xffffffff
    },
    text: {
      fontSize: 30,
      fontFace: CONFIG.language.font,
      color: 0xff000000
    },
    padding: 50,
    stroke: {
      color: 0x00,
      weight: 2
    },
    focused: {
      background: {
        color: CONFIG.theme.hex
      },
      text: {
        color: 0xff1f1f1f
      },
      icon: {
        color: 0xff1f1f1f
      }
    }
  };
  class Button extends lng$1.Component {
    static _template() {
      return {
        w: this.styles.w,
        h: this.styles.h,
        radius: this.styles.radius,
        strokeColor: this.styles.stroke.color,
        strokeWeight: this.styles.stroke.weight,
        Content: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2,
          flex: {
            direction: 'row',
            alignContent: 'center',
            alignItems: 'center'
          },
          Icon: {
            type: Icon
          },
          Title: {
            y: 2
          }
        },
        Stroke: {
          zIndex: -1,
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._focused = false;
      this._whenEnabled = new Promise(resolve => this._enable = resolve, console.error);
      this._strokeWeight = 2;
      this._strokeColor = 0x00;
    }
    _init() {
      this._update();
    }
    _focus() {
      if (this._smooth === undefined) this._smooth = true;
      this._focused = true;
      this._update();
    }
    _unfocus() {
      this._focused = false;
      this._update();
    }
    _updateColor() {
      const color = this._focused ? getFirstNumber$1(this.focusedBackground, this.styles.focused.background.color) : getFirstNumber$1(this.background, this.styles.background.color);
      if (this._smooth) {
        this.smooth = {
          color
        };
      } else {
        this.color = color;
      }
    }
    _updateTitle() {
      if (this.title) {
        this._Title.text = {
          ...this.styles.text,
          fontColor: this.styles.text.color,
          fontSize: this.fontSize || this.styles.text.fontSize,
          fontFamily: this.styles.text.fontFace || this.styles.text.fontFamily || this.stage._options.defaultFontFace,
          text: this.title
        };
        const color = this._focused ? getFirstNumber$1(this.focusedTextColor, this.styles.focused.text.color) : getFirstNumber$1(this.textColor, this.styles.text.color);
        if (this._smooth) {
          this._Title.smooth = {
            color
          };
        } else {
          this._Title.color = color;
        }
      } else {
        this._Title.texture = false;
      }
    }
    _updateIcon() {
      if (this.icon) {
        const {
          color,
          size,
          spacing,
          src
        } = this.icon;
        this._Icon.patch({
          w: size,
          h: size,
          icon: src,
          flexItem: {
            marginRight: this.title ? spacing : 0
          }
        });
        const iconColor = this._focused ? getFirstNumber$1(this.focusedIconColor, this.styles.focused.icon.color) : getFirstNumber$1(color, this.styles.icon.color);
        if (this._smooth) {
          this._Icon.smooth = {
            color: iconColor
          };
        } else {
          this._Icon.color = iconColor;
        }
      } else {
        this._Icon.patch({
          w: 0,
          h: 0,
          texture: false,
          flexItem: false
        });
      }
    }
    _updateStroke() {
      if (this.stroke && !this._focused) {
        const radius = this.radius || this.styles.radius;
        this.texture = lng$1.Tools.getRoundRect(RoundRect$1.getWidth(this.w), RoundRect$1.getHeight(this.h), radius, 0x00, true, 0xffffffff);
        this._Stroke.color = this.strokeColor;
        this._Stroke.texture = lng$1.Tools.getRoundRect(RoundRect$1.getWidth(this.w), RoundRect$1.getHeight(this.h), radius, this.strokeWeight, 0xffffffff, true, this.background);
      } else {
        const radius = this.radius || this.styles.radius;
        this.texture = lng$1.Tools.getRoundRect(RoundRect$1.getWidth(this.w), RoundRect$1.getHeight(this.h), radius);
        this._Stroke.texture = false;
      }
    }
    _updateWidth() {
      if (!this.fixed) {
        const iconSize = this._icon ? this._icon.size + this._icon.spacing : 0;
        const padding = getFirstNumber$1(this.padding, this.styles.padding, 10);
        const w = measureTextWidth$1(this._Title.text || {}) + padding * 2 + iconSize;
        if (w && w !== this.w) {
          this.w = w > this.styles.w ? w : this.styles.w;
          this.fireAncestors('$itemChanged');
          this.signal('buttonWidthChanged', {
            w: this.w
          });
        }
      }
    }
    _update() {
      this._whenEnabled.then(() => {
        this._updateColor();
        this._updateTitle();
        this._updateIcon();
        this._updateStroke();
        this._updateWidth();
      });
    }
    _handleEnter() {
      if (typeof this.onEnter === 'function') {
        this.onEnter(this);
      }
    }
    get radius() {
      return this._radius;
    }
    set radius(radius) {
      if (this._radius !== radius) {
        this._radius = radius;
        this._update();
      }
    }
    get title() {
      return this._title;
    }
    set title(title) {
      if (this._title !== title) {
        this._title = title;
        this._update();
      }
    }
    get icon() {
      return this._icon;
    }
    set icon(_ref) {
      let {
        src,
        size = 20,
        spacing = 5,
        color = 0xffffffff
      } = _ref;
      if (src) {
        this._icon = {
          src,
          size,
          spacing,
          color
        };
      } else {
        this._icon = null;
      }
      this._update();
    }
    get strokeWeight() {
      return this._strokeWeight;
    }
    set strokeWeight(strokeWeight) {
      if (this._strokeWeight !== strokeWeight) {
        this._strokeWeight = strokeWeight;
        this._update();
      }
    }
    get strokeColor() {
      return this._strokeColor;
    }
    set strokeColor(strokeColor) {
      if (this._strokeColor !== strokeColor) {
        this._strokeColor = strokeColor;
        this._update();
      }
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(stroke) {
      if (this._stroke !== stroke) {
        this._stroke = stroke;
        this._update();
      }
    }
    get w() {
      return this._w;
    }
    set w(w) {
      if (this._w !== w) {
        this._w = w;
        this._update();
      }
    }
    set label(label) {
      this._label = label;
    }
    get label() {
      return this._label || this._title;
    }
    get announce() {
      // TODO - Localization?
      // Do we need a locale file with
      // component translations?
      return this.label + ', Button';
    }
    get _Content() {
      return this.tag('Content');
    }
    get _Title() {
      return this.tag('Content.Title');
    }
    get _Icon() {
      return this.tag('Content.Icon');
    }
    get _Stroke() {
      return this.tag('Stroke');
    }
  }
  var Button$1 = withStyles(Button, styles);

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FocusManager extends lng$1.Component {
    constructor(stage) {
      super(stage);
      this.patch({
        Items: {}
      });
      this._direction = this.direction || 'row';
    }
    _construct() {
      this._selectedIndex = 0;
    }
    get direction() {
      return this._direction;
    }
    set direction(direction) {
      this._direction = direction;
      let state = {
        none: 'None',
        column: 'Column',
        row: 'Row'
      }[direction];
      if (state) {
        this._setState(state);
      }
    }
    get Items() {
      return this.tag('Items');
    }
    get items() {
      return this.Items.children;
    }
    set items(items) {
      this.Items.childList.clear();
      this._selectedIndex = 0;
      this.appendItems(items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.Items.childList.a(items);
      this._refocus();
    }
    get selected() {
      return this.Items.children[this.selectedIndex];
    }
    get selectedIndex() {
      return this._selectedIndex;
    }
    set selectedIndex(index) {
      const prevSelected = this.selected;
      if (index !== this._selectedIndex) {
        this._selectedIndex = index;
      }
      // Have items update (change height or width) before we render
      this._refocus();
      if (this.selected) {
        this.render(this.selected, prevSelected);
        this.signal('selectedChange', this.selected, prevSelected);
      }
    }

    // Override
    render() {}
    selectPrevious() {
      if (this.selectedIndex > 0) {
        let prevIndex = this.selectedIndex - 1;
        let previous = this.items[prevIndex];
        while (prevIndex && previous.skipFocus) {
          this._selectedIndex = prevIndex;
          this.render(previous, this.items[prevIndex + 1]);
          prevIndex -= 1;
          previous = this.items[prevIndex];
        }
        this.selectedIndex = prevIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = this.Items.children.length - 1;
        return true;
      }
      return false;
    }
    selectNext() {
      if (this.selectedIndex < this.Items.children.length - 1) {
        let nextIndex = this.selectedIndex + 1;
        let next = this.items[nextIndex];
        while (nextIndex < this.items.length - 1 && next.skipFocus) {
          this._selectedIndex = nextIndex;
          this.render(next, this.items[nextIndex - 1]);
          nextIndex += 1;
          next = this.items[nextIndex];
        }
        this.selectedIndex = nextIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = 0;
        return true;
      }
      return false;
    }
    _getFocused() {
      let {
        selected
      } = this;
      // Make sure we're focused on a component
      if (selected) {
        if (selected.focusRef) {
          return selected.tag(selected.focusRef);
        } else if (selected.cparent) {
          return selected;
        }
      }
      return this;
    }
    static _states() {
      return [class None extends this {}, class Row extends this {
        _handleLeft() {
          return this.selectPrevious();
        }
        _handleRight() {
          return this.selectNext();
        }
      }, class Column extends this {
        _handleUp() {
          return this.selectPrevious();
        }
        _handleDown() {
          return this.selectNext();
        }
      }];
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Column extends FocusManager {
    static _template() {
      return {
        direction: 'column'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._h = this.stage.h;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 30;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
      this._updateImmediate = debounce_1.debounce(this._updateLayout, this.debounceDelay, true);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollUp() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsY < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollDown() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsY - this.h) < lastChild.y + this.Items.childList.last.h;
    }
    render(next, prev) {
      this._prevLastScrollIndex = this._lastScrollIndex;
      if (this.plinko && prev && (prev.currentItem || prev.selected)) {
        next.selectedIndex = this._getIndexOfItemNear(next, prev);
      }

      // Rows are changing height, so we'll render via updateLayout
      if (this.itemsChangeable) {
        return;
      }
      this._performRender();
    }
    _performRender() {
      this._whenEnabled.then(() => {
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;
        const firstChild = this.Items.childList.first;
        const lastChild = this.Items.childList.last;
        const shouldScroll = this.alwaysScroll || lastChild && (this.shouldScrollUp() || this.shouldScrollDown());
        if (shouldScroll) {
          const scrollItem = this.selectedIndex > this._lastScrollIndex ? this.Items.children[this._lastScrollIndex - this._scrollIndex] : this.selected;
          if (this._smooth) {
            this.Items.smooth = {
              y: [-(scrollItem || firstChild).transition('y').targetValue + (scrollItem === this.selected ? scrollOffset : 0), this._itemTransition]
            };
          } else {
            this.Items.patch({
              y: -scrollItem.y + (scrollItem === this.selected ? scrollOffset : 0)
            });
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const y = getY(child);
      const {
        h
      } = child;
      const withinLowerBounds = y + h + this._itemsY > 0;
      const withinUpperBounds = y + this._itemsY < this.h;
      return withinLowerBounds && withinUpperBounds;
    }
    _updateLayout() {
      this._whenEnabled.then(() => {
        let nextY = 0;
        let nextW = 0;
        // layout items in row
        for (let i = 0; i < this.Items.children.length; i++) {
          const child = this.Items.children[i];
          nextW = Math.max(nextW, getW(child));
          if (this._smooth) {
            child.smooth = {
              y: [nextY, this._itemTransition]
            };
          } else {
            child.patch({
              y: nextY
            });
          }
          nextY += child.h;
          if (i < this.Items.children.length - 1) {
            nextY += this.itemSpacing;
          }
          if (child.centerInParent) {
            // if the child is another focus manager, check the width of the item container
            const childWidth = child.Items && child.Items.w || child.w;
            // only center the child if it is within the bounds of this focus manager
            if (childWidth < this.w) {
              child.x = (this.w - childWidth) / 2;
            }
          }
        }
        this.Items.patch({
          w: nextW,
          h: nextY
        });
        const lastChild = this.Items.childList.last;
        const endOfLastChild = lastChild ? getY(lastChild) + lastChild.h : 0;
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;

        // determine when to stop scrolling down
        if (this.alwaysScroll) {
          this._lastScrollIndex = this.Items.children.length - 1;
        } else if (endOfLastChild > this.h) {
          for (let i = this.Items.children.length - 1; i >= 0; i--) {
            const child = this.Items.children[i];
            const childY = getY(child);
            if (childY + this.h - scrollOffset > endOfLastChild) {
              this._lastScrollIndex = i;
            } else {
              break;
            }
          }
        } else if (this._lastScrollIndex > this.items.length) {
          this._lastScrollIndex = this.items.length - 1;
        }
        this._performRender();
      });
    }

    // finds the index of the item with the closest middle to the previously selected item
    _getIndexOfItemNear(selected, prev) {
      // edge case
      if (selected.items.length < 2) return 0;
      let prevItem = prev.selected || prev.currentItem;
      let prevOffset = prev.transition('x').targetValue || 0;
      let [itemX] = prevItem.core.getAbsoluteCoords(-prevOffset, 0);
      let prevMiddle = itemX + prevItem.w / 2;

      // set the first item to be closest
      let closest = selected.items[0];
      let closestMiddle = closest.core.getAbsoluteCoords(0, 0)[0] + closest.w / 2;

      // start at the 2nd item
      for (let i = 1; i < selected.items.length; i++) {
        // for some reason here !!/!.. evals returning number
        if (selected.items[i].skipFocus === true) {
          continue;
        }
        const item = selected.items[i];
        const middle = item.core.getAbsoluteCoords(0, 0)[0] + item.w / 2;
        if (Math.abs(middle - prevMiddle) < Math.abs(closestMiddle - prevMiddle)) {
          // current item is the closest
          closest = item;
          closestMiddle = middle;
        } else {
          if (!closest.skipFocus) {
            // weve already found closest return its index
            return selected.items.indexOf(closest);
          } else if (!selected.items[i - 1].skipFocus) {
            // previous item is focusable return it
            return i - 1;
          } else {
            // return closest left or right of index
            const prevIndex = prev.items.indexOf(prevItem);
            return this._getIndexofClosestFocusable(prevIndex, selected, prevMiddle);
          }
        }
      }
      // if last index is focusable return
      return selected.items.length - 1;
    }
    _getIndexofClosestFocusable(selectedIndex, selected, prevMiddle) {
      // dont want to mutate the original selected.items using spread for copy
      // get first focusable item before and after the current focused item's index
      const prevIndex = [...selected.items].slice(0, selectedIndex).map(item => !!item.skipFocus).lastIndexOf(false);
      const nextIndex = [...selected.items].slice(selectedIndex + 1).map(item => !!item.skipFocus).indexOf(false) + selectedIndex + 1;
      const prevItem = selected.items[prevIndex];
      const nextItem = selected.items[nextIndex];

      // Check if the items exist if not return the other
      // covers case where at 0 idx, previous would not exist
      // and opposite for last index next would not exist
      if (prevIndex === -1 || !prevItem) {
        return nextIndex;
      }
      if (nextIndex === -1 || !nextItem) {
        return prevIndex;
      }

      // If both items compare coordinates to determine which direction of plinko
      const next = nextItem.core.getAbsoluteCoords(0, 0)[0] + nextItem.w / 2;
      const prev = prevItem.core.getAbsoluteCoords(0, 0)[0] + prevItem.w / 2;
      return Math.abs(prev - prevMiddle) < Math.abs(next - prevMiddle) ? prevIndex : nextIndex;
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsY() {
      return getY(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemWidth = this.renderWidth;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.w = getW(item) || itemWidth;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    scrollTo(index) {
      let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._itemTransition.duration * 100;
      if (duration === 0) this.selectedIndex = index;
      for (let i = 0; i !== Math.abs(this.selectedIndex - index); i++) {
        setTimeout(() => {
          this.selectedIndex > index ? this.selectPrevious() : this.selectNext();
        }, duration * i);
      }
      this.Items.transition('y').on('finish', () => this._smooth = false);
    }
    $itemChanged() {
      this.itemsChangeable = true;
      this._updateImmediate();
    }
    $removeItem(item) {
      if (item) {
        let wasSelected = item === this.selected;
        this.Items.childList.remove(item);
        this._updateImmediate();
        if (wasSelected || this.selectedIndex >= this.items.length) {
          // eslint-disable-next-line no-self-assign
          this.selectedIndex = this._selectedIndex;
        }
        if (!this.items.length) {
          this.fireAncestors('$columnEmpty');
        }
      }
    }
    $columnChanged() {
      this._updateImmediate();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FadeShader$1 extends lng$1.shaders.WebGLDefaultShader {
    constructor(context) {
      super(context);
      this._margin = {
        left: 0,
        right: 0
      };
    }
    set positionLeft(v) {
      this._positionLeft = v;
    }
    set positionRight(v) {
      this._positionRight = v;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      if (this._positionLeft === 0) {
        this._positionLeft = 0.001;
      }
      if (this._positionRight === 0) {
        this._positionRight = 0.001;
      }
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform('margin', [this._positionLeft * renderPrecision, this._positionRight * renderPrecision], this.gl.uniform1fv);
      this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
  }
  FadeShader$1.fragmentShaderSource = "\n  #ifdef GL_ES\n  precision lowp float;\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class MarqueeText extends lng$1.Component {
    static _template() {
      return {
        TextClipper: {
          boundsMargin: [],
          // overwrite boundsMargin so text won't de-render if moved offscreen
          TextBox: {
            Text: {},
            TextLoopTexture: {}
          }
        }
      };
    }
    get title() {
      return (this._Text && this._Text.text || {}).text;
    }
    set title(text) {
      this.patch({
        TextClipper: {
          w: this.finalW + 14,
          h: text.lineHeight + 10,
          TextBox: {
            Text: {
              rtt: true,
              text: {
                ...text
              }
            },
            TextLoopTexture: {}
          }
        }
      });
      this._Text.on('txLoaded', () => {
        if (this.autoStart) {
          this.startScrolling();
        }
      });
      this._Text.loadTexture();
      this._updateShader(this.finalW);
      this._scrolling && this.startScrolling();
    }
    set color(color) {
      this.tag('TextBox.Text').smooth = {
        color
      };
    }
    startScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      if (this._textRenderedW === 0) {
        this._Text.on('txLoaded', () => {
          this.startScrolling();
        });
      }
      if (this._textRenderedW > finalW - this._fadeW) {
        this._scrolling = true;
        this._TextLoopTexture.x = this._textRenderedW + this._offset;
        this._TextLoopTexture.texture = this._Text.getTexture();
        this._updateShader(finalW);
        this._updateAnimation();
        this._scrollAnimation.start();
      } else {
        // in case the metadata width gets larger on focus and the text goes from being clipped to not
        this._TextClipper.shader = null;
        if (this._Text.text && this._Text.text.textAlign === 'center') {
          this._centerText(finalW);
        }
        this._scrolling = false;
      }
    }
    stopScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      this._scrolling = false;
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this._TextLoopTexture.texture = null;
      }
      this._updateShader(finalW);
    }
    _updateShader(finalW) {
      this.stage.update();
      this._Text.loadTexture();
      this._TextClipper.patch({
        w: finalW > 0 ? finalW + this._fadeW / 2 : 0,
        shader: {
          type: FadeShader$1,
          positionLeft: 0,
          positionRight: this._fadeW
        },
        rtt: true
      });
    }
    _updateAnimation() {
      this._scrollAnimation && this._scrollAnimation.stopNow();
      this._scrollAnimation = this.animation({
        duration: this._textRenderedW / 50,
        delay: isNaN(this.delay) ? 1.5 : this.delay,
        repeat: isNaN(this.repeat) ? -1 : this.repeat,
        actions: [{
          t: 'TextBox',
          p: 'x',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.5: {
              v: -(this._textRenderedW + this._offset)
            }
          }
        }, {
          t: 'TextClipper',
          p: 'shader.positionLeft',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.1: {
              v: this._fadeW
            },
            0.4: {
              v: this._fadeW
            },
            0.5: {
              v: 0
            }
          }
        }]
      });
    }
    _centerText(finalW) {
      this._TextBox.x = ((finalW || this.finalW) - this._textRenderedW) / 2;
    }
    get _TextClipper() {
      return this.tag('TextClipper');
    }
    get _TextBox() {
      return this.tag('TextBox');
    }
    get _Text() {
      return this.tag('Text');
    }
    get _TextLoopTexture() {
      return this.tag('TextLoopTexture');
    }
    get _offset() {
      return 32;
    }
    get _fadeW() {
      return 30;
    }
    get _textRenderedW() {
      return this._Text.renderWidth;
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Row extends FocusManager {
    static _template() {
      return {
        direction: 'row'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._w = this.stage.w;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 1;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollLeft() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsX < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollRight() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsX - this.w) < lastChild.x + this.Items.childList.last.w;
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const x = getX(child);
      const {
        w
      } = child;
      const withinLowerBounds = x + w + this._itemsX > 0;
      const withinUpperBounds = x + this._itemsX < this.w;
      return withinLowerBounds && withinUpperBounds;
    }
    _isOnScreenCompletely(child) {
      let itemX = child.core.renderContext.px;
      let rowX = this.core.renderContext.px;
      return itemX >= rowX && itemX + child.w <= rowX + this.w;
    }
    _shouldScroll() {
      const lastChild = this.Items.childList.last;
      let shouldScroll = this.alwaysScroll;
      if (!shouldScroll) {
        if (this.lazyScroll) {
          shouldScroll = !this._isOnScreenCompletely(this.selected);
        } else {
          shouldScroll = lastChild && (this.shouldScrollLeft() || this.shouldScrollRight() || !this._isOnScreenCompletely(this.selected));
        }
      }
      return shouldScroll;
    }
    _getLazyScrollX(prev) {
      let itemsContainerX;
      const prevIndex = this.Items.childList.getIndex(prev);
      if (prevIndex > this.selectedIndex) {
        itemsContainerX = -this.selected.x;
      } else if (prevIndex < this.selectedIndex) {
        itemsContainerX = this.w - this.selected.x - this.selected.w;
      }
      return itemsContainerX;
    }
    _getScrollX() {
      let itemsContainerX;
      let itemIndex = this.selectedIndex - this.scrollIndex;
      itemIndex = itemIndex < 0 ? 0 : itemIndex;
      if (this.Items.children[itemIndex]) {
        itemsContainerX = this.Items.children[itemIndex].transition('x') ? -this.Items.children[itemIndex].transition('x').targetValue : -this.Items.children[itemIndex].x;
      }
      return itemsContainerX;
    }
    render(next, prev) {
      this._whenEnabled.then(() => {
        this._prevLastScrollIndex = this._lastScrollIndex;
        if (this._shouldScroll()) {
          const itemsContainerX = this.lazyScroll && prev ? this._getLazyScrollX(prev) : this._getScrollX();
          if (itemsContainerX !== undefined) {
            if (this._smooth) {
              this.Items.smooth = {
                x: [itemsContainerX, this._itemTransition]
              };
            } else {
              this.Items.x = itemsContainerX;
            }
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    _updateLayout() {
      let nextX = 0;
      let nextH = 0;
      // layout items in row
      for (let i = 0; i < this.Items.children.length; i++) {
        const child = this.Items.children[i];
        nextH = Math.max(nextH, getH(child));
        if (this._smooth) {
          child.smooth = {
            x: [nextX, this._itemTransition]
          };
        } else {
          child.patch({
            x: nextX
          });
        }
        nextX += child.w;
        if (i < this.Items.children.length - 1) {
          nextX += this.itemSpacing;
        }
        if (child.centerInParent) {
          // if the child is another focus manager, check the height of the item container
          const childHeight = child.Items && child.Items.h || child.h;
          // only center the child if it is within the bounds of this focus manager
          if (childHeight < this.h) {
            child.y = (this.h - childHeight) / 2;
          }
        }
      }
      this.Items.patch({
        h: nextH,
        w: nextX
      });
      const lastChild = this.Items.childList.last;
      const endOfLastChild = lastChild ? getX(lastChild) + lastChild.w : 0;
      const scrollOffset = (this.Items.children[this._scrollIndex] || {
        x: 0
      }).x;

      // determine when to stop scrolling right
      if (this.alwaysScroll) {
        this._lastScrollIndex = this.Items.children.length - 1;
      } else if (endOfLastChild > this.w) {
        for (let i = this.Items.children.length - 1; i >= 0; i--) {
          const child = this.Items.children[i];
          const childX = getX(child);
          if (childX + this.w - scrollOffset > endOfLastChild) {
            this._lastScrollIndex = i;
          } else {
            break;
          }
        }
      }
      this.fireAncestors('$itemChanged');
      this.render(this.selected, null);
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsX() {
      return getX(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemHeight = this.renderHeight;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.h = item.h || itemHeight;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    $itemChanged() {
      this._update();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const KEY_DIMENSIONS = {
    h: 90,
    w: 109,
    padding: 0,
    fixed: true
  }; // actualize key values : 60 ,60  ; 90,100
  const isUpperCase = string => /^[A-Z]$/.test(string);
  class Key extends Button$1 {
    static _template() {
      return {
        ...super._template(),
        ...KEY_DIMENSIONS
      };
    }
    set config(config) {
      if (config) {
        this.sizes = config.sizes;
      }
    }
    set icon(src) {
      if (src) {
        this._Icon.patch({
          color: 0xffffffff,
          size: 32,
          spacing: 16,
          src
        });
      }
    }
    set size(size) {
      this.w = this._sizes[size] || this.h;
    }
    set char(char) {
      this.title = char;
    }
    set announce(value) {
      this._announce = value;
    }
    get announce() {
      if (this._announce) {
        return this._announce;
      }
      if (isUpperCase(this.title)) {
        return "Capital ".concat(this.title, ", button");
      }
      return this.title + ', button';
    }
    set label(label) {
      this.title = label;
    }
    get _sizes() {
      return this.styles.sizes ? {
        ...this.styles.sizes,
        ...this.sizes
      } : {
        small: 50,
        medium: 110,
        large: 273,
        xlarge: 718,
        done_size: 340,
        ...this.sizes
      }; // actualize values 50,110,212,350 ; 50,110,212,750
    }
    _handleEnter() {
      if (this.toggle) {
        this.fireAncestors('$toggleKeyboard', this.toggle);
      }
      this.fireAncestors('$onSoftKey', {
        key: this.title
      });
    }
  }

  /*
  * If not stated otherwise in this file or this component's LICENSE file the
  * following copyright and licenses apply:
  *
  * Copyright 2021 RDK Management
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * Copyright 2021 Comcast Cable Communications Management, LLC
  * Licensed under the Apache License, Version 2.0
  */
  class Keyboard extends lng$1.Component {
    _construct() {
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
    }
    get announce() {
      return 'Keyboard' + (this.title ? ", ".concat(this.title) : '');
    }
    get announceContext() {
      return ['PAUSE-2', 'Use arrow keys to choose characters, press center to select'];
    }
    set formats(formats) {
      if (formats === void 0) {
        formats = {};
      }
      this._formats = formats;
      this._currentFormat = this._defaultFormat;
      // Ensure formats prop is set last
      this._whenEnabled.then(() => {
        Object.entries(formats).forEach(_ref => {
          let [key, value] = _ref;
          let keyboardData = this._formatKeyboardData(value);
          this._createKeyboard(key, this._createRows(keyboardData));
        });
        this.tag(this._currentFormat).alpha = 1;
        this._refocus();
      });
    }
    _createKeyboard(key) {
      let rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      key = key.charAt(0).toUpperCase() + key.slice(1);
      if (rows.length === 1) {
        this.patch({
          [key]: {
            ...rows[0],
            alpha: 0
          }
        });
      } else {
        this.patch({
          [key]: {
            type: Column,
            alpha: 0,
            plinko: true,
            itemSpacing: this._spacing,
            items: rows
          }
        });
      }
    }
    _createRows() {
      let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return rows.map(keys => {
        let h = this.keysConfig && this.keysConfig.h || KEY_DIMENSIONS.h;
        return {
          type: Row,
          h,
          wrapSelected: this.rowWrap === undefined ? true : this.rowWrap,
          itemSpacing: this._spacing,
          items: this._createKeys(keys)
        };
      });
    }
    _createKeys() {
      let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return keys.map(keyProps => {
        const key = {
          type: this.keyComponent || Key,
          config: this.keysConfig
        };
        if (!keyProps) {
          return {
            ...KEY_DIMENSIONS,
            skipFocus: true
          };
        } else if (typeof keyProps === 'object') {
          return {
            ...key,
            ...keyProps
          };
        }
        return {
          ...key,
          label: keyProps
        };
      });
    }
    _formatKeyboardData() {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (Array.isArray(data) && data.length) {
        if (!Array.isArray(data[0]) && !this.inline) {
          let keyRows = [],
            idx,
            counter;
          for (idx = 0, counter = -1; idx < data.length; idx++) {
            if (idx % this.columnCount === 0) {
              counter++;
              keyRows[counter] = [];
            }
            keyRows[counter].push(data[idx]);
          }
          return keyRows;
        } else if (this.inline) {
          return [data];
        }
        return data;
      }
    }
    $toggleKeyboard(keyboardFormat) {
      keyboardFormat = keyboardFormat.charAt(0).toUpperCase() + keyboardFormat.slice(1);
      if (keyboardFormat !== this._currentFormat) {
        this.selectKeyOn(this.tag(keyboardFormat));
        this.tag(this._currentFormat).alpha = 0;
        this.tag(keyboardFormat).alpha = 1;
        this._currentFormat = keyboardFormat;
      }
    }
    selectKeyOn(keyboard) {
      let {
        row,
        column
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelectedKey();
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        keyboard.selectedIndex = column;
      } else {
        keyboard.selectedIndex = row;
        keyboard.Items.children[row].selectedIndex = column;
      }
    }
    getSelectedKey() {
      let row, column;
      let keyboard = this.tag(this._currentFormat);
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        row = 0;
        column = keyboard.selectedIndex;
      } else {
        row = keyboard.selectedIndex;
        column = keyboard.Items.children[row].selectedIndex;
      }
      return {
        row,
        column
      };
    }
    _getFocused() {
      return this.tag(this._currentFormat) || this;
    }
    _focus() {
      this.fireAncestors('$keyboardFocused', true);
    }
    _unfocus() {
      this.tag(this._currentFormat).alpha = 0;
      this._currentFormat = this._defaultFormat;
      this.tag(this._currentFormat).alpha = 1;
      this._refocus();
      this.fireAncestors('$keyboardFocused', false);
    }
    set columnCount(columnCount) {
      this._columnCount = columnCount;
    }
    set rowCount(rowCount) {
      this._rowCount = rowCount;
    }
    get columnCount() {
      if (this._columnCount) return this._columnCount;
      if (this._rowCount) return this._formats[this._defaultFormat.toLowerCase()].length / this._rowCount;
      if (this.inline) return this._formats[this._defaultFormat.toLowerCase()].length;else return 11;
    }
    get _spacing() {
      return this.spacing || 8;
    }
    get _defaultFormat() {
      let defaultFormat = this.defaultFormat || Object.keys(this._formats)[0];
      return defaultFormat.charAt(0).toUpperCase() + defaultFormat.slice(1);
    }
  }
  const KEYBOARD_FORMATS = {
    fullscreen: {
      letters: [['', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'large',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']],
      symbols: [['', '', '', '', '', '', '', '', '', {
        label: 'ABC',
        size: 'large',
        toggle: 'letters',
        announce: 'caps on, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, '~', '_', '.', '-', '+']]
    },
    qwerty: {
      uppercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['Z', 'X', 'C', 'V', 'B', 'N', 'M', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      lowercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['z', 'x', 'c', 'v', 'b', 'n', 'm', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'uppercase',
        announce: 'shift on, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accents: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accentsUpper',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accentsUpper: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accents',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      symbols: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], [{
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], [{
        label: '{',
        announce: 'open brace, button'
      }, {
        label: '}',
        announce: 'close brace, button'
      }, {
        label: '[',
        announce: 'open bracket, button'
      }, {
        label: ']',
        announce: 'close bracket, button'
      }, {
        label: ';',
        announce: 'semicolon, button'
      }, {
        label: '"',
        announce: 'doublequote, button'
      }, {
        label: "'",
        announce: 'singlequote, button'
      }, {
        label: '|',
        announce: 'vertical bar, button'
      }, {
        label: '\\',
        announce: 'backslash, button'
      }, {
        label: '/',
        announce: 'forwardslash, button'
      }, {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], [{
        label: '<',
        announce: 'less than, button'
      }, {
        label: '>',
        announce: 'greater than, button'
      }, {
        label: '?',
        announce: 'question mark, button'
      }, {
        label: '=',
        announce: 'equals, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, {
        label: '~',
        announce: 'tilde, button'
      }, {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: '+',
        announce: 'plus sign, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]]
    },
    numbers: {
      // numbers: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
      // dialpad: [
      //   ['1', '2', '3'],
      //   ['4', '5', '6'],
      //   ['7', '8', '9'],
      //   ['', '0', '']
      // ],
      dialpadExtended: [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'], ['Delete', '0', 'Clear'], [{
        label: 'Done',
        size: 'done_size'
      }]]
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class PasswordSwitch extends lng$1.Component {
    static _template() {
      return {
        src: Utils.asset('images/settings/ToggleOffWhite.png')
      };
    }
    _handleEnter() {
      if (this.isOn) {
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
      } else {
        this.patch({
          src: Utils.asset("images/settings/ToggleOnOrange.png")
        });
      }
      this.isOn = !this.isOn;
      this.fireAncestors('$handleEnter', this.isOn);
    }
    _init() {
      this.isOn = false;
    }
    _disable() {
      if (this.isOn) {
        this.isOn = false;
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
        this.fireAncestors('$handleEnter', this.isOn);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const WiFiErrorMessages = {
    0: 'SSID_CHANGED - The SSID of the network changed',
    1: 'CONNECTION_LOST - The connection to the network was lost',
    2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
    3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
    4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
    5: 'NO_SSID - The SSID does not exist',
    6: 'UNKNOWN - Any other error.'
  };
  const WiFiState = {
    UNINSTALLED: 0,
    DISABLED: 1,
    DISCONNECTED: 2,
    PAIRING: 3,
    CONNECTING: 4,
    CONNECTED: 5,
    FAILED: 6
  };
  const WiFiError = {
    SSID_CHANGED: 0,
    CONNECTION_LOST: 1,
    CONNECTION_FAILED: 2,
    CONNECTION_INTERRUPTED: 3,
    INVALID_CREDENTIALS: 4,
    NO_SSID: 5,
    UNKNOWN: 6
  };
  let instance$3 = null;
  class Wifi {
    constructor() {
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.callsign = 'org.rdk.Wifi';
      this.INFO = console.info;
      this.LOG = console.log;
      this.ERR = console.error;
    }
    static get() {
      if (instance$3 == null) {
        instance$3 = new Wifi();
        // Vital plugins; always keep activated.
        instance$3.activate();
      }
      return instance$3;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " activate");
        this.thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " activate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder Controller wifi activate" + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " deactivate");
        this.thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " deactivate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder Controller wifi deactivate" + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    cancelWPSPairing() {
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " cancelWPSPairing");
        this.thunder.call(this.callsign, 'cancelWPSPairing').then(result => {
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + ": cancelWPSPairing error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi cancelWPSPairing" + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    clearSSID() {
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " clearSSID");
        this.thunder.call(this.callsign, 'clearSSID').then(result => {
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + ": clearSSID error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi clearing SSID" + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    connect() {
      let useSaved = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let networkInfo = arguments.length > 1 ? arguments[1] : undefined;
      let passphrase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      let params = {};
      if (!useSaved) {
        // saveSSID was never called earlier. Need proper params.
        params.ssid = networkInfo.ssid;
        if (Object.prototype.hasOwnProperty.call(networkInfo, "security")) params.securityMode = networkInfo.security;
        if (passphrase.length) params.passphrase = passphrase;
      }
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " connect with params: " + JSON.stringify(params));
        this.thunder.call(this.callsign, 'connect', params).then(result => {
          result.success ? resolve(result.success) : reject(result.success);
        }).catch(err => {
          this.ERR(this.callsign + ": connect error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi connect params " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    disconnect() {
      return new Promise((resolve, reject) => {
        this.LOG(this.callsign + " disconnect");
        this.thunder.call(this.callsign, 'disconnect').then(result => {
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + ": disconnect error:" + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi disconnect params " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getConnectedSSID() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getConnectedSSID').then(result => {
          this.LOG(this.callsign + " getConnectedSSID result:" + "Error in Thunder wifi connect params" + JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " getConnectedSSID error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi getConnectedSSID " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getCurrentState() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getCurrentState').then(result => {
          this.LOG(this.callsign + " getCurrentState result:" + result);
          resolve(result.success ? result.state : 0); // 0 is UNINSTALLED
        }).catch(err => {
          this.ERR(this.callsign + " getCurrentState error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi getCurrentState " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getPairedSSID() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getPairedSSID').then(result => {
          this.LOG(this.callsign + " getPairedSSID result:" + result);
          if (result.success) resolve(result.ssid);
          reject(result);
        }).catch(err => {
          this.ERR(this.callsign + " getPairedSSID error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi getPairedSSID " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getPairedSSIDInfo() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getPairedSSIDInfo').then(result => {
          this.LOG(this.callsign + " getPairedSSIDInfo result:" + result);
          if (result.success) resolve(result);
          reject(result);
        }).catch(err => {
          this.ERR(this.callsign + " getPairedSSIDInfo error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi getPairedSSIDInfo " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSupportedSecurityModes() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getSupportedSecurityModes').then(result => {
          this.LOG(this.callsign + " getSupportedSecurityModes result:" + result);
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " getSupportedSecurityModes error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi getSupportedSecurityModes " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    initiateWPSPairing() {
      let method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "PIN";
      let wps_pin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      // SERIALIZED_PIN/PIN/PBC
      return new Promise((resolve, reject) => {
        let params = {
          method: method
        };
        if (method == "PIN") {
          params.wps_pin = wps_pin;
        }
        this.thunder.call(this.callsign, 'initiateWPSPairing', params).then(result => {
          this.LOG(this.callsign + " initiateWPSPairing result:" + result);
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " initiateWPSPairing error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi initiateWPSPairing " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    isPaired() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'isPaired').then(result => {
          this.LOG(this.callsign + " isPaired result:" + result);
          if (result.success) resolve(result.result);
          reject(result);
        }).catch(err => {
          this.ERR(this.callsign + " isPaired error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi isPaired " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    isSignalThresholdChangeEnabled() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'isSignalThresholdChangeEnabled').then(result => {
          this.LOG(this.callsign + " isSignalThresholdChangeEnabled result:" + result);
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " isSignalThresholdChangeEnabled error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi isSignalThresholdChangeEnabled " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    saveSSID(ssid, passphrase, securityMode) {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'saveSSID', {
          ssid: ssid,
          passphrase: passphrase,
          securityMode: securityMode
        }).then(result => {
          this.LOG(this.callsign + " saveSSID result:" + result);
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " saveSSID error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi saveSSID " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setEnabled() {
      let enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'setEnabled', {
          enable: enable
        }).then(result => {
          this.LOG(this.callsign + " setEnabled result:" + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + " setEnabled error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi setEnabled " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setSignalThresholdChangeEnabled() {
      let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      let interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'setSignalThresholdChangeEnabled', {
          enabled: enabled,
          interval: interval
        }).then(result => {
          this.LOG(this.callsign + " setSignalThresholdChangeEnabled result:" + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + " setSignalThresholdChangeEnabled error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi setSignalThresholdChangeEnabled " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    startScan() {
      let incremental = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let ssid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      let frequency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      // frequence: 2.5 or 5.0
      return new Promise((resolve, reject) => {
        let params = {
          incremental: incremental
        };
        if (ssid.length) params.ssid = ssid;
        if (frequency.length) params.frequency = frequency;
        this.LOG(this.callsign + " startScan params:" + params);
        this.thunder.call(this.callsign, 'startScan', params).then(result => {
          this.LOG(this.callsign + " startScan result:" + result);
          resolve(result);
        }).catch(err => {
          this.ERR(this.callsign + " startScan error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi startScan " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    stopScan() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'stopScan').then(result => {
          this.LOG(this.callsign + " stopScan result:" + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + " stopScan error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.NETWORK, "WifiApiError", "Error in Thunder wifi stopScan " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class JoinAnotherNetworkComponent$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _active() {
      this.hidePasswd = true;
      this.star = "";
      this.tag("Keyboard").visible = false;
    }
    handleDone() {
      this.tag("Keyboard").visible = false;
      let securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14 || securityCode === 0 && !this.scode) {
        this.scode = true;
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        let self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }
    async startConnectForAnotherNetwork(device, passphrase) {
      await Wifi.get().connect(false, {
        ssid: device.ssid,
        security: device.security
      }, passphrase).then(() => {
        Wifi.get().saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            PersistentStoreApi.get().setValue('wifi', 'SSID', device.ssid);
          } else if (response.result !== 0) {
            Wifi.get().clearSSID();
          }
        });
        if (!Router.isNavigating()) {
          Router.back();
        }
      });
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xCC000000
        },
        Text: {
          x: 758,
          y: 70,
          text: {
            text: Language$1.translate("Find and join a WiFi network"),
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: Language$1.translate("Network Name") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: Language$1.translate("Security") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: Language$1.translate("Password") + ":",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard,
          visible: false,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 330,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: true
        },
        ShowPassword: {
          x: 1405,
          y: 312,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: Language$1.translate('Show Password'),
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: true
        }
      };
    }
    _focus() {
      this.scode = false;
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = Language$1.translate("Press OK to enter Password");
      this.tag("NetworkText").text.text = Language$1.translate("Press OK to enter SSID");
      this.tag('NetworkText').text.textColor = 0xff808080;
      this.tag('Pwd').text.textColor = 0xff808080;
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    encrypt() {
      if (this.prevState === "EnterPassword" && this.hidePasswd) return true;else return false;
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
          this.tag('NetworkText').text.text = this.textCollection['EnterSSID'];
          this.tag('NetworkText').text.textColor = 0xffffffff;
          this.tag("Keyboard").visible = true;
        }
        $exit() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleRight() {
          this._setState("PasswordSwitchState");
        }
        _handleEnter() {
          this.tag("Keyboard").visible = true;
          this._setState('Keyboard');
          this.tag('Pwd').text.text = this.hidePasswd ? this.star : this.textCollection['EnterPassword'];
          this.tag('Pwd').text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
          this.tag('ShowPassword').text.textColor = CONFIG.theme.hex;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleLeft() {
          this._setState("EnterPassword");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['EnterPassword']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
          this.tag('ShowPassword').text.textColor = 0xffffffff;
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (this.prevState === 'PasswordSwitchState') {
            this.prevState = "EnterPassword";
          }
          console.log("Prev state:", this.prevState);
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.star = this.prevState === "EnterPassword" ? this.star.substring(0, this.star.length - 1) : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.star = this.prevState === "EnterPassword" ? '' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          }
        }
        _handleUp() {
          this._setState(this.prevState);
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _init() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.star = '';
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkConfigurationScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _active() {
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      Network.get().getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
      this.onDefaultIfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', data => {
        this.$NetworkInterfaceText(data.newInterfaceName);
        this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
        Metrics$3.action("user", "User changed the network interface", null);
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6"; // this fails, need to verify how to set proper ip settings

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _inactive() {
      this.onDefaultIfaceChangedCB.dispose();
    }
    _focus() {
      this._setState(this.state); //can be used on init as well
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language$1.translate('Network Interface: ') + text;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration'));
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/info');
          }
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface');
          }
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          // this._setState('NetworkInfo')
        }
        async _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          await Network.get().isConnectedToInternet().then(result => {
            var connectionStatus = Language$1.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language$1.translate("Connected");
            } else {
              connectionStatus += Language$1.translate("Disconnected");
            }
            this.tag('TestInternetAccess.Loader').visible = false;
            this.tag('TestInternetAccess.Title').text.text = connectionStatus;
            this.loadingAnimation.stop();
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {
          // Nothing to do here.
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var currentInterface$1 = [];
  class NetworkInfo$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/network');
      }
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Info'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    _active() {
      this.onInterfaceStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onInterfaceStatusChanged', data => {
        this.refreshDetails();
      });
      this.onConnectionStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onConnectionStatusChanged', data => {
        this.refreshDetails();
      });
      this.onIPAddressStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onIPAddressStatusChanged', data => {
        this.refreshDetails();
      });
      this.onDefaultInterfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', data => {
        this.refreshDetails();
      });
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        this.OnNetworkChangedfirebolt = FireBoltApi.get().deviceinfo.listen("networkChanged", value => {
          this.refreshDetails();
        });
      }
    }
    _inactive() {
      this.onInterfaceStatusChangedCB.dispose();
      this.onConnectionStatusChangedCB.dispose();
      this.onIPAddressStatusChangedCB.dispose();
      this.onDefaultInterfaceChangedCB.dispose();
    }
    async refreshDetails() {
      this.tag("ConnectionType.Value").text.text = "NA";
      this.tag("Status.Value").text.text = Language$1.translate('Disconnected');
      this.tag("IPAddress.Value").text.text = "NA";
      this.tag("Gateway.Value").text.text = "NA";
      this.tag("MACAddress.Value").text.text = "NA";
      if ("ResidentApp" === GLOBALS.selfClientName) {
        await Network.get().getDefaultInterface().then(defaultInterface => {
          Network.get().getIPSettings(defaultInterface).then(result => {
            if (result.interface === "WIFI") {
              this.tag("ConnectionType.Value").text.text = Language$1.translate("Wireless");
              this.tag("SSID").alpha = 1;
              this.tag("SignalStrength").alpha = 1;
              Wifi.get().getConnectedSSID().then(result => {
                if (parseInt(result.signalStrength) >= -50) {
                  this.tag("SignalStrength.Value").text.text = "Excellent";
                } else if (parseInt(result.signalStrength) >= -60) {
                  this.tag("SignalStrength.Value").text.text = "Good";
                } else if (parseInt(result.signalStrength) >= -67) {
                  this.tag("SignalStrength.Value").text.text = "Fair";
                } else {
                  this.tag("SignalStrength.Value").text.text = "Poor";
                }
                this.tag("SSID.Value").text.text = "".concat(result.ssid);
              }).catch(error => console.log(error));
            } else if (result.interface === "ETHERNET") {
              this.tag("ConnectionType.Value").text.text = 'Ethernet';
              this.tag("SSID").alpha = 0;
              this.tag("SignalStrength").alpha = 0;
            }
            this.tag('InternetProtocol.Value').text.text = result.ipversion;
            this.tag('IPAddress.Value').text.text = result.ipaddr;
            this.tag("Gateway.Value").text.text = result.gateway;
          }).catch(err => console.error(err));
          Network.get().getInterfaces().then(interfaces => {
            currentInterface$1 = interfaces.filter(data => data.interface === defaultInterface);
            if (currentInterface$1[0].connected) {
              this.tag("Status.Value").text.text = Language$1.translate('Connected');
            } else {
              this.tag('Status.Value').text.text = Language$1.translate('Disconnected');
            }
            this.tag('MACAddress.Value').text.text = currentInterface$1[0].macAddress;
          }).catch(error => console.log(error));
        }).catch(error => console.log(error));
      } else {
        await FireBoltApi.get().deviceinfo.getnetwork().then(res => {
          if (res.type === "wifi") {
            this.tag("ConnectionType.Value").text.text = Language$1.translate("Wireless");
            this.tag("SSID").alpha = 1;
            this.tag("SignalStrength").alpha = 1;
            Wifi.get().getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
          } else if (res.type === "ethernet") {
            this.tag("ConnectionType.Value").text.text = 'Ethernet';
            this.tag("SSID").alpha = 0;
            this.tag("SignalStrength").alpha = 0;
          }
          if (res.state == "connected") {
            this.tag("Status.Value").text.text = Language$1.translate('Connected');
          } else {
            this.tag('Status.Value').text.text = Language$1.translate('Disconnected');
          }
          Network.get().getDefaultInterface().then(defaultInterface => {
            Network.get().getIPSettings(defaultInterface).then(result => {
              this.tag('InternetProtocol.Value').text.text = result.ipversion;
              this.tag('IPAddress.Value').text.text = result.ipaddr;
              this.tag("Gateway.Value").text.text = result.gateway;
            });
            Network.get().getInterfaces().then(interfaces => {
              currentInterface$1 = interfaces.filter(data => data.interface === defaultInterface);
              this.tag('MACAddress.Value').text.text = currentInterface$1[0].macAddress;
            }).catch(error => console.log(error));
          });
        }).catch(error => console.log(error));
      }
    }
    _focus() {
      this.refreshDetails();
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkInterfaceScreen$1 extends lng$1.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 500,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        }
      };
    }
    _focus() {
      console.warn(new Date().toISOString() + " from: NetworkInterfaceScreen.js");
      this._setState('WiFi');
    }
    _active() {
      this.onDefaultInterfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate("Connected");
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate('Error') + ', ' + Language$1.translate('Retry') + '!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
        Metrics$3.action("user", "The user changed the network interface", null);
      });
      this.onConnectionStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onConnectionStatusChanged', notification => {
        console.log('onConnectionStatusChanged notification from networkInterfaceScreen: ', notification);
        if (notification.interface === "ETHERNET") {
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate(notification.status.toLowerCase());
        }
        Metrics$3.action("App", "network connection of app changed", null);
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _inactive() {
      this.onDefaultInterfaceChangedCB.dispose();
      this.onConnectionStatusChangedCB.dispose();
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/network');
      }
    }
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Interface'));
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface/wifi');
          }
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        async _handleEnter() {
          this.tag('Ethernet.Title').text.text = 'Ethernet :' + Language$1.translate('Configuring as default');
          this.tag('Ethernet.Loader').visible = true;
          this.loadingAnimation.start();
          await Network.get().isInterfaceEnabled("ETHERNET").then(enabled => {
            if (!enabled) {
              Network.get().setInterfaceEnabled("ETHERNET").then(() => {
                Network.get().setDefaultInterface("ETHERNET").then(result => {
                  if (result) {
                    this.loadingAnimation.stop();
                    this.tag('Ethernet.Title').text.text = 'Ethernet';
                    this.tag('Ethernet.Loader').visible = false;
                  }
                });
              });
            } else {
              Network.get().setDefaultInterface("ETHERNET").then(result => {
                if (result) {
                  this.loadingAnimation.stop();
                  this.tag('Ethernet.Title').text.text = 'Ethernet';
                  this.tag('Ethernet.Loader').visible = false;
                }
              });
            }
          });
        }
        _handleDown() {
          // this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class ConfirmAndCancel extends lng$1.Component {
    static _template() {
      return {
        Item: {
          w: 325,
          // previous value : ((1920 / 2) - 350) / 2
          h: 85,
          // previous value: 65
          rect: true,
          color: 0xffffffff,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 0
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Left: {
          x: this.tag("Item").w / 2,
          // orginal = 10
          y: this.tag('Item').h / 2,
          mountX: 0.5,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xff000000,
            fontFace: CONFIG.language.font
          }
        }
      });
    }

    /**
     * Set width of the item.
     */
    set width(width) {
      this.tag('Item').w = width;
    }

    /**
     * Set height of the item.
     */
    set height(height) {
      this.tag('Item').h = height;
    }
    _focus() {
      this.tag('Item').color = CONFIG.theme.hex;
    }
    _unfocus() {
      this.tag('Item').color = 0xffffffff;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Password') + ": ",
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1390,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Show Password'),
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: lng$1.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    _handleBack() {
      Router.back();
    }

    /**
     * @param {{ item: Wifi Response Object; }} args
     */
    set params(args) {
      if (args.wifiItem) {
        this.item(args.wifiItem);
      } else {
        Registry.setTimeout(() => {
          Router.navigate('settings/network/interface/wifi');
        }, Router.isNavigating() ? 20 : 0);
      }
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      let options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
    }
    _unfocus() {}
    _active() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
    }
    _inactive() {
      if (this.onErrorCB) this.onErrorCB.dispose();
      if (this.onWIFIStateChangedCB) this.onWIFIStateChangedCB.dispose();
      if (this.waitToConnectTO) Registry.clearTimeout(this.waitToConnectTO);
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        Router.back();
      } else if (option === 'Connect') {
        if (this._item) {
          Wifi.get().connect(false, this._item, '').then(() => {}).catch(err => {
            console.error('Not able to connect to wifi', JSON.stringify(err));
          });
        }
        Router.back();
      } else if (option === 'Disconnect') {
        Wifi.get().disconnect().then(() => {
          Registry.setTimeout(() => {
            Router.back();
          }, Router.isNavigating() ? 20 : 0);
        });
      }
    }
    startConnect() {
      let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      let flag = 0;
      this.onErrorCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onError', notification => {
        if (notification.code === WiFiError.INVALID_CREDENTIALS || notification.code === WiFiError.SSID_CHANGED) {
          console.log("INVALID_CREDENTIALS; deleting WiFi Persistence data.");
          Wifi.get().clearSSID().then(() => {
            PersistentStoreApi.get().deleteNamespace('wifi');
          });
          flag = 1;
          this.onErrorCB.dispose();
        }
      });
      this.onWIFIStateChangedCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onWIFIStateChanged', notification => {
        if (notification.state === WiFiState.CONNECTED) {
          Network.get().setDefaultInterface("WIFI").then(() => {
            console.log("Successfully set WIFI as default interface.");
          }).catch(err => {
            console.error("Could not set WIFI as default interface." + JSON.stringify(err));
          });
          this.onWIFIStateChangedCB.dispose();
        }
      });
      Wifi.get().connect(false, this._item, password).then(() => {
        Wifi.get().saveSSID(this._item.ssid, password, this._item.security).then(response => {
          if (response.result === 0 && response.success === true && flag === 0) {
            PersistentStoreApi.get().setValue('wifi', 'SSID', this._item.ssid);
          } else if (response.result !== 0) {
            Wifi.get().clearSSID();
          }
        }).then(() => {
          // Immediate return causes some clash at plugin implementation level resulting not saving/connecting.
          // https://jira.rdkcentral.com/jira/browse/RDKDEV-924
          // Fix need to be implemented at network manager level and then can remove this.
          this.waitToConnectTO = Registry.setTimeout(() => {
            Router.back();
          }, 5000);
        });
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WiFiItem extends lng$1.Component {
    _construct() {
      this.Lock = Utils.asset('/images/settings/Lock.png');
      this.WiFi1 = Utils.asset('/images/settings/WiFi1.png');
      this.WiFi2 = Utils.asset('/images/settings/WiFi2.png');
      this.WiFi3 = Utils.asset('/images/settings/WiFi3.png');
      this.WiFi4 = Utils.asset('/images/settings/WiFi4.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    _init() {
      this.tag('Item.Tick').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png';
        this.tag('Item.Tick').src = url;
      });
    }
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      if (item.ssid) {
        this.status = item.connected ? 'Connected' : 'Not Connected';
      }
      let wifiicon = "";
      if (item.signalStrength >= -50) {
        wifiicon = this.WiFi4;
      } else if (item.signalStrength >= -60) {
        wifiicon = this.WiFi3;
      } else if (item.signalStrength >= -67) {
        wifiicon = this.WiFi2;
      } else {
        wifiicon = this.WiFi1;
      }
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          //texture: Lightning.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item.connected ? true : false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.ssid,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1560,
          mountX: 1,
          y: 45,
          mountY: 0.5,
          flex: {
            direction: 'row'
          },
          Lock: {
            color: 0xffffffff,
            texture: lng$1.Tools.getSvgTexture(this.Lock, 32.5, 32.5),
            alpha: 1
          },
          Icon: {
            color: 0xffffffff,
            flexItem: {
              marginLeft: 15
            },
            texture: lng$1.Tools.getSvgTexture(wifiicon, 32.5, 32.5)
          }
        }
      });
      if (item.security == '0' || item.security == '15') {
        this.tag('Item.Right.Lock').visible = false;
      } else {
        this.tag('Item.Right.Lock').visible = true;
      }
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let appApi$c = new AppApi();
  var previousFocusedItemSSid;
  class WiFiScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    async _init() {
      await appApi$c.checkStatus(Wifi.get().callsign).then(result => {
        if (result[0].state !== "activated") {
          Wifi.get().activate();
        }
      });
    }
    async _active() {
      this.renderSSIDS = this.ssids = [];
      await Network.get().isInterfaceEnabled("WIFI").then(enabled => {
        this.wifiStatus = enabled;
      });
      this.onInterfaceStatusChangedCB = null;
      this.wifiEventHandlers();
    }
    _focus() {
      if (this.wifiStatus) {
        Wifi.get().startScan();
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.tag('Switch.Loader').visible = true;
        this.wifiLoading.start();
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else {
        this.tag('Networks').visible = false;
        this.tag('JoinAnotherNetwork').visible = false;
        this.tag('Switch.Loader').visible = false;
        this.wifiLoading.stop();
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
      this._setState('Switch');
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _disable() {
      Network.get().isInterfaceEnabled("WIFI").then(enabled => {
        if (enabled) {
          Wifi.get().stopScan();
          this.wifiLoading.stop();
          this.tag('Switch.Loader').visible = false;
        }
      });
      if (this.onInterfaceStatusChangedCB) {
        this.onInterfaceStatusChangedCB.dispose();
      }
    }
    pairedDevices() {
      this.tag('Networks.PairedNetworks').tag('List').items = [];
      this.tag('Networks.AvailableNetworks').tag('List').items = [];
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      console.log("WIFI renderDeviceList ssids.length:" + JSON.stringify(ssids.length));
      ssids.sort((a, b) => {
        if (a.signalStrength >= b.signalStrength) return -1;else return 1;
      });
      this._pairedList = [];
      this.tag('Networks.PairedNetworks').h = 0;
      this.tag('Networks.AvailableNetworks').tag('List').rollMax = ssids.length * 90;
      this.tag('Networks.PairedNetworks').tag('List').items = [];
      this.tag('Networks.PairedNetworks').tag('List').h = 0;
      Wifi.get().getConnectedSSID().then(result => {
        if (result.ssid != '') {
          console.log("Connected network detected " + JSON.stringify(result.ssid));
          this._pairedList = [result];
          this.tag('Networks.PairedNetworks').h = this._pairedList.length * 90;
          this.tag('Networks.PairedNetworks').tag('List').h = this._pairedList.length * 90;
          this.tag('Networks.PairedNetworks').tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this.tag('Networks.AvailableNetworks').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            index: index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
      let IndexVal = 0;
      console.log("previousFocusedItemSSid:::", previousFocusedItemSSid);
      this.tag('Networks.AvailableNetworks').tag('List').items.forEach(element => {
        if (element._item.ssid == previousFocusedItemSSid) {
          IndexVal = element.index;
        }
      });
      this.tag('Networks.AvailableNetworks').tag('List').setIndex(IndexVal);
    }
    _handleBack() {
      Registry.setTimeout(() => {
        Router.navigate('settings/network/interface');
      }, Router.isNavigating() ? 20 : 0);
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Interface  WiFi'));
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          } else {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {}
        _getFocused() {
          return this.tag('Networks.PairedNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          Registry.setTimeout(() => {
            Router.navigate('settings/network/interface/wifi/connect', {
              wifiItem: this.tag('Networks.PairedNetworks').tag('List').element._item
            });
          }, Router.isNavigating() ? 20 : 0);
        }
      }, class AvailableDevices extends this {
        $enter() {}
        _getFocused() {
          previousFocusedItemSSid = this.tag('Networks.AvailableNetworks').tag('List').element._item.ssid;
          return this.tag('Networks.AvailableNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        async _handleEnter() {
          console.log("SSID check" + JSON.stringify(this.tag('Networks.AvailableNetworks').tag('List').element._item));
          let item = this.tag('Networks.AvailableNetworks').tag('List').element._item;
          await Wifi.get().isPaired().then(ispaired => {
            if (!ispaired) {
              // ispaired.result == 0 means saved SSID.
              Wifi.get().getPairedSSID().then(pairedssid => {
                if (pairedssid === item.ssid) {
                  console.log("WiFiScreen getPairedSSID matched with current selection; try auto connect.");
                  Wifi.get().connect(true).then(() => {
                    Wifi.get().thunder.on('onError', notification => {
                      if (notification.code === WiFiError.SSID_CHANGED || notification.code === WiFiError.INVALID_CREDENTIALS) {
                        Wifi.get().clearSSID().then(() => {
                          Router.navigate('settings/network/interface/wifi/connect', {
                            wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
                          });
                        });
                      }
                    });
                    Wifi.get().thunder.on('onWIFIStateChanged', notification => {
                      if (notification.state === WiFiState.CONNECTED) {
                        Network.get().setDefaultInterface("WIFI").then(() => {
                          console.log("Successfully set WIFI as default interface.");
                        }).catch(err => {
                          console.error("Could not set WIFI as default interface." + JSON.stringify(err));
                        });
                      }
                    });
                  }).catch(err => {
                    console.error("WiFiScreen auto-connect error:", JSON.stringify(err));
                    PersistentStoreApi.get().deleteKey('wifi', 'SSID').then(() => {
                      Router.navigate('settings/network/interface/wifi/connect', {
                        wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
                      });
                    });
                  });
                } else {
                  console.log("WiFiScreen getPairedSSID differs with current selection.");
                  Router.navigate('settings/network/interface/wifi/connect', {
                    wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
                  });
                }
              }).catch(err => {
                console.error("WiFi.getPairedSSID() error: ", JSON.stringify(err));
                Router.navigate('settings/network/interface/wifi/connect', {
                  wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
                });
              });
            } else {
              console.log("WiFi.isPaired() is false; attempting regular connect.");
              Router.navigate('settings/network/interface/wifi/connect', {
                wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
              });
            }
          }).catch(err => {
            console.error("WiFi.isPaired() error: ", JSON.stringify(err));
            PersistentStoreApi.get().deleteKey('wifi', 'SSID').then(() => {
              Router.navigate('settings/network/interface/wifi/connect', {
                wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
              });
            });
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this.tag('Networks.PairedNetworks').tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this.tag('Networks.AvailableNetworks').tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this.tag('Networks.PairedNetworks').tag('List');else if (listname === 'AvailableDevices') list = this.tag('Networks.AvailableNetworks').tag('List');
      if (!list) return;
      if (dir === 'down') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this.tag('Networks.AvailableNetworks').tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this.tag('Networks.PairedNetworks').tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }

    /**
     * Function to turn on and off Wi-Fi.
     */
    async switch() {
      if (this.wifiStatus) {
        console.log('Disabling Wi-Fi.');
        await Network.get().setInterfaceEnabled('WIFI', false).then(result => {
          if (result) {
            this.wifiStatus = false;
            this.tag('Networks').visible = false;
            this.tag('JoinAnotherNetwork').visible = false;
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          } else {
            console.error("setInterfaceEnabled WIFI false returned error: " + JSON.stringify(result));
          }
        });
      } else {
        console.log('Enabling Wi-Fi.');
        await Network.get().isInterfaceEnabled("WIFI").then(ifaceStatus => {
          if (!ifaceStatus) {
            this.onInterfaceStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onInterfaceStatusChanged', ifaceStatus => {
              if (ifaceStatus.interface === "WIFI" && ifaceStatus.enabled) {
                this.onInterfaceStatusChangedCB.dispose();
                this.wifiStatus = true;
                this.tag('Networks').visible = true;
                this.tag('JoinAnotherNetwork').visible = true;
                this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
                Wifi.get().startScan();
                this.wifiLoading.play();
                this.tag('Switch.Loader').visible = true;
              }
            });
            Network.get().setInterfaceEnabled("WIFI");
          } else {
            this.wifiStatus = true;
            this.tag('Networks').visible = true;
            this.tag('JoinAnotherNetwork').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            Wifi.get().startScan();
            this.wifiLoading.play();
            this.tag('Switch.Loader').visible = true;
          }
          this.pairedDevices();
        });
      }
    }
    wifiEventHandlers() {
      this.onWIFIStateChangedCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onWIFIStateChanged', notification => {
        if (this.renderSSIDS.length) {
          this.renderDeviceList(this.renderSSIDS);
        }
        if (notification.state === WiFiState.CONNECTED) {
          Wifi.get().getConnectedSSID().then(result => {
            PersistentStoreApi.get().setValue('wifi', 'SSID', result.ssid).then(response => {
              console.log(response);
            });
          });
        }
      });
      this.onErrorCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onError', notification => {
        if (notification.code === WiFiError.INVALID_CREDENTIALS) {
          Wifi.get().clearSSID();
        }
        if (this.renderSSIDS.length) {
          this.renderDeviceList(this.renderSSIDS);
        }
        if (this.widgets) {
          this.widgets.fail.notify({
            title: 'WiFi Error',
            msg: WiFiErrorMessages[notification.code]
          });
          Router.focusWidget('Fail');
        }
      });
      this.onAvailableSSIDsCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onAvailableSSIDs', notification => {
        console.log("Notification[onAvailableSSIDs]: found " + JSON.stringify(notification.ssids.length));
        this.ssids = [...this.ssids, ...notification.ssids];
        if (!notification.moreData) {
          this.renderSSIDS = this.ssids;
          this.ssids = [];
          this.renderDeviceList(this.renderSSIDS);
          setTimeout(() => {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
        if (!notification.ssids.length) {
          console.log("onAvailableSSIDs length is ZERO; scanning again.");
          Network.get().isInterfaceEnabled("WIFI").then(enabled => {
            if (enabled) {
              Wifi.get().startScan();
              this.wifiLoading.play();
              this.tag('Switch.Loader').visible = true;
            }
          });
        }
      });
    }
    _inactive() {
      previousFocusedItemSSid = undefined;
      this.onWIFIStateChangedCB.dispose();
      this.onErrorCB.dispose();
      this.onAvailableSSIDsCB.dispose();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2023 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance$2 = null;
  class RCApi {
    constructor() {
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      // this.INFO = console.info;
      // this.LOG = console.log;
      this.INFO = function () {};
      this.LOG = function () {};
      this.ERR = console.error;
    }
    static get() {
      if (instance$2 == null) {
        instance$2 = new RCApi();
      }
      return instance$2;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: activate.");
        this.thunder.Controller.activate({
          callsign: 'org.rdk.RemoteControl'
        }).then(() => {
          resolve(true);
        }).catch(err => {
          this.ERR('RCApi: Error Activation ', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error while Thunder Controller RemoteControl activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.Controller.deactivate({
          callsign: 'org.rdk.RemoteControl'
        }).then(() => {
          this.INFO("RCApi: deactivated org.rdk.RemoteControl");
          resolve(true);
        }).catch(err => {
          this.ERR('RCApi: Error deactivation ', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error while Thunder Controller RemoteControl deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getApiVersionNumber() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: getApiVersionNumber");
        this.thunder.call('org.rdk.RemoteControl', 'getApiVersionNumber').then(result => {
          this.INFO("RCApi: getApiVersionNumber result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("RCApi: getApiVersionNumber error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl getApiVersionNumber " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getNetStatus() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: getNetStatus of netType:", netType);
        this.thunder.call('org.rdk.RemoteControl', 'getNetStatus', {
          netType: netType
        }).then(result => {
          this.INFO("RCApi: getNetStatus result: ", JSON.stringify(result));
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR("RCApi: getNetStatus error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl getNetStatus " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    startPairing() {
      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      let netType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return new Promise((resolve, reject) => {
        //this.INFO("RCApi: startPairing netType " + netType + " timeout " + timeout);
        this.thunder.call('org.rdk.RemoteControl', 'startPairing', {
          netType: netType,
          timeout: timeout
        }).then(result => {
          //this.INFO("RCApi: startPairing result: ", JSON.stringify(result))
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: startPairing error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl startPairing " + JSON.stringify(err), false, null);
          reject(err);
        });
        resolve(true);
      });
    }
    initializeIRDB() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    clearIRCodes() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    setIRCode() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    getIRCodesByAutoLookup() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    getIRCodesByNames() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    getIRDBManufacturers() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    getIRDBModels() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    getLastKeypressSource() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "NotImplemented", false, null);
        reject("NotImplemented");
      });
    }
    configureWakeupKeys() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let wakeupConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "custom";
      let customKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "3,1";
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: configureWakeupKeys netType:" + netType + " wakeupConfig:" + wakeupConfig + " customKeys:" + customKeys);
        this.thunder.call('org.rdk.RemoteControl', 'configureWakeupKeys', {
          netType: netType,
          wakeupConfig: wakeupConfig,
          customKeys: customKeys
        }).then(result => {
          this.INFO("RCApi: configureWakeupKeys result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: configureWakeupKeys error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl configureWakeupKeys " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    findMyRemote() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "mid";
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: findMyRemote netType:" + netType + " level:" + level);
        this.thunder.call('org.rdk.RemoteControl', 'findMyRemote', {
          netType: netType,
          level: level
        }).then(result => {
          this.INFO("RCApi: findMyRemote result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: findMyRemote error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl findMyRemote " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    factoryReset() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: factoryReset");
        this.thunder.call('org.rdk.RemoteControl', 'factoryReset').then(result => {
          this.INFO("RCApi: factoryReset result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: factoryReset error:", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "RemoteControlApiError", "Error in Thunder RemoteControl factoryReset " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _thunder$1 = thunderJS$1(CONFIG.thunderConfig);
  let onStatusCBhandle = null;
  class RCInformationScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Bluetooth Voice Remote Control'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: 0xCC000000,
        DeviceInfoContents: {
          x: 200,
          y: 275,
          Line1: {
            y: 0,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          MacAddress: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("MacAddress"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 45,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line2: {
            y: 90,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          RCUName: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("RCU Name"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 135,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line3: {
            y: 180,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          Status: {
            Title: {
              x: 10,
              y: 225,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Connection Status"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 225,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line4: {
            y: 270,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          BatteryPercent: {
            Title: {
              x: 10,
              y: 315,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Battery percent'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1600,
                wordWrap: true,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 315,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1200,
                wordWrap: true,
                fontSize: 25
              }
            }
          },
          Line5: {
            y: 360,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SwVersion: {
            Title: {
              x: 10,
              y: 405,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Software Version"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 405,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line6: {
            y: 450,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          }
        }
      };
    }
    async _active() {
      await RCApi.get().activate().catch(err => {
        console.error("RCInformationScreen error:", err);
      });
      await RCApi.get().getNetStatus().then(result => {
        console.info("RCInformationScreen getNetStatus:", result);
        onStatusCBhandle = _thunder$1.on('org.rdk.RemoteControl', 'onStatus', data => {
          this.onStatusCB(data);
        });
        this.onStatusCB(result);
      }).catch(err => console.error("RCInformationScreen error:", err));
    }
    _inactive() {
      console.warn("RCInformationScreen _inactive.");
      onStatusCBhandle.dispose();
      this.tag("Status.Value").text.text = "N/A";
      this.tag("MacAddress.Value").text.text = "N/A";
      this.tag("SwVersion.Value").text.text = "N/A";
      this.tag("BatteryPercent.Value").text.text = "N/A";
      this.tag("RCUName.Value").text.text = "N/A";
      //RCApi.get().deactivate().catch(err=> { console.error("RCInformationScreen error:", err)});
    }
    onStatusCB(cbData) {
      // getStatus response has 'success' property; notification payload does not have that.
      if (cbData !== undefined && ("success" in cbData ? cbData.success : true)) {
        if (cbData.status.remoteData.length) {
          console.log("RCInformationScreen rcPairingApis RemoteData Length", cbData.status.remoteData.length);
          let RemoteName = [];
          let connectedStatus = [];
          let MacAddress = [];
          let swVersion = [];
          let BatteryPercent = [];
          cbData.status.remoteData.map(item => {
            RemoteName.push(item.name);
          });
          cbData.status.remoteData.map(item => {
            MacAddress.push(item.macAddress);
          });
          cbData.status.remoteData.map(item => {
            swVersion.push(item.swVersion);
          });
          cbData.status.remoteData.map(item => {
            BatteryPercent.push(item.batteryPercent);
          });
          cbData.status.remoteData.map(item => {
            connectedStatus.push(item.connected);
          });
          this.tag("Status.Value").text.text = connectedStatus;
          this.tag("MacAddress.Value").text.text = MacAddress;
          this.tag("SwVersion.Value").text.text = swVersion;
          this.tag("BatteryPercent.Value").text.text = BatteryPercent;
          this.tag("RCUName.Value").text.text = RemoteName;
        } else {
          if (cbData.status.pairingState != "SEARCHING" && cbData.status.pairingState != "PAIRING") {
            RCApi.get().startPairing(30).catch(err => {
              console.err("RCInformationScreen startPairing error:", err);
            });
          }
        }
      }
    }
    _focus() {
      this._setState("RCInformationScreen");
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > 215) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 275) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const networkRoutes = [{
    path: 'settings/network',
    component: NetworkConfigurationScreen$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/info',
    component: NetworkInfo$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface',
    component: NetworkInterfaceScreen$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi',
    component: WiFiScreen$1,
    widgets: ['Menu', 'Fail', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi/connect',
    component: WifiPairingScreen$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi/another',
    component: JoinAnotherNetworkComponent$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth',
    component: BluetoothScreen$2,
    widgets: ['Menu', 'Fail', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth/pairing',
    component: BluetoothPairingScreen$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth/RCVolumeInfoScreen',
    component: RCInformationScreen,
    widgets: ["Menu", 'Volume', "Fail", "AppCarousel"]
  }];
  var route$1 = {
    network: networkRoutes
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Variable to store the timer
   */
  var timeout;

  /**
   * Class to render the UI controls for the video player.
   */
  class LightningPlayerControls extends lng$1.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        TimeBar: {
          x: 90,
          y: 93.5,
          texture: lng$1.Tools.getRoundRect(1740, 20, 10, 0, 0, true, 0xffffffff)
        },
        ProgressWrapper: {
          x: 90,
          y: 93.5,
          w: 0,
          h: 35,
          clipping: true,
          ProgressBar: {
            texture: lng$1.Tools.getRoundRect(1740, 20, 10, 0, 0, true, CONFIG.theme.hex)
            // x: 90,
            // y: 93.5,
          }
        },
        Duration: {
          x: 1690,
          y: 125,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: 0xffFFFFFF
          }
        },
        CurrentTime: {
          x: 140,
          // 140 = 90 + 50 | 50 is approzimately 1/2 of length(in px) of the text "00:00:00" and 90 is padding from left
          y: 60,
          mountX: 0.5,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffFFFFFF
          }
        },
        Buttons: {
          x: 820,
          y: 125,
          children: [{
            src: Utils.asset('images/player/rewind.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Back_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Pause_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Next_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/player/fast-forward.png'),
            x: 17,
            y: 17
          }].map((item, idx) => ({
            x: idx * 75,
            // texture: Lightning.Tools.getRoundRect(80, 80, 40, 0, 0, true, 0xff8e8e8e),
            ControlIcon: {
              x: item.x,
              y: item.y,
              texture: lng$1.Tools.getSvgTexture(item.src, 50, 50)
            }
          }))
        }
      };
    }
    _activate() {
      /**
       * Variable to store the duration of the video content.
       */
      this.videoDuration = 0;
      this.tag('Buttons').children[1].patch({
        alpha: 1
      });
      this.tag('Buttons').children[3].patch({
        alpha: 1
      });
      this.toggle = false;
    }

    /**
     * Function to set focus to player controls when the player controls are shown.
     */
    _focus() {
      this._index = 1;
      this._setState('PlayPause');
    }

    /**
     * Function to handle the player controls when they are hidden.
     */
    _unfocus() {
      this._setState('Hidden');
      clearTimeout(timeout);
    }
    reset() {
      this.toggle = false;
    }
    /**
     * Function to set the duration of the video.
     * @param {String} duration video duration to be set.
     */
    set duration(duration) {
      console.log("duration was set = ".concat(duration));
      this.videoDuration = duration;
      this.tag('Duration').text.text = this.SecondsTohhmmss(duration);
    }

    /**
     * Function to set the current video time.
     * @param {String} currentTime current time to be set.
     */
    set currentTime(currentTime) {
      let value = 1740 * currentTime / this.videoDuration;
      this.tag('ProgressWrapper').patch({
        w: value
      });
      this.tag('CurrentTime').text.text = this.SecondsTohhmmss(currentTime);
      if (value >= 50 && value <= 1690) {
        // 1740 - 50 = 1690
        this.tag('CurrentTime').x = 90 + value; //90 is padding from left
      } else if (currentTime === 0) {
        this.tag('CurrentTime').x = 140; //initial position 140 = 90 + 50
      }
    }

    /**
     * Function to convert time in seconds to hh:mm:ss format.
     * @param {String} totalSeconds time in seconds.
     */
    SecondsTohhmmss(totalSeconds) {
      this.hours = Math.floor(totalSeconds / 3600);
      this.minutes = Math.floor((totalSeconds - this.hours * 3600) / 60);
      this.seconds = totalSeconds - this.hours * 3600 - this.minutes * 60;
      this.seconds = Math.round(totalSeconds) - this.hours * 3600 - this.minutes * 60;
      this.result = this.hours < 10 ? '0' + this.hours : this.hours;
      this.result += ':' + (this.minutes < 10 ? '0' + this.minutes : this.minutes);
      this.result += ':' + (this.seconds < 10 ? '0' + this.seconds : this.seconds);
      return this.result;
    }

    /**
     * Function to hide player controls.
     */
    hideLightningPlayerControls() {
      this.signal('hide');
    }
    hideNextPrevious() {
      this.isChannel = true;
      this.tag('Buttons').children[1].visible = false;
      this.tag('Buttons').children[3].visible = false;
    }
    showNextPrevious() {
      this.isChannel = false;
      this.tag('Buttons').children[1].visible = true;
      this.tag('Buttons').children[3].visible = true;
    }
    /**
     * Timer function to track the inactivity of the player controls.
     */
    timer() {
      clearTimeout(timeout);
      timeout = setTimeout(this.hideLightningPlayerControls.bind(this), 5000);
    }

    /**
     * Function that defines the different states of the player controls.
     */
    static _states() {
      return [class PlayPause extends this {
        $enter() {
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        $exit() {
          this.unfocus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_White_16k.png') : Utils.asset('images/Media Player/Icon_Pause_White_16k.png');
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.unfocus, 50, 50)
          });
        }
        _handleEnter() {
          if (this.toggle) {
            //this.fireAncestors('$play');
            this.signal('play');
          } else {
            //this.fireAncestors('$pause');
            this.signal('pause');
          }
          this.toggle = !this.toggle;
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        _handleRight() {
          if (!this.isChannel) {
            this._setState('Forward');
          } else {
            this._setState('seekFwd');
          }
        }
        _handleLeft() {
          if (!this.isChannel) {
            this._setState('Rewind');
          } else {
            this._setState('seekRwd');
          }
        }
        _getFocused() {
          this.timer();
        }
      }, class Forward extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[3].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[3].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_White_16k.png'), 50, 50)
          });
        }
        _handleRight() {
          this._setState('seekFwd');
        }
        _handleLeft() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('nextTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class Rewind extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_White_16k.png'), 50, 50)
          });
        }
        _handleLeft() {
          this._setState('seekRwd');
        }
        _handleRight() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('prevTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class seekFwd extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[4].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/SeekFwd.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[4].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/player/fast-forward.png'), 50, 50)
          });
        }
        _handleLeft() {
          if (!this.isChannel) {
            this._setState('Forward');
          } else {
            this._setState('PlayPause');
          }
        }
        _handleRight() {}
        _handleEnter() {
          this.toggle = false;
          this.signal('seekFwd');
        }
        _getFocused() {
          this.timer();
        }
      }, class seekRwd extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/Media Player/SeekRwd.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: lng$1.Tools.getSvgTexture(Utils.asset('images/player/rewind.png'), 50, 50)
          });
        }
        _handleLeft() {}
        _handleRight() {
          if (!this.isChannel) {
            this._setState('Rewind');
          } else {
            this._setState('PlayPause');
          }
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('seekRwd');
        }
        _getFocused() {
          this.timer();
        }
      }, class Hidden extends this {
        _getFocused() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem$1 extends lng$1.Component {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 232,
          h: 81
        },
        BottomLine: {
          y: 81,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    set item(item) {
      //  this.shows = item.shows;
      this._item = item;
      this.tag('Item').patch({
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.index + 1 + "\t\t\t\t" + item.shortname,
            fontFace: CONFIG.language.font,
            fontSize: 21,
            textColor: 0xffFFFFFF,
            wordWrap: false,
            wordWrapWidth: 232 - 20,
            maxLines: 1,
            textOverflow: '...'
          } // update the text
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.tag('TopLine').h = 5;
      this.tag('BottomLine').h = 5;
      this.tag('Item.Title').text.fontStyle = "bold";
      this.patch({
        zIndex: 2
      });
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
      this.tag('Item.Title').text.fontStyle = "normal";
      this.patch({
        zIndex: 1
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelOverlay extends lng$1.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        Wrapper: {
          x: -235,
          y: 90,
          clipping: true,
          w: 232,
          h: 900,
          Channels: {
            y: 5,
            w: 232,
            h: 891,
            type: lng$1.components.ListComponent,
            // clipping:true,
            itemSize: 81,
            roll: true,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -10
          }
        }
      };
    }
    _init() {
      this.activeChannelIdx = 0; //this must be initialised in init
    }
    _firstEnable() {
      this.homeApi = new HomeApi();
      this.dtvApi = new DTVApi();
      this.appApi = new AppApi();
      this.options = [];
      this.overlayTimeout = null;
      this.timeoutDuration = 10000;
      this.dtvApi.serviceList().then(async channels => {
        await this.homeApi.checkChannelComapatability(channels).then(res => {
          channels = res;
        });
        this.options = channels;
        this.tag('Channels').items = this.options.map((item, index) => {
          return {
            type: ChannelItem$1,
            index: index,
            item: item,
            ref: "Channel" + index
          };
        });
      }).catch(err => {
        console.log("Failed to fetch channels: ", JSON.stringify(err));
      });
      this._overlayAnimation = this.tag("Wrapper").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -235,
            1: 0
          }
        }]
      });
    }
    _focus() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
      this.$focusChannel(this.activeChannelIdx);
      this._overlayAnimation.start();
    }
    _unfocus() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this._overlayAnimation.stop();
    }
    resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $focusChannel(index) {
      this.activeChannelIdx = index;
      this.tag('Channels').setIndex(this.activeChannelIdx);
    }
    _getFocused() {
      return this.tag('Channels').element; // add logic to focus on current channel
    }
    _handleDown() {
      this.resetTimeout();
      this.tag('Channels').setNext();
    }
    _handleUp() {
      this.resetTimeout();
      this.tag('Channels').setPrevious();
    }
    _handleBack() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }
      Router.focusPage();
    }
    _handleLeft() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }
      Router.focusPage();
    }
    _handleRight() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }
      Router.focusPage();
    }
    _handleEnter() {
      this.resetTimeout();
      let focusedChannelIdx = this.tag("Channels").index;
      let channel = this.options[focusedChannelIdx];
      if (channel.dvburi === "OTT") {
        let params = {
          launchLocation: "epgScreen",
          url: channel.url
        };
        this.appApi.launchApp(channel.callsign, params).then(() => {
          this.dtvApi.exitChannel();
        }).catch(() => {
          this.dtvApi.exitChannel(); //to exit previous channel regardless the app launch succeeds or fails
        });
      } else if (channel.dvburi.startsWith("C_")) {
        if (!Router.isNavigating()) {
          let playerParams = {
            url: channel.iptvuri,
            //video url for playing
            isChannel: true,
            channelName: channel.channelName,
            showName: "sample show name",
            showDescription: "sample description",
            channelIndex: focusedChannelIdx
          };
          if (Router.getActiveHash() === "player") {
            this.activeChannelIdx = focusedChannelIdx;
            this.fireAncestors("$changeChannel", channel.iptvuri, playerParams.showName, playerParams.channelName);
          } else {
            Router.navigate("player", playerParams);
          }
        }
      } else {
        if (focusedChannelIdx !== this.activeChannelIdx) {
          this.dtvApi.exitChannel().then(res => {
            console.log("Current channel exit successful, launching new channel: ", JSON.stringify(res));
            this.dtvApi.launchChannel(this.options[focusedChannelIdx].dvburi).then(res => {
              console.log("Change Channel successfull: ", JSON.stringify(res));
              this.activeChannelIdx = focusedChannelIdx;
            }).catch(err => {
              console.log("Failed to launch new channel", JSON.stringify(err));
            });
          }).catch(err => {
            console.log("Failed to exit current playing channel: ", JSON.stringify(err));
          });
        }
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let player = null;
  let position = null;
  /**
   * Class to render AAMP video player.
   */
  class AAMPVideoPlayer extends lng$1.Component {
    /**
     * Function to render player controls.
     */

    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      if (args.isUSB) {
        this.isUSB = args.isUSB;
      } else if (args.isChannel) {
        this.isChannel = args.isChannel;
        this.channelName = args.channelName;
        this.showName = args.showName;
        this.showDescription = args.description;
        this.channelIndex = args.channelIndex;
      }
      let url = args.url ? args.url : 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8';
      if (args.isAudio) {
        this.tag('Image').alpha = 1;
      }
      try {
        this.load({
          title: 'Parkour event',
          url: url,
          drmConfig: null
        });
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
        Metrics$3.error(Metrics$3.ErrorType.MEDIA, "PlaybackError", "Playback Failed" + JSON.stringify(error), false, null);
      }
    }
    static _template() {
      return {
        Image: {
          alpha: 0,
          x: 960,
          y: 560,
          mount: 0.5,
          texture: {
            type: lng$1.textures.ImageTexture,
            src: 'static/images/Media Player/Audio_Background_16k.jpg',
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        InfoOverlay: {
          x: 90,
          y: 820,
          alpha: 0,
          zIndex: 3,
          ShowName: {
            text: {
              text: "Show Name",
              fontFace: CONFIG.language.font,
              fontSize: 48,
              fontStyle: 'bold',
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          },
          ChannelName: {
            y: 50,
            visible: false,
            text: {
              text: "Channel Name",
              fontFace: CONFIG.language.font,
              fontSize: 35,
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          }
        },
        PlayerControlsWrapper: {
          alpha: 0,
          h: 330,
          w: 1920,
          y: 750,
          rect: true,
          colorBottom: 0xFF000000,
          colorTop: 0x00000000,
          PlayerControls: {
            y: 70,
            type: LightningPlayerControls,
            signals: {
              pause: 'pause',
              play: 'play',
              hide: 'hidePlayerControls',
              fastfwd: 'fastfwd',
              fastrwd: 'fastrwd',
              nextTrack: 'nextTrack',
              prevTrack: 'prevTrack',
              seekFwd: 'seekFwd',
              seekRwd: 'seekRwd'
            }
          }
        },
        ChannelWrapper: {
          h: 1080,
          w: 350,
          x: -360,
          rect: true,
          colorLeft: 0xFF000000,
          colorRight: 0x00000000,
          ChannelOverlay: {
            type: ChannelOverlay,
            x: 50,
            y: 92
          }
        }
      };
    }
    _init() {
      this.x = 0;
      this.y = 0;
      this.w = 0;
      this.h = 0;
      this.videoEl = document.createElement('video');
      this.videoEl.setAttribute('id', 'video-player');
      this.videoEl.style.position = 'absolute';
      this.videoEl.style.zIndex = '1';
      this.videoEl.setAttribute('width', '100%');
      this.videoEl.setAttribute('height', '100%');
      this.videoEl.setAttribute('type', 'video/ave');
      document.body.appendChild(this.videoEl);
      this.playbackSpeeds = [-16, -8, -4, -2, 1, 2, 4, 8, 16];
      this.playerStatesEnum = {
        idle: 0,
        initializing: 1,
        playing: 8,
        paused: 6,
        seeking: 7
      };
      player = null;
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
      this.defaultInitConfig = {
        initialBitrate: 2500000,
        offset: 0,
        networkTimeout: 10,
        preferredAudioLanguage: 'en',
        liveOffset: 15,
        drmConfig: null
      };
    }

    /**
     * Function to set video coordinates.
     * @param {int} x x position of video
     * @param {int} y y position of video
     * @param {int} w width of video
     * @param {int} h height of video
     */
    setVideoRect(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }

    /**
     * Event handler to store the current playback state.
     * @param  event playback state of the video.
     */
    _playbackStateChanged(event) {
      switch (event.state) {
        case player.playerStatesEnum.idle:
          this.playerState = player.playerStatesEnum.idle;
          break;
        case player.playerStatesEnum.initializing:
          this.playerState = player.playerStatesEnum.initializing;
          break;
        case player.playerStatesEnum.playing:
          this.playerState = player.playerStatesEnum.playing;
          break;
        case player.playerStatesEnum.paused:
          this.playerState = player.playerStatesEnum.paused;
          break;
        case player.playerStatesEnum.seeking:
          this.playerState = player.playerStatesEnum.seeking;
          break;
      }
    }

    /**
     * Event handler to handle the event of completion of a video playback.
     */
    _mediaEndReached() {
      this.load(this.videoInfo);
      this.setVideoRect(this.x, this.y, this.w, this.h);
    }

    /**
     * Event handler to handle the event of changing the playback speed.
     */
    _mediaSpeedChanged() {}

    /**
     * Event handler to handle the event of bit rate change.
     */
    _bitrateChanged() {}

    /**
     * Function to handle the event of playback failure.
     */
    _mediaPlaybackFailed() {
      this.load(this.videoInfo);
    }

    /**
     * Function to handle the event of playback progress.
     * @param event playback event.
     */
    _mediaProgressUpdate(event) {
      position = event.positionMiliseconds / 1000;
      this.tag('PlayerControls').currentTime = position;
    }

    /**
     * Function to handle the event of starting the playback.
     */
    _mediaPlaybackStarted() {
      this.tag('PlayerControls').reset();
      this.showPlayerControls();
      if (this.isUSB) {
        this.tag("InfoOverlay").setSmooth('alpha', 1);
      }
    }

    /**
     * Function to handle the event of change in the duration of the playback content.
     */
    _mediaDurationChanged() {}

    /**
     * Function to create the video player instance for video playback and its initial settings.
     */
    createPlayer() {
      if (player !== null) {
        this.destroy();
        player = null;
      }
      try {
        player = new AAMPMediaPlayer();
        player.addEventListener('playbackStateChanged', this._playbackStateChanged);
        player.addEventListener('playbackCompleted', this._mediaEndReached.bind(this));
        player.addEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
        player.addEventListener('bitrateChanged', this._bitrateChanged);
        player.addEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
        player.addEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
        player.addEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
        player.addEventListener('durationChanged', this._mediaDurationChanged);
        this.playerState = this.playerStatesEnum.idle;
      } catch (error) {
        console.error('AAMPMediaPlayer is not defined');
        Metrics$3.error(Metrics$3.ErrorType.MEDIA, "PlaybackError", "AAMPMediaPlayer is not defined" + JSON.stringify(error), false, null);
      }
    }

    /**
     * Loads the player with video URL.
     * @param videoInfo the url and the info regarding the video like title.
     */
    load(videoInfo) {
      this.createPlayer();
      this.videoInfo = videoInfo;
      this.configObj = this.defaultInitConfig;
      this.configObj.drmConfig = this.videoInfo.drmConfig;
      player.initConfig(this.configObj);
      player.load(videoInfo.url);
      this.tag('PlayerControls').title = videoInfo.title;
      this.tag('PlayerControls').duration = player.getDurationSec();
      console.log('Duration of video', player.getDurationSec());
      this.tag('PlayerControls').currentTime = 0;
      this.play();
    }

    /**
     * Starts playback when enough data is buffered at play head.
     */
    play() {
      player.play();
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
    }

    /**
     * Pauses playback.
     */
    pause() {
      player.pause();
    }

    /**
     * Stop playback and free resources.
     */
    stop() {
      player.stop();
      this.hidePlayerControls();
    }
    $changeChannel(url, showName, channelName) {
      this.stop();
      this.destroy();
      try {
        this.load({
          title: showName,
          url: url,
          drmConfig: null
        });
        this.tag('ShowName').text.text = showName;
        this.tag('ChannelName').text.text = channelName;
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
        Metrics$3.error(Metrics$3.ErrorType.MEDIA, "PlaybackError", "Playback Failed " + JSON.stringify(error), false, null);
      }
    }
    seekFwd() {
      player.seek(position + 10);
    }
    seekRwd() {
      player.seek(position - 10);
    }
    voiceSeek(time) {
      player.seek(position + time);
    }
    nextTrack() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
          Metrics$3.error(Metrics$3.ErrorType.MEDIA, "PlaybackError", 'Playback Failed ' + JSON.stringify(error), false, null);
        }
      }
    }
    prevTrack() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
          Metrics$3.error(Metrics$3.ErrorType.MEDIA, "PlaybackError", 'Playback Failed ' + JSON.stringify(error), false, null);
        }
      }
    }

    /**
     * Function to perform fast forward of the video content.
     */
    fastfwd() {
      if (this.playbackRateIndex < this.playbackSpeeds.length - 1) {
        this.playbackRateIndex++;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      player.setPlaybackRate(this.rate);
    }

    /**
     * Function to perform fast rewind of the video content.
     */
    fastrwd() {
      if (this.playbackRateIndex > 0) {
        this.playbackRateIndex--;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      player.setPlaybackRate(this.rate);
    }

    /**
     * Function that returns player instance.
     * @returns player instance.
     */
    getPlayer() {
      return player;
    }

    /**
     * Function to release the video player instance when not in use.
     */
    destroy() {
      if (player.getCurrentState() !== this.playerStatesEnum.idle) {
        player.stop();
      }
      player.removeEventListener('playbackStateChanged', this._playbackStateChanged);
      player.removeEventListener('playbackCompleted', this._mediaEndReached);
      player.removeEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
      player.removeEventListener('bitrateChanged', this._bitrateChanged);
      player.removeEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
      player.removeEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
      player.removeEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
      player.removeEventListener('durationChanged', this._mediaDurationChanged);
      player.release();
      player = null;
      this.hidePlayerControls();
    }

    /**
     * Function to hide the player controls.
     */
    hidePlayerControls() {
      this.tag('PlayerControlsWrapper').setSmooth('y', 1080, {
        duration: 0.7
      });
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 0, {
        duration: 0.7
      });
      this._setState('HideControls');
      this.hideInfo();
    }

    /**
     * Function to show the player controls.
     */
    showPlayerControls() {
      // this.tag('PlayerControls').reset()
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 1);
      this.tag('PlayerControlsWrapper').setSmooth('y', 750, {
        duration: 0.7
      });
      this._setState('ShowControls');
      this.timeout = setTimeout(this.hidePlayerControls.bind(this), 5000);
    }
    showInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 1, {
          duration: 0.3,
          delay: 0.7
        });
      }
    }
    hideInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 0, {
          duration: 0.3
        });
      }
    }
    updateInfo() {
      if (this.isUSB) {
        this.tag('ShowName').text.text = this.data[this.currentIndex].data.displayName;
      } else if (this.isChannel) {
        this.tag('ShowName').text.text = this.showName;
        this.tag('ChannelName').text.text = this.channelName;
      }
    }
    /**
     * Function to display player controls on down key press.
     */

    /**
     *Function to hide player control on up key press.
     */

    _handleBack() {
      Router.back();
    }
    _inactive() {
      this.tag('Image').alpha = 0;
      this.tag('InfoOverlay').alpha = 0;
      this.isUSB = false;
      this.isChannel = false;
      this.tag('PlayerControls').reset();
      this.stop();
      this.destroy();
    }
    _focus() {
      this._setState('HideControls');
      this.updateInfo();
      if (this.isChannel) {
        this.tag('ChannelOverlay').$focusChannel(this.channelIndex);
        this.tag('InfoOverlay').y = 790;
        this.tag('ChannelName').visible = true;
        this.tag('PlayerControls').hideNextPrevious();
      } else {
        this.tag('InfoOverlay').y = 820;
        this.tag('ChannelName').visible = false;
        this.tag('PlayerControls').showNextPrevious();
      }
      if (this.data == undefined || this.data.length <= 1) {
        this.tag('PlayerControls').hideNextPrevious();
      }
    }
    /**
     * Function to define the different states of the video player.
     */
    static _states() {
      return [class ShowControls extends this {
        _getFocused() {
          return this.tag('PlayerControls');
        }
        _handleDown() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleUp() {
          if (this.isChannel) {
            this.hidePlayerControls();
            this._setState('ChannelOverlay');
          }
        }
      }, class HideControls extends this {
        // _handleBack(){
        //   console.log('go back from hidecontrol')
        // }
        _handleUp() {
          // this.tag('PlayerControlsWrapper').setSmooth('alpha', 1, { duration: 1 })
          // this.tag('PlayerControlsWrapper').setSmooth('y', 820, { duration: 1 })
          this.showPlayerControls();
          this._setState('ShowControls');
          this.showInfo();
          clearTimeout(this.timeout);
        }
        _handleLeft() {
          if (this.isChannel) {
            this._setState('ChannelOverlay');
          }
        }
      }, class ChannelOverlay extends this {
        $enter() {
          this.tag('ChannelWrapper').setSmooth('x', 0, {
            duration: 1
          });
        }
        $exit() {
          this.tag('ChannelWrapper').setSmooth('x', -360, {
            duration: 1
          });
        }
        _handleLeft() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleRight() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleBack() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _getFocused() {
          return this.tag('ChannelOverlay');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            //  alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            //alpha: 0.3, // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + Language$1.translate(standbyMode);
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + text;
    }
    $screenSaverTime(text) {
      this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + text;
    }
    _focus() {
      this._setState(this.state);
      if (Storage$1.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + Storage$1.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        let currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + Language$1.translate(currentStandbyMode);
      });
      if (Storage$1.get('ScreenSaverTimeoutInterval')) {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + Storage$1.get('ScreenSaverTimeoutInterval') + ' min';
      } else {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + 'Off';
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          // this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('ScreenSaver');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/timer');
          }
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/ScreenSaver');
          }
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('ScreenSaver');
        }
        _handleDown() {
          // this._setState('Theme')
          this._setState('Language');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/energy');
          }
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/language');
          }
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('Language');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/privacy');
          }
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          // this._setState('SleepTimer')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Sleep Timer'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: lng$1.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(() => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error('error while registering the inactivity monitoring event' + JSON.stringify(err));
      });
      this._setState('Options');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });
          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      let self = this;
      let standbyMode = "";
      if (this._item === Language$1.translate("Deep Sleep")) {
        standbyMode = "DEEP_SLEEP";
      } else if (this._item === Language$1.translate("Light Sleep")) {
        standbyMode = "LIGHT_SLEEP";
      }
      this.appApi.setPreferredStandbyMode(standbyMode).then(result => {
        console.log("setPreferredStandbyMode " + JSON.stringify(result));
        self.fireAncestors("$resetPrevTickObject", self);
        this.fireAncestors("$updateStandbyMode", this._item);
        self.tag("Item.Tick").visible = true;
      });
    }
    set item(item) {
      this._item = item;
      let self = this;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: self.isTicked ? true : false //implement the logic to show the tick
        },
        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Energy Saver'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }
    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language$1.translate("Deep Sleep"), Language$1.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      var standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language$1.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language$1.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class LanguageItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}

    /**
     * Function to set contents of an item in the Language screen.
     */
    set item(item) {
      // console.log(item)
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          w: 32.5,
          h: 32.5,
          src: Utils.asset('images/settings/Tick.png'),
          color: 0xffffffff,
          visible: Language$1.get() === item ? true : item === 'en' && Language$1.get() === null ? true : false
        },
        Left: {
          x: 60,
          y: 45,
          mountY: 0.5,
          text: {
            text: Language$1.translate(item),
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$b = new AppApi();
  const thunder$f = thunderJS$1(CONFIG.thunderConfig);
  const loader$2 = 'Loader';
  class LanguageScreen$2 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Language'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: lng$1.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _active() {
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        this.OnLanguageChangedfirebolt = FireBoltApi.get().localization.listen("languageChanged", value => {
          console.log('language changed successfully', value);
        });
      }
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$b.deactivateResidentApp(loader$2);
      rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
      rdkShellApisInstance.setFocus(GLOBALS.selfClientName).then(result => {
        console.log('LanguageScreen: ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('LanguageScreen: Error', err);
        Metrics$2.error(Metrics$2.ErrorType.OTHER, "AppLangugaeError", 'Thunder RDKShell setFocus Error' + JSON.stringify(err), false, null);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          if (Language$1.get() !== availableLanguages[this._Languages.tag('List').index]) {
            let updatedLanguage = availableLanguageCodes[availableLanguages[this._Languages.tag('List').index]];
            if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError") {
              AlexaApi.get().getAlexaDeviceSettings();
              thunder$f.on('org.rdk.VoiceControl', 'onServerMessage', notification => {
                if (notification.xr_speech_avs.deviceSettings.currentLocale.toString() != updatedLanguage) {
                  for (let i = 0; i < notification.xr_speech_avs.deviceSettings.supportedLocales.length; i++) {
                    if (updatedLanguage === notification.xr_speech_avs.deviceSettings.supportedLocales[i].toString()) {
                      AlexaApi.get().updateDeviceLanguageInAlexa(updatedLanguage);
                    }
                  }
                }
              });
            }
            if ("ResidentApp" === GLOBALS.selfClientName) {
              appApi$b.setUILanguage(updatedLanguage);
            } else {
              FireBoltApi.get().localization.setlanguage(availableLanguages[this._Languages.tag('List').index]).then(res => console.log("sucess language set ::::", res));
            }
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            appApi$b.launchResident(notification_url, loader$2).catch(err => {
              console.error("error while launching loader url in resident app", err);
            });
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Privacy Screen.
   */

  const xcastApi$2 = new XcastApi();
  let cookieToggle = false;
  class PrivacyScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Privacy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    checkUSBDeviceStatus() {
      if (!Storage$1.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage$1.set('UsbMedia', 'ON');
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi$2.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi$2.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi$2.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi$2.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active');
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          // this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage$1.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(res => {
              Storage$1.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(res => {
              Storage$1.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          //
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          cookieToggle = !cookieToggle;

          //TOGGLE BUTTON
          if (cookieToggle) {
            this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate('In Progress');
          } else {
            this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
          }
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
          setTimeout(() => {
            AlexaApi.get().resetAVSCredentials().then(result => {
              console.log("Triggering AVS credential reset.", result);
              if (result.success) {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
                this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate('Finished');
                setTimeout(() => {
                  this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
                  this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
                  cookieToggle = !cookieToggle;
                }, 2000);
              } else {
                //UNSUCCESSFULL API CALL
                this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate("Error!");
                setTimeout(() => {
                  this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
                  this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
                  cookieToggle = !cookieToggle;
                }, 2000);
              }
            });
          }, 2000);
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          // this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/privacyPolicy');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy$1 = "Privacy\n Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n\n the categories of personally identifiable information about you that may be collected and how that information is used;\n how we collect and use non-personally identifiable information about your use of the website;\n the categories of persons or entities with whom the information may be shared;\n the choices that are available to you regarding collection, use, and distribution of the information;\n how you can opt out of RDK-related promotional e-mail;\n the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n how you can review and request changes to the information; and\n how we notify users of this website of changes to this privacy policy.\n Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n\n\n What categories of information do we collect?\n The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n\n To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n\n The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n\n Does RDK Management analyze my interaction with this website?\n Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n\n We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n\n You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n\n What categories of persons or entities do we share personally identifiable information with?\n We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n\n What do we do to personalize your use of this website?\n We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n\n To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n\n RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n\n The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n\n In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n\n We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n\n Your Access to and Control over your information?\n You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n\n Request to see all the information stored in the system\n Accuracy of your data can be checked or corrected.\n Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n Express any concern you have about our use of your data\n Opt out from receiving emails by clicking unsubscribe.\n How do users opt out of RDK-related promotional e-mail?\n You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n\n Other Websites\n\n To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n\n Security\n\n All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n\n Changes to this Privacy Policy\n\n We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n\n A Special Note About Children\n\n This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n\n Contacting us:\n\n If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n\n Data Protection Officer:  Herman-Jan Smith\n\n Email us at: hj.smith@rdkcentral.com\n\n Contacting the appropriate authority:\n\n Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n\n Email: compliance_team@rdkcentral.com\n\n Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Privacy  Policy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        clipping: true,
        PrivacyPolicy: {
          x: 200,
          y: 270,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: Language$1.translate('Privacy Policy'),
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontStyle: "bold",
              fontSize: 40
            }
          },
          Content: {
            x: 10,
            y: 100,
            text: {
              text: _privacyPolicy$1,
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 20,
              wordWrapWidth: 1500,
              wordWrap: true
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other/privacy');
      }
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 235) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$e = thunderJS$1(CONFIG.thunderConfig);
  class CECApi {
    activate() {
      return new Promise(resolve => {
        thunder$e.Controller.activate({
          callsign: 'org.rdk.HdmiCecSource'
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Activation', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error while Thunder Controller HdmiCecSource activate " + JSON.stringify(err), false, null);
        });
      });
    }
    deactivate() {
      return new Promise(resolve => {
        thunder$e.Controller.deactivate({
          callsign: 'org.rdk.HdmiCecSource'
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Deactivation', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error while Thunder Controller HdmiCecSource deactivate " + JSON.stringify(err), false, null);
        });
      });
    }
    getEnabled() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.HdmiCecSource', 'getEnabled').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Get Enabled', +JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource getEnabled " + JSON.stringify(err), false, null);
          resolve({
            enabled: false
          });
        });
      });
    }
    setEnabled() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.HdmiCecSource', 'setEnabled', {
          enabled: true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Set Enabled', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource setEnabled " + JSON.stringify(err), false, null);
          resolve({
            success: false
          });
        });
      });
    }
    getOSDName() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.HdmiCecSource', 'getOSDName').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('getOSDName' + JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource getOSDName " + JSON.stringify(err), false, null);
          resolve({
            enabled: false
          });
        });
      });
    }
    setOSDName(osdname) {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.HdmiCecSource', 'setOSDName', {
          name: osdname
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('setOSDName', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource setOSDName " + JSON.stringify(err), false, null);
          resolve({
            success: false
          });
        });
      });
    }
    performOTP() {
      return new Promise(resolve => {
        thunder$e.call('org.rdk.HdmiCecSource', 'performOTPAction').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Otp Error', err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource performOTPAction " + JSON.stringify(err), false, null);
          resolve({
            success: false
          });
        });
      });
    }
    getActiveSourceStatus() {
      return new Promise((resolve, reject) => {
        thunder$e.call('org.rdk.HdmiCecSource', 'getActiveSourceStatus').then(result => {
          resolve(result.status);
        }).catch(err => {
          console.error("CECApi HdmiCecSource getActiveSourceStatus failed." + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "HdmiCecSourceError", "Error in Thunder HdmiCecSource getActiveSourceStatus " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for AdvancedSettings screen.
   */

  class AdvanceSettingsScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class DeviceScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Info');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced');
      }
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          // this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/info');
          }
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/timezone');
          }
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/firmware');
          }
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          this._setState('Reset');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/reboot');
          }
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/factoryReset');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Info'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: 0xCC000000,
        DeviceInfoContents: {
          x: 200,
          y: 275,
          Line1: {
            y: 0,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          ChipSet: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Chipset"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 45,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line2: {
            y: 90,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SerialNumber: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Serial Number"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 135,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line3: {
            y: 180,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          Location: {
            Title: {
              x: 10,
              y: 225,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Location"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 225,
              mountY: 0.5,
              text: {
                text: "CountryCode:",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line4: {
            y: 270,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SupportedDRM: {
            Title: {
              x: 10,
              y: 360,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Supported DRM & Key-System"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1600,
                wordWrap: true,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 360,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1200,
                wordWrap: true,
                fontSize: 25
              }
            }
          },
          Line5: {
            y: 450,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          FirmwareVersions: {
            Title: {
              x: 10,
              y: 540,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Firmware version"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 540,
              mountY: 0.5,
              text: {
                text: "UI Version: ".concat(Settings$2.get('platform', 'version'), ", Build Version: , Firebolt API Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line6: {
            y: 630,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          AppVersions: {
            Title: {
              x: 10,
              y: 720,
              mountY: 0.5,
              text: {
                text: Language$1.translate("App Info"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 720,
              mountY: 0.5,
              text: {
                text: "Youtube:\nAmazon Prime:\nNetflix ESN:",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line7: {
            y: 810,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result);
      });
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.appApi.getSystemVersions().then(res => {
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
        }).catch(err => {
          console.error("error while getting the system versions");
        });
        this._network.isConnectedToInternet().then(result => {
          if (result === true) {
            this.appApi.getLocation().then(result => {
              console.log("getLocation from device info " + JSON.stringify(result));
              let locationInfo = "";
              if (result.city.length !== 0) {
                locationInfo = "City: " + result.city;
              } else {
                locationInfo = "City: N/A ";
              }
              if (result.country.length !== 0) {
                locationInfo += ", Country: " + result.country;
              } else {
                locationInfo += ", Country: N/A ";
              }
              this.tag('Location.Value').text.text = "".concat(locationInfo);
            });
          } else {
            this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
          }
        });
      } else {
        // Firebolt mode
        FireBoltApi.get().deviceinfo.getversion().then(res => {
          console.log("build verion".concat(res.firmware.readable, " Firebolt API Version - ").concat(res.api.readable));
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.firmware.readable, " \nFirebolt API Version - ").concat(res.api.readable, " ");
        }).catch(err => {
          console.error("error while getting the system versions from Firebolt.getversion API");
        });
        FireBoltApi.get().localization.countryCode().then(res => {
          this.tag('Location.Value').text.text = "CountryCode: ".concat(res);
        });
      }
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        let drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });
      let self = this;
      if (Storage$1.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage$1.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage$1.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
          self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: \"Not Detected\"";
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > 215) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 275) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Firmware screen.
   */

  const thunder$d = thunderJS$1(CONFIG.thunderConfig);
  class FirmwareScreen$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Firmware Update'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            alpha: 0,
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _init() {
      this._appApi = new AppApi();
    }
    _active() {
      this.onFirmwareUpdateStateChangeCB = thunder$d.on('org.rdk.System', 'onFirmwareUpdateStateChange', notification => {
        this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + FirmwareScreen$1.STATES[notification.firmwareUpdateStateChange];
        console.log('onFirmwareUpdateStateChange:' + JSON.stringify(notification));
        if (FirmwareScreen$1.STATES[notification.firmwareUpdateStateChange] === "Downloading") {
          this.showUpdateButton(notification.firmwareUpdateStateChange);
          this.downloadInterval = setInterval(() => {
            console.log("Downloading...");
            this.getDownloadPercent();
          }, 1000);
        } else if (notification.firmwareUpdateStateChange > 3) {
          this.showUpdateButton(notification.firmwareUpdateStateChange);
          this.getDownloadFirmwareInfo();
        } else if (FirmwareScreen$1.STATES[notification.firmwareUpdateStateChange] != "Downloading") {
          this.tag('DownloadedPercent.Title').visible = false;
          this.showUpdateButton(notification.firmwareUpdateStateChange);
          if (this.downloadInterval) {
            console.log("");
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }
      });
      // TODO: This need to be in _init() as it should be system wide.
      this.onFirmwareUpdateInfoReceivedCB = thunder$d.on('org.rdk.System', 'onFirmwareUpdateInfoReceived', params => {
        console.log("onFirmwareUpdateInfoReceived", JSON.stringify(params));
        if (params.success) {
          if (params.updateAvailable) {
            switch (params.updateAvailableEnum) {
              case 0:
                // A new firmware version is available.
                this.showUpdateButton(params.updateAvailable);
                break;
              case 1: // The firmware version is at the current version.
              case 2: // XCONF did not return a firmware version (timeout or other XCONF error).
              case 3:
                // The device is configured not to update the firmware (swupdate.conf exists on the device).
                this.tag("FirmwareUpdate").alpha = 0;
                this._setState('Idle');
                break;
            }
          }
        }
      });
      // TODO: decouple updateFirmware from here.
      //this.getDownloadFirmwareInfo();
      this.getDownloadPercent();
    }
    showDownloadPercentage() {
      this.downloadInterval = setInterval(() => {
        this.getDownloadPercent();
      }, 1000);
    }
    showUpdateButton(state) {
      if (state > 3 || state === 2) {
        this.tag("FirmwareUpdate").alpha = 0;
        this._setState('Idle');
      } else {
        this.tag("FirmwareUpdate").alpha = 1;
        this._setState('FirmwareUpdate');
      }
    }
    _disable() {
      if (this.onFirmwareUpdateStateChangeCB) this.onFirmwareUpdateStateChangeCB.dispose();
    }
    async _focus() {
      this.downloadInterval = null;
      await this._appApi.getFirmwareUpdateState().then(res => {
        if (res.success) {
          console.log("getFirmwareUpdateState from firmware screen " + JSON.stringify(res));
          this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + FirmwareScreen$1.STATES[res.firmwareUpdateState];
          this.showUpdateButton(res.firmwareUpdateState);
          if (res.firmwareUpdateState === "Downloading") {
            this.showDownloadPercentage();
          }
        }
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("getDownloadFirmwareInfo : ".concat(JSON.stringify(res)));
        this.tag('Version.Title').text.text = Language$1.translate("Firmware Versions: ") + res.currentFWVersion;
        this.tag('DownloadedVersion.Title').text.text = Language$1.translate('Downloaded Firmware Version: ') + "".concat(res.downloadedFWVersion ? res.downloadedFWVersion : 'NA');
      });
    }
    getDownloadPercent() {
      this._appApi.getFirmwareDownloadPercent().then(res => {
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').visible = false;
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').visible = true;
          this.tag('DownloadedPercent.Title').text.text = Language$1.translate("Download Progress: ") + res.downloadPercent + "%";
          if (this.downloadInterval === null) {
            this.showDownloadPercentage();
          }
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi.updateFirmware().then(res => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadedFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language$1.translate('Downloaded Firmware Version: ') + "".concat(result.downloadedFWVersion ? result.downloadedFWVersion : "");
          this.tag('Version.Title').text.text = Language$1.translate("Firmware Versions: ") + result.currentFWVersion;
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }, class Idle extends this {
        //
      }];
    }
  }
  FirmwareScreen$1.STATES = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'Download Complete', 'Validation Complete', 'Preparing to Reboot'];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$a = new AppApi();
  /**
   * Class for Reboot Confirmation Screen.
   */
  class RebootConfirmationScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('Confirm');
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$a.reboot().then(result => {
            console.log('device rebooting' + JSON.stringify(result));
            this._setState('Rebooting');
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag('Buttons').visible = false;
          this.tag('Info').visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneItem extends lng$1.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      Router.navigate('settings/advanced/device/timezone/item', {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Time'));
    }

    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        TimeZone: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -1
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: Language$1.translate('Not supported'),
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.zone = await this.appApi.getZone();
      } else {
        this.zone = await FireBoltApi.get().localization.getTimeZone();
      }
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
        if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError" && this.zone.length) {
          AlexaApi.get().updateDeviceTimeZoneInAlexa(this.zone);
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
    }
    _getFocused() {
      return this.tag('List').element;
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[1]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItems extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Time: {
          x: 200,
          y: 185,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -2
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set params(item) {
      console.log(item);
      this._item = item;
      this.tag('List').h = Object.keys(item.time_region).length * 90;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _init() {
      this.appApi = new AppApi();
    }
    _active() {
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        FireBoltApi.get().localization.listen("timeZoneChanged", value => {
          console.log('timezone changed successfully to ', JSON.stringify(value));
        });
      }
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.widgets.menu.updateTimeZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      } else {
        FireBoltApi.get().localization.setTimeZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      }
      Router.navigate('settings/advanced/device/timezone', {
        refresh: true
      });
    }
    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance$1 = null;
  class Warehouse {
    constructor() {
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.callsign = 'org.rdk.Warehouse';
      this.INFO = function () {};
      this.LOG = function () {};
      this.ERR = console.error;
    }
    static get() {
      if (instance$1 === null) {
        instance$1 = new Warehouse();
      }
      return instance$1;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO(this.callsign + " activate result:" + result);
          resolve(true);
        }).catch(err => {
          this.ERR(this.callsign + " activate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error in Thunder controller warehouseApi activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO(this.callsign + " deactivate result:" + result);
          resolve(true);
        }).catch(err => {
          this.ERR(this.callsign + " deactivate error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error in Thunder controller warehouseApi deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    executeHardwareTest() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'executeHardwareTest').then(result => {
          this.INFO(this.callsign + " executeHardwareTest result: " + result);
          if (result.success) resolve(result.success);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " executeHardwareTest error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi executeHardwareTest " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    internalReset() {
      let passPhrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "FOR TEST PURPOSES ONLY";
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'internalReset', {
          passPhrase: passPhrase
        }).then(result => {
          this.INFO(this.callsign + " internalReset result: " + result);
          if (result.success) resolve(result.success);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " internalReset error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi internalReset " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    isClean() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'isClean').then(result => {
          this.INFO(this.callsign + " isClean result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " isClean error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi isClean " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    lightReset() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'lightReset').then(result => {
          this.INFO(this.callsign + " lightReset result: " + result);
          if (result.success) resolve(result.success);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " lightReset error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi lightReset " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    resetDevice() {
      let resetType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "USERFACTORY";
      let suppressReboot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "false";
      return new Promise((resolve, reject) => {
        let params = {
          resetType: resetType,
          suppressReboot: suppressReboot
        };
        this.INFO(this.callsign + " resetDevice params: " + JSON.stringify(params));
        this.thunder.call(this.callsign, 'resetDevice', params).then(result => {
          this.INFO(this.callsign + " resetDevice result: " + result);
          if (result.success) resolve(result.success);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " resetDevice error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi resetDevice " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setFrontPanelState() {
      let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      // -1 (NONE), 1 (DOWNLOAD IN PROGRESS), 3 (DOWNLOAD FAILED)
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'setFrontPanelState', {
          state: state
        }).then(result => {
          this.INFO(this.callsign + " setFrontPanelState result: " + result);
          if (result.success) resolve(result.success);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + " setFrontPanelState error: " + err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "WarehouseApiError", "Error while Thunder warehouseApi setFrontPanelState " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$9 = new AppApi();
  const _btApi = new BluetoothApi();

  /**
   * Class for Reboot Confirmation Screen.
   */
  class RebootConfirmationScreen extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Factory Reset"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to FactoryReset!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _init() {
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState('Confirm');
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _firstEnable() {
      this.AppApi.checkStatus(Warehouse.get().callsign).then(resp => {
        console.log("FactoryReset: warehouse plugin status : ", resp[0].status);
        if (resp[0].status != 'activated') {
          Warehouse.get().activate().catch(err => {
            console.error("FactoryReset: warehouse plugin activation failed; feature may not work.");
          });
        }
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    async _performFactoryReset() {
      // Deactivate SmartScreen instance to prevent overlay when Auth is revoked.
      AlexaApi.get().disableSmartScreen();
      AlexaApi.get().resetAVSCredentials();
      AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
      let getsuportedmode = await appApi$9.getSupportedAudioPorts();
      for (let i = 0; i < getsuportedmode.supportedAudioPorts.length; i++) {
        if (getsuportedmode.supportedAudioPorts[i] != 'SPDIF0') {
          let rsbass = await appApi$9.resetBassEnhancer(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetBassEnhancer", err);
          });
          if (rsbass.success != true) {
            console.log("resetBassEnhancer", rsbass);
          } //throw new Error(rsbass); }//{Promise.reject(false); return}
          let rsDialog = await appApi$9.resetDialogEnhancement(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetDialogEnhancement", err);
          }); //{Promise.reject(JSON.stringify(err))});
          if (rsDialog.success != true) {
            console.log("resetDialogEnhancement", rsDialog);
          }
          let rsVirtualizer = await appApi$9.resetSurroundVirtualizer(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetSurroundVirtualizer", err);
          });
          if (rsVirtualizer.success != true) {
            console.log("resetSurroundVirtualizer", rsVirtualizer);
          }
          let rsvolumelvel = await appApi$9.resetVolumeLeveller(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetVolumeLeveller", err);
          });
          if (rsvolumelvel.success != true) {
            console.log("resetVolumeLeveller", rsvolumelvel);
          }
        }
      }
      await _btApi.btactivate().then(result => console.log("Btactivate", result)).catch(err => console.log("error while activating bluetooth"));
      let getPairedDevices = await _btApi.getPairedDevices().then(res => res).catch(err => 0);
      console.log("getpairedDevices", getPairedDevices);
      for (let i = 0; i < getPairedDevices.length; i++) {
        if (getPairedDevices.length > 0) {
          let btunpair = await _btApi.unpair(getPairedDevices[i].deviceId).catch(err => {
            console.log("btunpair", err);
          });
          if (btunpair.success != true) {
            console.log("btunpair", btunpair);
          }
        }
      }
      await RCApi.get().activate().then(() => {
        RCApi.get().factoryReset();
      }).catch(err => console.log("error while resetting remote control"));
      let contollerStat = await appApi$9.checkStatus("Monitor");
      for (let i = 0; i < contollerStat[0].configuration.observables.length; i++) {
        let monitorstat = await appApi$9.monitorStatus(contollerStat[0].configuration.observables[i].callsign).catch(err => {
          console.log("monitorStatus", err);
        });
        if (monitorstat.length < 0) {
          console.log("monitorStatus", monitorstat);
        }
      }
      // warehouse apis
      await Warehouse.get().internalReset().catch(err => {
        console.error("internalReset", err);
      });
      await Warehouse.get().isClean().catch(err => {
        console.error("isClean", err);
      });
      await Warehouse.get().lightReset().catch(err => {
        console.error("lightReset", err);
      });
      await Warehouse.get().resetDevice().catch(err => {
        console.error("resetDevice", err);
      });
      let rsactivitytime = await appApi$9.resetInactivityTime().catch(err => {
        console.error("resetInactivityTime", err);
      });
      if (rsactivitytime.success != true) {
        console.log("rsactivitytime", rsactivitytime);
      }
      let clearLastDeepSleepReason = await appApi$9.clearLastDeepSleepReason().catch(err => {
        console.error("clearLastDeepSleepReason", err);
      });
      if (clearLastDeepSleepReason.success != true) {
        console.log("clearLastDeepSleepReason", clearLastDeepSleepReason);
      }
      let clearSSID = await Wifi.get().clearSSID().catch(err => {
        console.error("clearSSID", err);
      });
      if (clearSSID.success != true) {
        console.log("clearSSID", clearSSID);
      }
      let wifidisconnect = await Wifi.get().disconnect().catch(err => {
        console.error("wifidisconnect", err);
      });
      if (wifidisconnect.success != true) {
        console.log("wifidisconnect", wifidisconnect);
      }
      await appApi$9.clearCache().catch(err => {
        console.error("clearCache error: ", err);
      });
      await appApi$9.reboot().then(result => {
        console.log('device rebooting' + JSON.stringify(result));
      });
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this._setState('Rebooting');
          /* Do any clean-up before _performFactoryReset() as it ends with a reboot. */
          this._performFactoryReset();
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag('Buttons').visible = false;
          this.tag('Info').visible = false;
        }
        $exit() {
          this.loadingAnimation.stop();
          this.tag("Loader").visible = false;
          this.tag('Buttons').visible = true;
          this.tag('Info').visible = true;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$8 = new AppApi();
  var thunder$c = thunderJS$1(CONFIG.thunderConfig);
  class SreenSaverScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Screen Saver'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: lng$1.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '5 Minutes',
        tick: false
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '30 Minutes',
        tick: false
      }, {
        value: '60 Minutes',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this._setState('Options');
      // this.setTimerValue(this.timerValue);
    }
    async _focus() {
      let FocusedValue = await PersistentStoreApi.get().getValue('ScreenSaverTime', 'timerValue').then(result => {
        if (result && result.value !== undefined && result.value !== "Off") {
          return result.value;
        } else {
          return "Off";
        }
      }).catch(err => {
        console.error("App PersistentStoreApi getValue error: " + JSON.stringify(err));
        return "Off";
      });
      console.log("PersistentStoreApi focusedValue", FocusedValue);
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '5 Minutes',
        tick: false
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '30 Minutes',
        tick: false
      }, {
        value: '60 Minutes',
        tick: false
      }];
      //let timeoutInterval = Storage.get('TimeoutInterval');
      if (!FocusedValue) {
        FocusedValue = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (item.value.startsWith(FocusedValue)) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this._setState('Options');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    setTimerValue(time) {
      if (time === "Off" || time === undefined || time === null) {
        rdkShellApisInstance.enableInactivityReporting(false).then(resp => console.log(resp));
        Storage$1.remove('ScreenSaverTimeoutInterval');
      } else {
        // 10
        rdkShellApisInstance.enableInactivityReporting(true).then(() => {
          rdkShellApisInstance.setInactivityInterval(parseInt(time)).then(res => {
            console.log("setinactivityres", res);
            Storage$1.set('ScreenSaverTimeoutInterval', time);
            console.log("successfully set the timer to ".concat(time, " minutes"));
            thunder$c.on('org.rdk.RDKShell', 'onUserInactivity', notification => {
              console.log("UserInactivityStatusNotification: ", JSON.stringify(notification));
              appApi$8.getAvCodeStatus().then(result => {
                console.log("Avdecoder", result.avDecoderStatus);
                if ((result.avDecoderStatus === "IDLE" || result.avDecoderStatus === "PAUSE") && GLOBALS.topmostApp === GLOBALS.selfClientName) {
                  this.fireAncestors("$hideImage", 1);
                }
              });
            });
          }).catch(err => {
            console.error("error while setting the timer" + JSON.stringify(err));
          });
        });
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        async _handleEnter() {
          this.options.forEach((element, idx) => {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
          });
          this.tag('List').element.tag('Tick').visible = true;
          this.timerValue = this.options[this.tag('List').index].value; //10 minutes
          this.timerValue = this.timerValue === "Off" ? "Off" : this.timerValue.substring(0, 2); // 10
          console.log("ScreenSaverTime Value:" + JSON.stringify(this.timerValue));
          await PersistentStoreApi.get().setValue('ScreenSaverTime', 'timerValue', this.timerValue).catch(err => {
            console.error("App PersistentStoreApi setValue error: " + JSON.stringify(err));
          });
          this.setTimerValue(this.timerValue); // enable and setinactivity process
          this.fireAncestors('$screenSaverTime', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const CONSTANTS = {
    LOCK_TIME: 20000,
    MAX_FAILURES: 3,
    PINS: {
      purchase: "1111"
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SecurityPinScreen extends lng$1.Component {
    set params(args) {
      console.log("args:", args);
      if (args.message !== "") {
        this.tag('Description').text.text = Language$1.translate(args.message);
      }
      this.responder = args.responder;
      this.challenge = args.challenge;
      this.numFailures = 0;
      this.lockedTime = 0;
    }
    pageTransition() {
      return 'left';
    }
    handleDone() {
      console.log("Inside handle done");
      this.onPinEntered(this.textCollection['TextBox']);
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          alpha: 1,
          color: 0xCC000000
        },
        KeypadBg: {
          x: 730,
          y: 200,
          w: 380,
          h: 600,
          rect: true,
          color: 0xCC000000,
          alpha: 1
        },
        Title: {
          x: 730,
          y: 70,
          text: {
            text: Language$1.translate('Security PIN input'),
            fontFace: CONFIG.language.font,
            fontSize: 40,
            textColor: CONFIG.theme.hex
          }
        },
        Description: {
          x: 730,
          y: 130,
          text: {
            text: Language$1.translate('Default description'),
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffffffff
          }
        },
        BorderTop: {
          x: 570,
          y: 125,
          w: 700,
          h: 2,
          rect: true
        },
        TextBox: {
          x: 750,
          y: 220,
          texture: lng$1.Tools.getRoundRect(340, 65, 0, 3, 0xffffffff, false)
        },
        PinText: {
          x: 770,
          y: 240,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Keyboard: {
          y: 300,
          x: 750,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.numbers
        }
      };
    }
    onPinEntered(pin) {
      if (pin === CONSTANTS.PINS[this.challenge.pinSpace]) {
        console.log("Correct pin");
        this.responder({
          granted: true,
          reason: PinChallenge.ResultReason.CORRECT_PIN
        });
        Router.back();
      } else {
        console.log("Wrong pin");
        this.numFailures++;
        if (this.numFailures >= CONSTANTS.MAX_FAILURES) {
          this.lockedTime = Date.now();
          this.responder({
            granted: false,
            reason: PinChallenge.ResultReason.EXCEEDED_PIN_FAILURES
          });
          Router.back();
        }
      }
    }
    _focus() {
      this.tag("PinText").text.text = "";
      this.textCollection = {
        'TextBox': '',
        'encrypted': ''
      };
    }
    _handleDown() {
      this._setState('TextBox');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class TextBox extends this {
        $enter() {
          this.tag('TextBox').texture = lng$1.Tools.getRoundRect(340, 65, 0, 3, CONFIG.theme.hex, false);
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('TextBox').texture = lng$1.Tools.getRoundRect(340, 65, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'TextBox') {
            this.element = 'PinText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection['TextBox'] = '';
            this.textCollection['encrypted'] = '';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else if (key === 'Space') {
            this.textCollection['encrypted'] += '\u25CF';
            this.textCollection['TextBox'] += ' ';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else if (key === 'Delete') {
            this.textCollection['encrypted'] = this.textCollection['encrypted'].substring(0, this.textCollection['encrypted'].length - 1);
            this.textCollection['TextBox'] = this.textCollection['TextBox'].substring(0, this.textCollection['TextBox'].length - 1);
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else {
            this.textCollection['TextBox'] += key;
            this.textCollection['encrypted'] += '\u25CF';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class KeyboardScreen extends lng$1.Component {
    set params(args) {
      if (args.message !== "") {
        this.tag('Description').text.text = Language$1.translate(args.message);
      }
      this.tag('InputType').text.text = args.type;
      this.hidePasswd = false;
      this.password = false;
      if (args.type === 'password') {
        this.password = true;
        this.hidePasswd = true;
        console.log("Making the password switch visible");
        this.tag('PasswrdSwitch').patch({
          visible: true
        });
        this.tag('ShowPassword').patch({
          visible: true
        });
      }
      this.responder = args.responder;
    }
    pageTransition() {
      return 'left';
    }
    handleDone() {
      this.responder({
        text: this.textCollection['TextBox'],
        canceled: false
      });
      Router.back();
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          alpha: 1,
          color: 0xCC000000
        },
        Title: {
          x: 200,
          y: 70,
          text: {
            text: "Keyboard challenge",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        Description: {
          x: 200,
          y: 130,
          text: {
            text: Language$1.translate('Default description'),
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffffffff
          }
        },
        BorderTop: {
          x: 190,
          y: 125,
          w: 1488,
          h: 2,
          rect: true
        },
        InputType: {
          x: 190,
          y: 316,
          text: {
            text: "Password: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        InputBox: {
          x: 400,
          y: 300,
          texture: lng$1.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false)
        },
        InputText: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 340,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: false
        },
        ShowPassword: {
          x: 1420,
          y: 322,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: 'Show Password',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: false
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        Cancel: {
          x: 1580,
          y: 60,
          w: 150,
          mountX: 0.5,
          h: 60,
          rect: true,
          color: 0xFFFFFFFF,
          Title: {
            x: 75,
            y: 30,
            mount: 0.5,
            text: {
              text: "Cancel",
              fontFace: CONFIG.language.font,
              fontSize: 22,
              textColor: 0xFF000000,
              fontStyle: 'bold'
            }
          },
          visible: true
        }
      };
    }
    _focus() {
      this._setState("InputBox");
      this.tag("InputText").text.text = "";
      this.textCollection = {
        'TextBox': '',
        'encrypted': ''
      };
    }
    get session() {
      return this._session;
    }
    set session(session) {
      this.donePending = false;
      this._session = session;
      this.onDone = session.onDone;
      this.onCancel = session.onCancel;
    }
    _getFocused() {
      return this;
    }
    _handleBack() {
      this.responder({
        text: '',
        canceled: true
      });
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    _updateText(txt) {
      this.tag("InputText").text.text = txt;
    }
    static _states() {
      return [class InputBox extends this {
        $enter() {
          this.tag('InputBox').texture = lng$1.Tools.getRoundRect(1279, 70, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("Cancel");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('InputBox').texture = lng$1.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'InputBox') {
            this.element = 'InputText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        _handleUp() {
          if (this.password) this._setState("PasswordSwitchState");else this._setState("Cancel");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Delete') {
            this.textCollection['encrypted'] = this.textCollection['encrypted'].substring(0, this.textCollection['encrypted'].length - 1);
            this.textCollection['TextBox'] = this.textCollection['TextBox'].substring(0, this.textCollection['TextBox'].length - 1);
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === 'Space') {
            this.textCollection['TextBox'] += ' ';
            this.textCollection['encrypted'] += '\u25CF';
            this.tag(this.element).text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === 'Clear') {
            this.textCollection['encrypted'] = '';
            this.textCollection['TextBox'] = '';
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else {
            this.textCollection['TextBox'] += key;
            this.textCollection['encrypted'] += '\u25CF';
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          }
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("InputBox").texture = lng$1.Tools.getRoundRect(1279, 70, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("Cancel");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['TextBox']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.textCollection['encrypted']);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("InputBox").texture = lng$1.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false);
        }
      }, class Cancel extends this {
        $enter() {
          this.tag("Cancel");
          this._focus();
        }
        _handleEnter() {
          this.responder({
            text: '',
            canceled: true
          });
          Router.back();
        }
        _handleDown() {
          if (this.hidePasswd) this._setState("PasswordSwitchState");else this._setState("InputBox");
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AcknowledgeScreen extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    set params(args) {
      console.log("args:", args);
      if (args.message !== "") {
        this.tag('Info').text.text = Language$1.translate(args.message);
      }
      this.responder = args.responder;
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: "Acknowledge",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Default text"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            YesButton: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "Grant",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            NoButton: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "Deny",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('NoButton');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        this.responder({
          granted: null
        });
        Router.back();
      }
    }
    static _states() {
      return [class YesButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.responder({
            granted: true
          });
          Router.back();
        }
        _handleRight() {
          this._setState('NoButton');
        }
        _focus() {
          this.tag('YesButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('YesButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class NoButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.responder({
            granted: false
          });
          Router.back();
        }
        _handleLeft() {
          this._setState('YesButton');
        }
        _focus() {
          this.tag('NoButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('NoButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var otherSettingsRoutes = {
    otherSettingsRoutes: [{
      path: 'settings/other',
      component: OtherSettingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/timer',
      component: SleepTimerScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/energy',
      component: EnergySavingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/language',
      component: LanguageScreen$2,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/privacy',
      component: PrivacyScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: "settings/other/SecurityPinScreen",
      component: SecurityPinScreen
    }, {
      path: "settings/other/KeyboardScreen",
      component: KeyboardScreen
    }, {
      path: "settings/other/AcknowledgeScreen",
      component: AcknowledgeScreen
    }, {
      path: 'settings/advanced',
      component: AdvanceSettingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device',
      component: DeviceScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/info',
      component: DeviceInformationScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/timezone',
      component: TimeZone$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/timezone/item',
      component: TimeItems,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/firmware',
      component: FirmwareScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/reboot',
      component: RebootConfirmationScreen$1
    }, {
      path: 'settings/advanced/device/factoryReset',
      component: RebootConfirmationScreen
    }, {
      path: 'settings/other/ScreenSaver',
      component: SreenSaverScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/privacyPolicy',
      component: PrivacyPolicyScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Audio screen.
   */

  class AudioScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Audio'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Wrapper: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState(this.state);
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language$1.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('Wrapper').visible = false;
    }
    show() {
      this.tag('Wrapper').visible = true;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio/output');
          }
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio/output');
          }
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4- 
           * 
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0", 100).then(res => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(res => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {
            this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(res => {
            this.appApi.getZoomSetting().then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class VideoAndAudioItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      if (this.videoElement === true) {
        this.appApi.setResolution(this._item).catch(err => {
          console.log("there was an error while setting the resolution." + JSON.stringify(err));
        });
      } else {
        this.appApi.setSoundMode(this._item).then(result => {
          if (result.success === true) {
            this.fireAncestors("$resetPrevTickObject", this);
            this.tag("Item.Tick").visible = true;
            // this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + soundMode
          }
          //this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + result.soundMode
          this.fireAncestors("$updateSoundMode", this._item);
        }).catch(err => {
          console.log('Some error while setting the sound mode ', err);
        });
      }
    }
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: this.isTicked ? true : false //implement the logic to show the tick
        },
        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$7 = new AppApi();
  class HdmiOutputScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Audio  Output Mode'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      appApi$7.getSoundMode().then(result => {
        appApi$7.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/audio');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$b = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Video  Resolution'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$b.on('org.rdk.DisplaySettings', 'resolutionPreChange', notification => {
        console.log(new Date().toISOString() + " ResolutionScreen got resolutionPreChange");
        Storage$1.set("ResolutionChangeInProgress", true);
      });
      thunder$b.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        console.log(new Date().toISOString() + " ResolutionScreen got resolutionChanged");
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
        Storage$1.set("ResolutionChangeInProgress", false);
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/video');
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      let sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('List').rollMax = options.length * 90;
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            let bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen$1 extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Video'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        FireBoltApi.get().deviceinfo.getscreenresolution().then(resolution => {
          this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + "".concat(JSON.stringify(resolution[0]), " , ").concat(JSON.stringify(resolution[1]));
        });
        FireBoltApi.get().deviceinfo.gethdcp().then(res => {
          let hdcp = "";
          for (let key in res) {
            hdcp += "\t\t".concat(key, " : ").concat(res[key], " ");
            hdcp += ",";
          }
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), " ").concat(hdcp.substring(0, hdcp.length - 1));
        });
        FireBoltApi.get().deviceinfo.gethdr().then(res => {
          let hdr = "";
          for (let key in res) {
            hdr += "\t\t".concat(key, " : ").concat(res[key]);
            hdr += ",";
          }
          this.tag("HDR.Title").text.text = "".concat(Language$1.translate('High Dynamic Range: ')).concat(hdr.substring(0, hdr.length - 1));
        });
      } else {
        this._appApi.getResolution().then(resolution => {
          this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + resolution;
        }).catch(err => {
          console.log("Error fetching the Resolution");
        });
        this._appApi.getHDCPStatus().then(result => {
          if (result.isHDCPCompliant && result.isHDCPEnabled) {
            this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
          } else {
            this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Not Supported ");
          }
        });
        this._appApi.getHDRSetting().then(result => {
          const availableHDROptions = {
            "HdrOff": "Off",
            "Hdr10": "HDR 10",
            "Hdr10Plus": "HDR 10+",
            "HdrHlg": "HLG",
            "HdrDolbyvision": "Dolby Vision",
            "HdrTechnicolor": "Technicolor HDR"
          };
          this.tag("HDR.Title").text.text = Language$1.translate('High Dynamic Range: ') + availableHDROptions[result];
        });
      }
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/video/resolution');
          }
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP') 
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var audioScreenRoutes = {
    audioScreenRoutes: [{
      path: 'settings/audio',
      component: AudioScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/audio/output',
      component: HdmiOutputScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/video',
      component: VideoScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/video/resolution',
      component: ResolutionScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle$1 = 'Error Title';
  const errorMsg$1 = 'Error Message';
  class Failscreen extends lng$1.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailScreen.Title').text.text = args.title;
        this.tag('FailScreen.Message').text.text = Language$1.translate(args.msg);
      }
      if (args.count) {
        this.timeout = args.count;
      } else {
        this.timeout = 5;
      }
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this.alpha = 1;
    }
    _unfocus() {
      this.alpha = 0;
      this.tag('FailScreen.Title').text.text = errorTitle$1;
      this.tag('FailScreen.Message').text.text = errorMsg$1;
    }
    static _template() {
      return {
        alpha: 0,
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        FailScreen: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle$1,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg$1,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: 0x000000,
            Timer: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Button: {
            x: 0,
            y: 450,
            w: 300,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xfff58233,
            Name: {
              x: 150,
              y: 30,
              mount: 0.5,
              text: {
                text: '',
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xffffffff,
                fontStyle: 'bold'
              }
            },
            visible: false
          }
        }
      };
    }
    set item(error) {
      this.tag('Pairing').text = error;
    }
    set timerVisible(v) {
      this.tag('Timer').alpha = v;
    }
    _active() {
      this.tag('Timer').text.text = "";
      if (this.timeout > 0) {
        this.initTimer();
      }
    }
    initTimer() {
      this.timeInterval = Registry.setInterval(() => {
        this.tag('Timer').text.text = this.timeout >= 10 ? "0:".concat(this.timeout) : "0:0".concat(this.timeout);
        if (this.timeout > 0) {
          --this.timeout;
        } else {
          Router.focusPage();
        }
      }, 1000);
    }

    /**
     * @param {{ button: any; visible: any; }} v
     */
    isButtonVisible(button, visible) {
      this.tag('Name').text.text = button;
      this.tag('Button').visible = visible;
    }
    _inactive() {
      if (this.timeInterval) {
        Registry.clearInterval(this.timeInterval);
      }
    }
    _handleBack() {
      Router.focusPage();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class UsbListItem extends lng$1.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + 24,
        w: this.w,
        x: this.x,
        y: this.y - 12
      });
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x + 10,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 20,
              maxLines: 2,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        scale: this.focus,
        alpha: 1
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        alpha: 0
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var usbApi = new UsbApi();
  class UsbAppsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText('USB');
    }
    static _template() {
      return {
        UsbAppsScreenContents: {
          rect: true,
          color: 0xff000000,
          x: 200,
          y: 270,
          w: 1765,
          h: 1250,
          clipping: true,
          Wrapper: {
            x: 0,
            w: 1765,
            h: 1250,
            clipping: true,
            Text1: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Videos"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row1: {
              y: 30,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 277,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text2: {
              // x: 10 + 25,
              y: 243,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Audio"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row2: {
              y: 273,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 171,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text3: {
              // x: 10 + 25,
              y: 486,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Photos"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row3: {
              y: 516,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text4: {
              // x: 10 + 25,
              y: 729,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Folders"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row4: {
              y: 759,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: lng$1.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          NoUSB: {
            x: 0,
            w: 1765,
            h: 800,
            clipping: true,
            visible: false,
            Image: {
              x: 800,
              y: 400,
              mount: 0.5,
              texture: {
                type: lng$1.textures.ImageTexture,
                src: 'static/images/usb/Unsupported_file_640x360.jpg',
                resizeMode: {
                  type: 'contain',
                  w: 640,
                  h: 360
                }
              }
            }
          }
        },
        AudioInfo: {
          zIndex: 2,
          visible: false,
          h: 1080,
          w: 1920,
          // x: -200,
          // y: -286,
          Image: {
            scale: 0.5,
            x: 960,
            y: 560,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Audio_Background_16k.jpg'
            }
          },
          Title: {
            x: 960,
            y: 900,
            mount: 0.5,
            text: {
              fontFace: CONFIG.language.font,
              text: 'file_name.mp3',
              fontSize: 35
            }
          }
        },
        PlayerControls: {
          type: LightningPlayerControls,
          y: 810,
          alpha: 0,
          signals: {
            pause: 'pause',
            play: 'play',
            hide: 'hidePlayerControls',
            fastfwd: 'fastfwd',
            fastrwd: 'fastrwd'
          },
          zIndex: 4
        }
      };
    }
    _handleBack() {
      if (!(this.cwd.length === 0)) {
        let clone = [...this.cwd];
        clone.pop();
        let cwdname = clone.join("/");
        usbApi.cd(cwdname).then(() => {
          this.cwd.pop();
          this.loadData();
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      } else {
        Router.navigate('menu');
      }
    }
    reset() {
      for (let i = this.tag('Row1').index; i > 0; i--) {
        this.tag('Row1').setPrevious();
      }
      for (let i = this.tag('Row2').index; i > 0; i--) {
        this.tag('Row2').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row3').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row4').setPrevious();
      }
    }
    hide() {
      this.tag('UsbAppsScreenContents').visible = false;
      this.fireAncestors('$hideAllforVideo');
    }
    show() {
      this.tag('UsbAppsScreenContents').visible = true;
      this.fireAncestors('$showAllforVideo');
    }
    traverseMinus() {
      this.index = (this.traversableRows.length + --this.index) % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    traversePlus() {
      this.index = ++this.index % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    static _states() {
      return [class Video extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('Row1').length) {
            return this.tag('Row1').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleRight() {
          if (this.tag('Row1').length - 1 != this.tag('Row1').index) {
            this.tag('Row1').setNext();
            return this.tag('Row1').element;
          }
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row1').element.data.uri,
            currentIndex: this.tag('Row1').element.idx,
            list: this.tag('Row1').items,
            isUSB: true
          });
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          if (0 != this.tag('Row1').index) {
            this.tag('Row1').setPrevious();
            return this.tag('Row1').element;
          } else {
            this.reset();
          }
        }
      }, class Audio extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('Row2').length) {
            return this.tag('Row2').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row2').element.data.uri,
            isAudio: true,
            list: this.tag('Row2').items,
            currentIndex: this.tag('Row2').element.idx,
            isUSB: true
          });
        }
        _handleRight() {
          if (this.tag('Row2').length - 1 != this.tag('Row2').index) {
            this.tag('Row2').setNext();
            return this.tag('Row2').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('Row2').index) {
            this.tag('Row2').setPrevious();
            return this.tag('Row2').element;
          } else {
            this.reset();
          }
        }
      }, class Picture extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('Row3').length) {
            return this.tag('Row3').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          // console.log(this.tag('Row3').items)
          Router.navigate('usb/image', {
            src: this.tag('Row3').element.data.uri,
            currentIndex: this.tag('Row3').element.idx,
            list: this.tag('Row3').items,
            cwd: this.cwd
          });
        }
        _handleRight() {
          if (this.tag('Row3').length - 1 != this.tag('Row3').index) {
            this.tag('Row3').setNext();
            return this.tag('Row3').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('Row3').index) {
            this.tag('Row3').setPrevious();
            return this.tag('Row3').element;
          } else {
            this.reset();
          }
        }
      }, class Folder extends this {
        $enter() {
          if (this.traversableRows.length > 3) {
            this.scroll(-243);
          }
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('Row4').length) {
            return this.tag('Row4').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          //do something after folder click.
          let dname = this.cwd.join("/") + "/" + this.tag('Row4').element.data.displayName;
          usbApi.cd(dname).then(() => {
            this.cwd.push(this.tag('Row4').element.data.displayName);
            // console.log(`loading the data from the directory ${this.cwd}

            // and its data = music:${JSON.stringify(musicListInfo)}

            // Pictures : ${JSON.stringify(imageListInfo)}

            // videos : ${JSON.stringify(videoListInfo)}

            // folders : ${JSON.stringify(UsbInnerFolderListInfo)}

            // `);
            this.loadData();
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
        _handleRight() {
          if (this.tag('Row4').length - 1 != this.tag('Row4').index) {
            this.tag('Row4').setNext();
            return this.tag('Row4').element;
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('Row4').index) {
            this.tag('Row4').setPrevious();
            return this.tag('Row4').element;
          } else {
            this.reset();
          }
        }
      }];
    }
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.thisDir = args.cwd;
    }
    set Row1Items(items) {
      this.tag('Row1').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row1').start();
    }
    set Row2Items(items) {
      this.tag('Row2').items = items.map((info, idx) => {
        return {
          w: 151,
          h: 151,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row2').start();
    }
    set Row3Items(items) {
      this.tag('Row3').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row3').start();
    }
    set Row4Items(items) {
      this.tag('Row4').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row4').start();
    }
    scroll(y) {
      this.tag('Wrapper').setSmooth('y', y, {
        duration: 0.5
      });
    }
    loadData() {
      // console.log(`loading data from the directory ${this.cwd}`);
      let sumY = 0;
      this.index = 0;
      this.traversableRows = [];
      this.Row1Items = videoListInfo;
      this.Row2Items = musicListInfo;
      this.Row3Items = imageListInfo;
      this.Row4Items = UsbInnerFolderListInfo;
      let text1 = this.tag("Text1");
      let row1 = this.tag('Row1');
      let text2 = this.tag("Text2");
      let row2 = this.tag('Row2');
      let text3 = this.tag("Text3");
      let row3 = this.tag('Row3');
      let text4 = this.tag('Text4');
      let row4 = this.tag('Row4');
      if (videoListInfo.length === 0 && musicListInfo.length === 0 && imageListInfo.length === 0 && UsbInnerFolderListInfo.length === 0) {
        this.tag('NoUSB').visible = true;
        text1.visible = false;
        row1.visible = false;
        text2.visible = false;
        row2.visible = false;
        text3.visible = false;
        row3.visible = false;
        text4.visible = false;
        row4.visible = false;
        //either the usb is not mounted or there aren't any videos , images or audio files.
      } else {
        this.tag('NoUSB').visible = false;
        if (videoListInfo.length === 0) {
          text1.visible = false;
          row1.visible = false;
        } else {
          this.traversableRows.push("Video");
          text1.visible = true;
          row1.visible = true;
          text1.y = sumY;
          row1.y = sumY + 30;
          sumY += 243;
        }
        if (musicListInfo.length === 0) {
          text2.visible = false;
          row2.visible = false;
        } else {
          this.traversableRows.push("Audio");
          text2.visible = true;
          row2.visible = true;
          text2.y = sumY;
          row2.y = sumY + 30;
          sumY += 243;
        }
        if (imageListInfo.length === 0) {
          text3.visible = false;
          row3.visible = false;
        } else {
          this.traversableRows.push("Picture");
          text3.visible = true;
          row3.visible = true;
          text3.y = sumY;
          row3.y = sumY + 30;
          sumY += 243;
        }
        if (UsbInnerFolderListInfo.length === 0) {
          text4.visible = false;
          row4.visible = false;
        } else {
          this.traversableRows.push("Folder");
          text4.visible = true;
          row4.visible = true;
          text4.y = sumY;
          row4.y = sumY + 30;
          sumY += 243;
        }
        this._setState(this.traversableRows[0]);
      }
    }
    _focus() {
      if (this.thisDir) {
        if (this.thisDir.length > 0) {
          this.cwd = [...this.thisDir];
          let dname = this.cwd.join("/");
          usbApi.cd(dname).then(() => {
            this.loadData();
            this._setState(this.traversableRows[this.index] + ".".concat(this.currentIndex)); //focus on first element
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
      } else {
        this.index = 0;
        this.traversableRows = [];
        this.cwd = [];
        usbApi.retrieUsb().then(() => {
          this.loadData();
          this._setState(this.traversableRows[this.index]);
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      }
      // this._setState(this.traversableRows[this.index])
    }
    _unfocus() {
      //this.exitFunctionality()
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const defaultImage = 'static/images/usb/USB_Photo_Placeholder.jpg';
  class ImageViewer extends lng$1.Component {
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      this.cwd = args.cwd;
      if (this.data != undefined && this.data.length > 1) {
        this.tag('Controls').alpha = 1;
      } else {
        this.tag('Controls').alpha = 0;
      }
      if (args.src) {
        this.tag('Image').texture.src = args.src;
      }
    }
    _handleRight() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleLeft() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleBack() {
      if (this.cwd) {
        Router.navigate('usb', {
          currentIndex: this.currentIndex,
          cwd: this.cwd
        });
      } else {
        Router.back();
      }
    }
    _unfocus() {
      this.tag('Image').texture.src = defaultImage;
    }
    static _template() {
      return {
        h: 1080,
        w: 1920,
        rect: true,
        color: 0xff000000,
        zIndex: 2,
        visible: false,
        Image: {
          x: 960,
          y: 540,
          mount: 0.5,
          texture: {
            type: lng$1.textures.ImageTexture,
            src: defaultImage,
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        Controls: {
          x: 960,
          y: 930,
          h: 75,
          w: 100,
          Previous: {
            x: -50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Back_White_16k.png'
            }
          },
          Next: {
            x: 50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: lng$1.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Next_White_16k.png'
            }
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$6 = new AppApi();
  let path = '';
  class LogoScreen extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        Logo: {
          mount: 0.5,
          x: 960,
          y: 540,
          src: Utils.asset('/images/splash/RDKLogo.png')
        },
        Sub: {
          mountY: 1,
          mountX: 0.5,
          x: 960,
          y: 1000,
          w: 216,
          h: 121,
          src: Utils.asset('/images/splash/gracenote.png')
        },
        Error: {
          alpha: 0,
          type: Failscreen,
          timerVisible: false
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    async _init() {
      this.btApi = new BluetoothApi();
      await appApi$6.getPluginStatus("org.rdk.Bluetooth").then(() => this._isBluetoothExist = true).catch(() => this._isBluetoothExist = false);
      await appApi$6.getPluginStatus("org.rdk.RemoteControl").then(() => this._isRCcontrolExist = true).catch(() => this._isRCcontrolExist = false);
    }
    checkPath(path) {
      if (path === 'ui') {
        return 'ui';
      }
      return 'menu';
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Splash Screen timer end - ', new Date().toUTCString());
    }
    async _focus() {
      path = Storage$1.get('setup') === true ? 'menu' : 'splash/bluetooth';
      var map = {
        37: false,
        38: false,
        39: false,
        40: false
      };
      this.handler = e => {
        if (e.keyCode in map) {
          map[e.keyCode] = true;
          if (map[37] && map[38] && map[39] && map[40]) {
            path = 'ui';
          }
        }
      };
      Registry.addEventListener(document, 'keydown', this.handler);
      if (Storage$1.get('setup') === true) {
        this._setState('Next');
        return true;
      }
      if (!this._isBluetoothExist && !this._isRCcontrolExist) {
        this.tag('Error').notify({
          'title': "Remote control plugin and Bluetooth plugin are not found",
          'msg': 'if we want to proceed .Click Ok',
          'count': 0
        });
        this.tag('Error').isButtonVisible('OK', true);
        this.tag('Error').alpha = 1;
        this._setState('Ok');
      } else {
        if (this._isBluetoothExist) {
          await this.btApi.btactivate().then(res => {
            console.log("successfully btactivated", res);
          }).catch(err => console.log("error in btactivate"));
          this.btApi.getPairedDevices().then(devices => {
            if (devices.length > 0 || Storage$1.get('setup')) {
              path = this.checkPath(path);
            }
          }).catch(() => {
            path = this.checkPath(path);
          });
        }
        this._setState('Next');
      }
    }
    _unfocus() {
      Registry.removeEventListener(document, 'keydown', this.handler);
    }
    _handleBack() {
      console.error("Initial page; cannot go back.");
    }
    static _states() {
      return [class Ok extends this {
        _handleEnter() {
          path = 'splash/language';
          this._setState('Next');
        }
        $exit() {
          this.tag('Error').alpha = 0;
        }
      }, class Next extends this {
        $enter() {
          setTimeout(() => {
            Router.navigate(path);
          }, 5000);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$5 = new AppApi();
  var bluetoothApi = new BluetoothApi();
  const _thunder = thunderJS$1(CONFIG.thunderConfig);
  class BluetoothScreen$1 extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Bluetooth: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Pair your remote control"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex,
              fontStyle: 'bold'
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 135,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Put the remote control in pairing mode; scan will start in one moment"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            },
            visible: true
          },
          Timer: {
            x: 0,
            y: 200,
            mountX: 0.5,
            text: {
              text: "0:30",
              fontFace: CONFIG.language.font,
              fontSize: 80
            },
            visible: true
          },
          Loader: {
            x: 0,
            y: 200,
            mountX: 0.5,
            w: 110,
            h: 110,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          },
          Buttons: {
            Continue: {
              x: 0,
              y: 210,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Continue Setup"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: false
            },
            StartPairing: {
              x: 0,
              y: 410,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("SKIP"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true,
              alpha: 0.5
            }
          },
          BorderBottom: {
            x: 0,
            y: 350,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _active() {
      this.timeout = 30;
    }
    _PairingApis() {
      //bluetoothApi.btactivate().then(enableResult =>{
      //  console.log('1')
      bluetoothApi.enable().then(res => {
        console.log("SplashBluetoothScreen enable result: ", res);
        bluetoothApi.startScanBluetooth().then(startScanresult => {
          console.log('SplashBluetoothScreen startScanresult ', startScanresult);
          var SubscribeEvent = _thunder.on('org.rdk.Bluetooth', 'onDiscoveredDevice', notification => {
            bluetoothApi.getDiscoveredDevices().then(getdocoveredInfo => {
              console.log('SplashBluetoothScreen onDiscoveredDevice ', getdocoveredInfo[0].name);
              this.tag('Info').text.text = "pairing this device ".concat(getdocoveredInfo[0].name);
              //bluetoothApi.connect(getdocoveredInfo[0].deviceID, getdocoveredInfo[0].deviceType).then(connectresult=>{
              //  console.log("connectresult",connectresult)
              bluetoothApi.pair(getdocoveredInfo[0].deviceID).then(Pairresult => {
                console.log("SplashBluetoothScreen Pairresult", Pairresult);
                bluetoothApi.getConnectedDevices().then(getCdresult => {
                  console.log("SplashBluetoothScreen getConnectedDevices", getCdresult);
                  bluetoothApi.getPairedDevices().then(getpairedDevices => {
                    console.log("SplashBluetoothScreen getpairedDevices", getpairedDevices);
                    bluetoothApi.stopScan().then(stopScan => {
                      console.log("SplashBluetoothScreen stopscan", stopScan);
                      SubscribeEvent.dispose();
                      //bluetoothApi.disable().then(disable =>{
                      //console.log("disable")
                      bluetoothApi.deactivateBluetooth().then(deactivateBluetooth => {
                        console.log("SplashBluetoothScreen DeactivatedBluetooth", deactivateBluetooth);
                        if (Router.getActiveHash() === "splash/bluetooth") {
                          Router.navigate('splash/language');
                        }
                      });
                    }).catch(err => {
                      console.error("SplashBluetoothScreen cant stopscan device : ".concat(JSON.stringify(err)));
                    });
                  }).catch(err => {
                    console.error("SplashBluetoothScreen cant getpaired device : ".concat(JSON.stringify(err)));
                  });
                }).catch(err => {
                  console.error("SplashBluetoothScreen Can't getconnected device : ".concat(JSON.stringify(err)));
                });
              }).catch(err => {
                console.error("SplashBluetoothScreen Can't pair device : ".concat(JSON.stringify(err)));
              });
            });
          });
        }).catch(err => {
          console.error("Can't scan enable : ".concat(JSON.stringify(err)));
        });
      });
    }
    onStatusCB(cbData) {
      //console.log("BluetoothScreen cbData:", JSON.stringify(cbData));
      // getStatus response has 'success' property; notification payload does not have that.
      if (cbData !== undefined && (cbData.hasOwnProperty("success") ? cbData.success : true)) {
        if (cbData.status.remoteData.length) {
          //console.log("BluetoothScreen rcPairingApis RemoteData Length ", cbData.status.remoteData.length)
          cbData.status.remoteData.map(item => {
            this.tag('Info').text.text = "paired with device ".concat(item.name);
            // Do not clear this.RCTimeout if need to run this in background to reconnect on loss.
            // if (this.RCTimeout) {
            //     console.log("SplashBluetoothScreen clearTimeout(this.RCTimeout)");
            //     Registry.clearTimeout(this.RCTimeout)
            // }
            // To stop the display counter.
            if (Router.getActiveHash() === "splash/bluetooth") {
              if (this.timeInterval) {
                Registry.clearInterval(this.timeInterval);
              }
              Registry.setTimeout(() => {
                Router.navigate('splash/language');
              }, 2000);
            }
          });
        } else {
          if (cbData.status.pairingState != "SEARCHING" && cbData.status.pairingState != "PAIRING") {
            RCApi.get().startPairing(30).catch(err => {
              console.err("RCInformationScreen startPairing error:", err);
            });
          }
        }
      }
    }
    async rcPairingFlow() {
      let activatePlugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (activatePlugin) {
        await RCApi.get().activate().catch(err => {
          console.error("SplashBluetoothScreen org.rdk.RemoteControl activate error:", err);
          return;
        });
      }
      _thunder.on('org.rdk.RemoteControl', 'onStatus', data => {
        this.onStatusCB(data);
      });
      this.RCTimeout = Registry.setTimeout(() => {
        RCApi.get().getNetStatus().then(result => {
          this.onStatusCB(result);
        });
      }, 5, true);
    }
    _init() {
      appApi$5.getPluginStatus('org.rdk.RemoteControl').then(result => {
        if (result[0].state != "activated") {
          console.log("SplashBluetoothScreen init RemoteControl activate.");
          this.rcPairingFlow(true);
        } else {
          console.log("SplashBluetoothScreen init RemoteControl already activated.");
          this.rcPairingFlow();
        }
      }).catch(err => {
        console.log('SplashBluetoothScreen getPluginStatus org.rdk.RemoteControl error:', JSON.stringify(err));
        appApi$5.getPluginStatusParams('org.rdk.Bluetooth').then(pluginresult => {
          console.log("SplashBluetoothScreen getPluginStatusParams org.rdk.Bluetooth:", pluginresult[1]);
          if (pluginresult[1] === 'deactivated') {
            bluetoothApi.btactivate().then(result => {
              console.log("SplashBluetoothScreen init pairing bluetooth");
              this._PairingApis();
            });
          } else {
            console.log("SplashBluetoothScreen init status not deactivated");
            this._PairingApis();
          }
        });
      });
    }
    _active() {
      this.initTimer();
    }
    pageTransition() {
      return 'left';
    }
    initTimer() {
      this.timeInterval = Registry.setInterval(() => {
        if (this.timeout > 0) {
          --this.timeout;
        } else {
          this.timeout = 30;
        }
        this.tag('Timer').text.text = this.timeout >= 10 ? "0:".concat(this.timeout) : "0:0".concat(this.timeout);
        if (this.timeout === 0) this._setState('StartPairing');
      }, 1000);
    }
    _inactive() {
      if (this.timeInterval) {
        Registry.clearInterval(this.timeInterval);
      }
      if (this.RCTimeout) {
        Registry.clearTimeout(this.RCTimeout);
      }
    }
    static _states() {
      return [class RemotePair extends this {
        $enter() {
          this.tag('Timer').visible = true;
          this.tag('Info').text.text = Language$1.translate('Put the remote control in pairing mode; scan will start in one moment');
        }
        _handleRight() {
          this._setState('Scanning');
        }
        $exit() {
          this.tag('Timer').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class Scanning extends this {
        $enter() {
          this.tag('Loader').visible = true;
          this.tag('Info').text.text = Language$1.translate('Scanning');
        }
        _handleRight() {
          this._setState('PairComplete');
        }
        _handleLeft() {
          this._setState('RemotePair');
        }
        $exit() {
          this.tag('Loader').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class PairComplete extends this {
        $enter() {
          this.tag('Buttons.Continue').visible = true;
          this.tag('Info').text.text = Language$1.translate('Pairing Successful');
        }
        _handleLeft() {
          this._setState('Scanning');
        }
        _handleRight() {
          Router.navigate('splash/language');
        }
        $exit() {
          this.tag('Buttons.Continue').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class StartPairing extends this {
        $enter() {
          this.tag('Buttons.StartPairing').alpha = 1;
          this._focus();
        }
        _focus() {
          this.tag('Buttons.StartPairing').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Buttons.StartPairing.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _handleLeft() {}
        _handleRight() {}
        _handleEnter() {
          console.log('SplashBluetoothScreen states Start Pairing');
          Router.navigate('splash/language');
        }
        $exit() {
          this.tag('Buttons.StartPairing').alpha = 0.5;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$4 = new AppApi();
  const loader$1 = 'Loader';
  class LanguageScreen$1 extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Language: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Language"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a language"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          LanguageScreenContents: {
            x: 200 - 1000,
            y: 270,
            Languages: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            Continue: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Continue Setup"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$4.deactivateResidentApp(loader$1);
      rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
      rdkShellApisInstance.setFocus(GLOBALS.selfClientName).then(result => {
        console.log('LanguageScreen: ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('LanguageScreen: Error', err);
        Metrics.error(Metrics.ErrorType.OTHER, "AppLangugaeError", 'Thunder RDKShell setFocus Error' + JSON.stringify(err), false, null);
      });
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {}
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleDown() {
          if (this._Languages.tag('List').index < availableLanguages.length - 1) {
            this._navigate('down');
          } else {
            this._setState('Continue');
          }
        }
        _handleEnter() {
          //need to verify
          if (Language$1.get() !== availableLanguages[this._Languages.tag('List').index]) {
            let updatedLanguage = availableLanguageCodes[availableLanguages[this._Languages.tag('List').index]];
            if ("ResidentApp" === GLOBALS.selfClientName) {
              appApi$4.setUILanguage(updatedLanguage);
            } else {
              FireBoltApi.get().localization.setlanguage(availableLanguages[this._Languages.tag('List').index]).then(res => console.log("sucess language set ::::", res));
            }
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$4.launchResident(notification_url, loader$1).catch(err => {});
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
            location.reload();
          }
        }
      }, class Continue extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Continue').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Continue').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleUp() {
          this._setState('Languages');
        }
        _handleEnter() {
          Router.navigate('splash/network');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkScreen extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Network: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a network interface"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          NetworkInterfaceList: {
            x: 200 - 1000,
            y: 270,
            WiFi: {
              y: 0,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('WiFi'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Ethernet: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('Ethernet'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Skip: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Skip"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    async _init() {
      this.appApi = new AppApi();
      await this.appApi.checkStatus(Network.get().callsign).then(nwPluginStatus => {
        if (nwPluginStatus[0].state.toLowerCase() !== "activated") {
          Network.get().activate();
        }
      });
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this._setState('WiFi');
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          // this._setState('WiFiScreen')
          Network.get().setInterfaceEnabled('WIFI').then(res => {
            if (res) {
              Network.get().setDefaultInterface('WIFI').then(() => {
                Registry.setTimeout(() => {
                  Router.navigate('splash/networkList');
                }, Router.isNavigating() ? 20 : 0);
              });
            }
          });
          console.log("Wifi");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          Network.get().setInterfaceEnabled('ETHERNET').then(res => {
            if (res) {
              Network.get().setDefaultInterface('ETHERNET').then(() => {
                Network.get().getInterfaces().then(res => {
                  let eth = res.filter(item => item.interface == 'ETHERNET');
                  if (eth[0].interface == 'ETHERNET' && eth[0].enabled == true && eth[0].connected == true) {
                    Registry.setTimeout(() => {
                      Router.navigate('menu');
                    }, Router.isNavigating() ? 20 : 0);
                  } else if (eth[0].interface == 'ETHERNET' && eth[0].connected == false) {
                    Registry.setTimeout(() => {
                      Router.navigate('splash/networkPrompt');
                    }, Router.isNavigating() ? 20 : 0);
                  }
                });
              });
            }
          });
        }
        _handleDown() {
          this._setState('Skip');
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class Skip extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Skip').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Skip').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleEnter() {
          if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
            Network.get().isConnectedToInternet().then(result => {
              if (result) Registry.setTimeout(() => {
                Router.navigate('AlexaLoginScreen');
              }, Router.isNavigating() ? 20 : 0);else Registry.setTimeout(() => {
                Router.navigate('menu');
              }, Router.isNavigating() ? 20 : 0);
            });
          } else {
            Registry.setTimeout(() => {
              Router.navigate('menu');
            }, Router.isNavigating() ? 20 : 0);
          }
        }
        _handleUp() {
          this._setState('Ethernet');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Reboot Confirmation Screen.
   */
  class NetworkPromptScreen extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        PromptScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Note"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 120,
            InfoTitle: {
              x: 0,
              y: 0,
              mountX: 0.5,
              text: {
                text: Language$1.translate("Ethernet cable is not connected"),
                fontFace: CONFIG.language.font,
                fontSize: 30
              }
            }
          },
          Buttons: {
            x: 200,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            TryAgain: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Try Again"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('TryAgain');
    }
    _handleBack() {
      Registry.setTimeout(() => {
        Router.navigate('splash/networkPrompt');
      }, Router.isNavigating() ? 20 : 0);
    }
    static _states() {
      return [class TryAgain extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Registry.setTimeout(() => {
            Router.navigate('splash/network');
          }, Router.isNavigating() ? 20 : 0);
        }
        _focus() {
          this.tag('TryAgain').patch({
            color: CONFIG.theme.hex
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('TryAgain').patch({
            color: 0xFFFFFFFF
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkList extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        NetworkList: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a wifi network"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Loader: {
            visible: false,
            h: 45,
            w: 45,
            x: 0,
            // x: 320,
            mountX: 1,
            y: 200,
            mountY: 0.5,
            src: Utils.asset('images/settings/Loading.png')
          },
          Networks: {
            x: -800,
            y: 340,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            x: -800,
            y: 250,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.wifiStatus = true;
      this._wifiIcon = true;
      this.showConnectMessage = true;
      this._activateWiFi();
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._setState('JoinAnotherNetwork');
      Network.get().activate().then(result => {
        if (result) {
          Network.get()._thunder.on(Network.get().callsign, 'onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'ACQUIRED') ; else if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                Network.get().setInterfaceEnabled('ETHERNET').then(res => {
                  if (res) {
                    Network.get().setDefaultInterface('ETHERNET');
                  }
                });
              }
            }
          });
          Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.newInterfaceName === 'ETHERNET') {
              Network.get().setInterfaceEnabled('ETHERNET').then(result => {
                if (result) {
                  Network.get().setDefaultInterface('ETHERNET');
                }
              });
            } else if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              //WiFi.get().disconnect()
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              Network.get().setInterfaceEnabled('ETHERNET').then(result => {
                if (result) {
                  Network.get().setDefaultInterface('ETHERNET');
                }
              });
            } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
              console.log('emplty new old wifi');
              Network.get().setDefaultInterface('ETHERNET');
            }
          });
          Network.get()._thunder.on(Network.get().callsign, 'onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              Network.get().setInterfaceEnabled('ETHERNET').then(res => {
                if (res) {
                  Network.get().setDefaultInterface('ETHERNET');
                }
              });
            }
          });
        }
      });
    }

    /**
    * Function to be executed when the Wi-Fi screen is enabled.
    */
    _focus() {
      this.ssids = [];
      if (this.wifiStatus) {
        if (this.showConnectMessage) {
          this.tag('Info').text.text = Language$1.translate("Searching, please wait");
        }
        Wifi.get().startScan();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _unfocus() {
      Wifi.get().stopScan();
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      console.log("WIFI renderDeviceList ssids.length:", ssids.length);
      Wifi.get().getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
        } else {
          this._pairedList = [];
        }
        this.tag('Networks.AvailableNetworks').tag('List').rollMax = ssids.length * 90;
        this.tag('Networks.PairedNetworks').h = this._pairedList.length * 90;
        this.tag('Networks.PairedNetworks').tag('List').h = this._pairedList.length * 90;
        this.tag('Networks.PairedNetworks').tag('List').items = this._pairedList.map((item, index) => {
          item.connected = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
        this._otherList = ssids.filter(device => {
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this.tag('Networks.AvailableNetworks').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
      this.ssids = [];
    }
    static _states() {
      return [class PairedDevices extends this {
        $enter() {}
        _getFocused() {
          return this.tag('Networks.PairedNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
      }, class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }
        }
        _getFocused() {
          return this.tag('Networks.AvailableNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log(this.tag('Networks.AvailableNetworks').tag('List').element._item);
          Router.navigate('settings/network/interface/wifi/connect', {
            wifiItem: this.tag('Networks.AvailableNetworks').tag('List').element._item
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          // this._setState('AvailableDevices')
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          this._setState('AvailableDevices');
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
    * Function to navigate through the lists in the screen.
    * @param {string} listname
    * @param {string} dir
    */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this.tag('Networks.PairedNetworks').tag('List');else if (listname === 'AvailableDevices') list = this.tag('Networks.AvailableNetworks').tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          Wifi.get().startScan();
          this._setState('JoinAnotherNetwork');
          if (listname === 'MyDevices' && this.tag('Networks.AvailableNetworks').tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this.tag('Networks.PairedNetworks').tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }

    /**
    * Function to turn on and off Wi-Fi.
    */
    switch() {
      if (!this.wifiStatus) {
        Wifi.get().disconnect();
        console.log('turning off wifi');
        Network.get().setInterfaceEnabled('ETHERNET', true).then(result => {
          if (result) {
            Network.get().setDefaultInterface('ETHERNET', true).then(result => {
              if (result) {
                Wifi.get().disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Loader').visible = false;
                this.wifiLoading.stop();
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        //this.wifiStatus = true
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Loader').visible = true;
        Wifi.get().startScan();
      }
    }

    /**
    * Function to activate Wi-Fi plugin.
    */
    _activateWiFi() {
      Wifi.get().activate().then(() => {
        this.switch();
      });
      Wifi.get().thunder.on(Wifi.get().callsign, 'onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === WiFiState.CONNECTED && !Storage$1.get("setup")) {
          this.tag('Info').text.text = Language$1.translate("Connection successful");
          Registry.setTimeout(() => {
            Router.navigate('menu');
          }, 2000);
        } else if (notification.state === WiFiState.CONNECTING || notification.state === WiFiState.PAIRING) {
          this.tag('Info').text.text = Language$1.translate("Connecting, please wait");
        }
      });
      Wifi.get().thunder.on(Wifi.get().callsign, 'onError', error => {
        Wifi.get().startScan();
        Network.get().getDefaultInterface().then(defIface => {
          if (defIface != "ETHERNET") {
            Network.get().setInterfaceEnabled('ETHERNET').then(res => {
              if (res) {
                Network.get().setDefaultInterface('ETHERNET');
              }
            });
          }
        });
        if (error.code === WiFiError.INVALID_CREDENTIALS || error.code === WiFiError.SSID_CHANGED || error.code === WiFiError.CONNECTION_FAILED || error.code === WiFiError.CONNECTION_INTERRUPTED) {
          // Show error message.
          this.tag('Info').text.text = Language$1.translate(WiFiErrorMessages[error.code]);
        }
      });
      Wifi.get().thunder.on(Wifi.get().callsign, 'onAvailableSSIDs', notification => {
        this.ssids = [...this.ssids, ...notification.ssids];
        if (!notification.moreData) {
          if (this.showConnectMessage) {
            this.showConnectMessage = false;
            this.tag('Info').text.text = Language$1.translate("Select a network to connect");
          }
          this.renderDeviceList(this.ssids);
          setTimeout(() => {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var splashScreenRoutes = {
    splashScreenRoutes: [{
      path: 'splash',
      component: LogoScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/bluetooth',
      component: BluetoothScreen$1,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/language',
      component: LanguageScreen$1,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/network',
      component: NetworkScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/networkPrompt',
      component: NetworkPromptScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/networkList',
      component: NetworkList,
      widgets: ['Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for rendering items in UI list.
   */
  class Item extends lng$1.Component {
    static _template() {
      return {
        Item: {
          w: 300,
          h: 150,
          rect: true,
          color: 0xFFDBEBFF,
          shader: {
            type: lng$1.shaders.RoundedRectangle,
            radius: 10
          }
        },
        OperatorLogo: {},
        Shadow: {
          alpha: 0,
          zIndex: 2,
          x: -25,
          y: -25,
          color: 0x66000000,
          texture: lng.Tools.getShadowRect(350, 180, 10, 10, 20)
        }
      };
    }

    /**
     * Function to set contents for an item in UI list.
     */
    set item(item) {
      this._item = item;
      this.tag('OperatorLogo').patch({
        Logo: {
          w: 300,
          h: 150,
          zIndex: 3,
          src: Utils.asset(this._item.url)
        }
      });
    }
    _focus() {
      this.tag('Item').zIndex = 3;
      this.tag('Item').scale = 1.2;
      this.tag('Item').color = 0xFFFFFFFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 1
        }
      });
    }
    _unfocus() {
      this.tag('Item').zIndex = 1;
      this.tag('Item').scale = 1;
      this.tag('Item').color = 0xFFDBEBFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const homeApi$2 = new HomeApi();
  class UIList extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        src: Utils.asset('images/splash/Splash-Background.jpg'),
        UI: {
          x: 200,
          y: 465,
          type: List,
          spacing: 20,
          direction: 'row',
          scroll: {
            after: 4
          }
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    _firstEnable() {
      this.tag('UI').add(homeApi$2.getUIInfo().map((element, idx) => {
        return {
          ref: 'UI' + idx,
          w: 300,
          h: 150,
          type: Item,
          item: element,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    _getFocused() {
      return this.tag('UI');
    }
    _handleEnter() {
      if (this.tag('UI').currentItem._item.title != 'DEFAULT') {
        console.log('Redirect to url');
        return;
      }
      Router.navigate('menu');
    }
  }

  function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
          var i = n[a](c), u = i.value;
      } catch (n) {
          return void e(n);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
  }

  function _asyncToGenerator(n) {
      return function() {
          var t = this, e = arguments;
          return new Promise((function(r, o) {
              var a = n.apply(t, e);
              function _next(n) {
                  asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
              }
              function _throw(n) {
                  asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
              }
              _next(void 0);
          }));
      };
  }

  function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter((function(r) {
              return Object.getOwnPropertyDescriptor(e, r).enumerable;
          }))), t.push.apply(t, o);
      }
      return t;
  }

  function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), !0).forEach((function(r) {
              _defineProperty(e, r, t[r]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach((function(r) {
              Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
          }));
      }
      return e;
  }

  function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
      }) : e[r] = t, e;
  }

  function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == typeof i ? i : i + "";
  }

  function _toPrimitive(t, r) {
      if ("object" != typeof t || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != typeof i) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
  }

  class Logger {
      constructor() {
          this._logCallback = undefined;
          this._prefix = "LightningUI";
          this._debug = false;
      }
      get debug() {
          return this._debug;
      }
      set debug(value) {
          this._debug = Boolean(value);
      }
      get logCallback() {
          return this._logCallback;
      }
      set logCallback(value) {
          if ("function" !== typeof value) {
              this.warn("logCallback value must be a function, instead received ".concat(typeof value));
              return;
          }
          this._logCallback = value;
      }
      log() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
          }
          if (this._logCallback) {
              this._logCallback({
                  level: "log",
                  payload: args
              });
          }
          if (this.debug) {
              console.log(this._prefix, ...args);
          }
      }
      info() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
          }
          if (this._logCallback) {
              this._logCallback({
                  level: "info",
                  payload: args
              });
          }
          if (this.debug) {
              console.info(this._prefix, ...args);
          }
      }
      warn() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
          }
          if (this._logCallback) {
              this._logCallback({
                  level: "warn",
                  payload: args
              });
          }
          if (this.debug) {
              console.warn(this._prefix, ...args);
          }
      }
      error() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
          }
          if (this._logCallback) {
              this._logCallback({
                  level: "error",
                  payload: args
              });
          }
          if (this.debug) {
              console.error(this._prefix, ...args);
          }
      }
  }

  var loggerInstance = new Logger;

  function isComponentOnScreen(component) {
      var offsets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!component) return false;
      var {w: w, h: h, core: {renderContext: {px: px, py: py}, _scissor: scissor = []} = {}} = component;
      var stageH = component.stage.h / component.stage.getRenderPrecision();
      var stageW = component.stage.w / component.stage.getRenderPrecision();
      var finalX = px;
      var finalY = py;
      var relativeOffsetX = px - component.x;
      var relativeOffsetY = py - component.y;
      var offsetX = offsets.offsetX - relativeOffsetX || 0;
      var offsetY = offsets.offsetY - relativeOffsetY || 0;
      if (component.transition("x")) {
          finalX = px - component.x + component.transition("x").targetValue;
      }
      if (component.transition("y")) {
          finalY = py - component.y + component.transition("y").targetValue;
      }
      finalX += offsetX;
      finalY += offsetY;
      var wVis = finalX >= 0 && finalX + w <= stageW;
      var hVis = finalY >= 0 && finalY + h <= stageH;
      if (!wVis || !hVis) return false;
      if (scissor && scissor.length) {
          var [leftBounds = null, topBounds = null, clipWidth = null, clipHeight = null] = scissor;
          var withinLeftClippingBounds = Math.round(finalX + w) >= Math.round(leftBounds);
          var withinRightClippingBounds = Math.round(finalX) <= Math.round(leftBounds + clipWidth);
          var withinTopClippingBounds = Math.round(finalY + h) >= Math.round(topBounds);
          var withinBottomClippingBounds = Math.round(finalY + h) <= Math.round(topBounds + clipHeight);
          return withinLeftClippingBounds && withinRightClippingBounds && withinTopClippingBounds && withinBottomClippingBounds;
      }
      return true;
  }

  function getWidthByUpCount(theme) {
      var upCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var screenW = theme.layout.screenW;
      var columnCount = theme.layout.columnCount;
      var marginX = theme.layout.marginX;
      var gutterX = theme.layout.gutterX;
      if (upCount < 1 || upCount > columnCount) {
          console.error("Column expects a number between 1 & ".concat(columnCount, ". Received ").concat(upCount));
          return;
      }
      var columnWidth = screenW - marginX * 2;
      var columnGapTotal = (upCount - 1) * gutterX;
      var totalColumnsWidth = columnWidth - columnGapTotal;
      return totalColumnsWidth / upCount;
  }

  function getWidthByColumnSpan(theme, columnSpan) {
      var columnCount = theme.layout.columnCount;
      var gutterX = theme.layout.gutterX;
      return getWidthByUpCount(theme, columnCount) * columnSpan + gutterX * (columnSpan - 1);
  }

  function getDimensions(theme) {
      var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var {w: w, h: h, ratioX: ratioX, ratioY: ratioY, upCount: upCount} = obj;
      var fallbackW = fallback.w || 0;
      var fallbackH = fallback.h || 0;
      var dimensions = {};
      if (w && h) {
          dimensions = {
              w: w,
              h: h
          };
      } else if (h && ratioX && ratioY) {
          dimensions = {
              w: Math.round(h * ratioX / ratioY),
              h: h
          };
      } else if (ratioX && ratioY && upCount) {
          dimensions = getItemRatioDimensions(theme, ratioX, ratioY, upCount);
      } else if (h && upCount) {
          dimensions = {
              w: Math.round(getWidthByUpCount(theme, upCount)),
              h: h
          };
      } else if (h) {
          dimensions = {
              w: fallbackW,
              h: h
          };
      } else if (w) {
          dimensions = {
              w: w,
              h: fallbackH
          };
      } else {
          dimensions = {
              w: fallbackW,
              h: fallbackH
          };
      }
      dimensions = _objectSpread(_objectSpread({}, dimensions), {}, {
          ratioX: ratioX,
          ratioY: ratioY,
          upCount: upCount
      });
      return dimensions;
  }

  function getItemRatioDimensions(theme, ratioX, ratioY, upCount) {
      var w, h;
      if (ratioX && ratioY && upCount) {
          w = Math.round(getWidthByUpCount(theme, upCount));
          h = Math.round(w / ratioX * ratioY);
      } else {
          w = 0;
          h = 0;
      }
      return {
          w: w,
          h: h
      };
  }

  function getAspectRatioW(h) {
      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "16:9";
      var seperator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ":";
      var [ratioW, ratioH] = ratio.split(seperator);
      return h * (ratioW / ratioH);
  }

  function getAspectRatioH(w) {
      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "16:9";
      var seperator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ":";
      var [ratioW, ratioH] = ratio.split(seperator);
      return w / (ratioW / ratioH);
  }

  function getHexColor(hex) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (!hex) {
          return 0;
      }
      if (typeof hex === "number") {
          hex = hex.toString(16).slice(2);
      }
      hex = hex.replace("#", "");
      var hexAlpha = Math.round(alpha * 255).toString(16);
      var str = "0x".concat(hexAlpha).concat(hex);
      return Number(str);
  }

  function getValidColor(color) {
      if (typeof color === "string" || typeof color === "number") {
          if (/^0x[0-9a-fA-F]{8}/g.test(color)) {
              return Number(color);
          } else if (/^#[0-9a-fA-F]{6}/g.test(color)) {
              return getHexColor(color.substr(1, 6));
          } else if (typeof color === "string" && /^[0-9]{8,10}/g.test(color)) {
              return parseInt(color);
          } else if (typeof color === "number" && /^[0-9]{8,10}/g.test(color.toString())) {
              return color;
          } else if (typeof color === "string" && color.indexOf("rgba") > -1) {
              return rgba2argb(color);
          } else if (typeof color === "string" && color.indexOf("rgb") > -1) {
              var rgba = [ ...color.replace(/rgb\(|\)/g, "").split(","), "255" ];
              return lng$1.StageUtils.getArgbNumber(rgba);
          }
      }
      return null;
  }

  function simplifyFraction(_ref) {
      var [numerator, denominator] = _ref;
      for (var i = numerator; i > 0; i--) {
          if (!(numerator % i) && !(denominator % i)) {
              return [ numerator / i, denominator / i ];
          }
      }
  }

  function reduceFraction(string) {
      return simplifyFraction(string.split("/").map((n => +n))).join("/");
  }

  var getValFromObjPath = (object, path) => {
      if (typeof path === "string") path = path.split(".").filter((key => key.length));
      return path.reduce(((dive, key) => dive && dive[key]), object);
  };

  function rgba2argb(rgbaStr) {
      var rgba = rgbaStr.replace(/rgba\(|\)/g, "").split(",");
      rgba[3] = rgba[3] * 255;
      return lng$1.StageUtils.getArgbNumber(rgba);
  }

  function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
  }

  var RoundRect = {
      getWidth(w) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var {padding: padding, paddingLeft: paddingLeft, paddingRight: paddingRight, strokeWidth: strokeWidth} = _objectSpread({
              padding: 0,
              paddingLeft: 0,
              paddingRight: 0,
              strokeWidth: 0
          }, options);
          if (!w) return 0;
          return w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth;
      },
      getHeight(h) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var {padding: padding, paddingBottom: paddingBottom, paddingTop: paddingTop, strokeWidth: strokeWidth} = _objectSpread({
              padding: 0,
              paddingBottom: 0,
              paddingTop: 0,
              strokeWidth: 0
          }, options);
          if (!h) return 0;
          return h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth;
      }
  };

  function clone(target, object) {
      var _clone = Object.create(Object.getPrototypeOf(target));
      Object.defineProperties(_clone, Object.getOwnPropertyDescriptors(target));
      if (!object || target === object) return _clone;
      for (var key in object) {
          var value = object[key];
          if (target.hasOwnProperty(key)) {
              _clone[key] = getMergeValue(key, target, object);
          } else {
              _clone[key] = value;
          }
      }
      return _clone;
  }

  function getMergeValue(key, target, object) {
      var targetVal = target[key];
      var objectVal = object[key];
      var targetValType = typeof targetVal;
      var objectValType = typeof objectVal;
      if (targetValType !== objectValType || objectValType === "function" || Array.isArray(objectVal)) {
          return objectVal;
      }
      if (objectVal && objectValType === "object") {
          return clone(targetVal, objectVal);
      }
      return objectVal;
  }

  function measureTextWidth() {
      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      var {fontStyle: fontStyle, fontWeight: fontWeight, fontSize: fontSize, fontFamily: fontFamily = text.fontFace || "sans-serif"} = text;
      var fontCss = [ fontStyle, fontWeight, fontSize ? "".concat(fontSize, "px") : "0", "'".concat(fontFamily, "'") ].filter(Boolean).join(" ");
      ctx.font = fontCss;
      var textMetrics = ctx.measureText(text.text || "");
      return Math.round(textMetrics.width);
  }

  function getFirstNumber() {
      for (var _len5 = arguments.length, numbers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          numbers[_key5] = arguments[_key5];
      }
      return numbers.find(Number.isFinite);
  }

  function getDimension(prop, component) {
      if (!component) return 0;
      var transition = component.transition(prop);
      if (transition.isRunning()) return transition.targetValue;
      var renderProp = prop;
      if (prop === "w") {
          renderProp = "renderWidth";
      } else if (prop === "h") {
          renderProp = "renderHeight";
      }
      return component[renderProp] || component[prop];
  }

  function flatten(arr) {
      return arr.reduce(((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten)), []);
  }

  function objectPropertyOf(object, path) {
      return path.reduce(((obj, key) => obj && obj[key] !== "undefined" ? obj[key] : undefined), object);
  }

  function stringifyCompare(objA, objB) {
      return JSON.stringify(objA) === JSON.stringify(objB);
  }

  function delayForAnimation(callback) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
      setTimeout(callback, delay);
  }

  function downloadFile(content, fileName, contentType) {
      var validContentTypes = [ "plain", "json" ];
      if (!validContentTypes.includes(contentType)) {
          contentType = "plain";
      }
      var dataStr = "data:text/".concat(contentType, ";charset=utf-8,") + encodeURIComponent(JSON.stringify(content));
      var dlAnchorElem = document.createElement("a");
      dlAnchorElem.setAttribute("href", dataStr);
      dlAnchorElem.setAttribute("download", fileName);
      dlAnchorElem.click();
  }

  var degreesToRadians = deg => deg * (Math.PI / 180);

  var MARKUP_STRING_PATTERN = /({ICON.*?}|{BADGE:.*?}|{NEWLINE}|{TEXT:.*?})/g;

  function isMarkupString() {
      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      if (typeof str !== "string") {
          return false;
      }
      return MARKUP_STRING_PATTERN.test(str);
  }

  function createConditionalZContext(component, zOffset) {
      if (!component.zIndex && typeof zOffset !== "undefined" && zOffset !== 0) {
          component.forceZIndexContext = true;
          component.zIndex = 0;
      }
  }

  function watchForUpdates(_ref2) {
      var _element$__core;
      var {element: element, watchProps: watchProps = [], sideEffect: sideEffect = () => {}} = _ref2;
      if (!(element !== null && element !== void 0 && element.isElement)) {
          loggerInstance.error("watchForUpdates: Expected a Lightning Element passed to element parameter, received ".concat(typeof element));
      }
      var initialOnAfterUpdate = (_element$__core = element.__core) === null || _element$__core === void 0 ? void 0 : _element$__core._onAfterUpdate;
      element.onAfterUpdate = function(element) {
          var hasChanged = false;
          watchProps.forEach((prop => {
              if (element.transition(prop) && element.transition(prop).isRunning()) {
                  return;
              }
              var prevValueKey = "__watchPrev".concat(prop);
              var nextValue = element[prop];
              if (nextValue !== element[prevValueKey]) {
                  element[prevValueKey] = nextValue;
                  hasChanged = true;
              }
          }));
          if (hasChanged) {
              sideEffect();
          }
          if (initialOnAfterUpdate) {
              initialOnAfterUpdate(element);
          }
      }.bind(this);
      return element;
  }

  function convertTextAlignToFlexJustify(align) {
      switch (align) {
        case "left":
          return "flex-start";

        case "center":
          return "center";

        case "right":
          return "flex-end";

        default:
          console.warn('Expected "textAlign" values are "left," "center," and "right," but instead, '.concat(align, ' was received and will fall back to "left."'));
          return "flex-start";
      }
  }

  function getMaxRoundRadius(radius, width, height) {
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var maxRadius = r => Math.max(0, Math.min(r, Math.min(width, height) / 2) + offset);
      return Array.isArray(radius) ? radius.map((r => Number(maxRadius(r)) || 0)) : Number(maxRadius(radius)) || 0;
  }

  var utils = {
      isMarkupString: isMarkupString,
      capitalizeFirstLetter: capitalizeFirstLetter,
      degreesToRadians: degreesToRadians,
      downloadFile: downloadFile,
      delayForAnimation: delayForAnimation,
      stringifyCompare: stringifyCompare,
      objectPropertyOf: objectPropertyOf,
      flatten: flatten,
      getDimension: getDimension,
      getFirstNumber: getFirstNumber,
      measureTextWidth: measureTextWidth,
      clone: clone,
      getMergeValue: getMergeValue,
      RoundRect: RoundRect,
      rgba2argb: rgba2argb,
      getValFromObjPath: getValFromObjPath,
      reduceFraction: reduceFraction,
      getValidColor: getValidColor,
      getHexColor: getHexColor,
      getAspectRatioH: getAspectRatioH,
      getAspectRatioW: getAspectRatioW,
      getWidthByUpCount: getWidthByUpCount,
      getDimensions: getDimensions,
      getWidthByColumnSpan: getWidthByColumnSpan,
      createConditionalZContext: createConditionalZContext,
      watchForUpdates: watchForUpdates,
      convertTextAlignToFlexJustify: convertTextAlignToFlexJustify,
      getMaxRoundRadius: getMaxRoundRadius
  };

  var utils$1 = utils;

  class Metrics$1 {
      constructor() {
          this._keyMetricsCallback = undefined;
      }
      get keyMetricsCallback() {
          return this._keyMetricsCallback;
      }
      set keyMetricsCallback(value) {
          if (-1 < [ "undefined", "function" ].indexOf(typeof value)) {
              this._keyMetricsCallback = value;
              return;
          }
          loggerInstance.warn("context keyMetricsCallback expected a function. Received ".concat(typeof value));
      }
  }

  var metricsInstance = new Metrics$1;

  var eventEmitterInstance = new lng$1.EventEmitter;

  var events = eventEmitterInstance;

  var baseTheme = {
      name: "Base Lightning TV",
      alpha: {
          primary: 1,
          secondary: .7,
          tertiary: .1,
          inactive: .5,
          full: 1,
          none: 0,
          alpha1: .1,
          alpha2: .3,
          alpha3: .5,
          alpha4: .7,
          alpha5: .9
      },
      animation: {
          duration: {
              none: 0,
              xfast: .1,
              fast: .25,
              normal: .5,
              slow: .75,
              xslow: .9
          },
          delay: {
              none: 0,
              xfast: .01,
              fast: .025,
              normal: .05,
              slow: .075,
              xslow: .09
          },
          expressive: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          expressiveEntrance: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          expressiveExit: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          standard: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          standardEntrance: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          standardExit: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          utility: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          utilityEntrance: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          },
          utilityExit: {
              timingFunction: "cubic-bezier(0, 0, 1, 1)",
              delay: 0,
              duration: .25
          }
      },
      asset: {
          arrowLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAi0lEQVRIDWNgGAWjIfD//38JID5Fk5AAGqwKxPeA+D/VLQCaaQLEr0CGgwBVLQCa5wbEn0EGwwDVLAAaGA3Ev2AGw2iqWAA0rBiI/8EMRaYptgBoWDeygehsci1gIlcjWfqArqZdEMFcBLSEdpGMZAntkimSJbTLaEiW0K6oQLKEdoUdzJJRemiHAAD4n+yzPWCs7QAAAABJRU5ErkJggg==",
          arrowRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAg0lEQVRIDWNgGAWjIYArBP7//38KiCVwyVMsDjQcBO4BsSrFhmEzAGw8hHgFpEywqaFIDMkCEPMzELtRZCC6ZjQLQNxfQByNro5sPhYLQEL/gLiYbEORNeKwACbcDVPLBGMMOhrmVDSapkFE00imaTKlaUajaVFB28Ju0CXrUQfhDAEAEgHss6NhpLQAAAAASUVORK5CYII=",
          backspaceOutline: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC",
          check: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAYAAAAi2ky3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACtSURBVHgBvdPdDcIgEAfwoy8Nb45QN3AGF2s36Ahu4gpuIDoBfSgfpdoTlCbEWEMh6T8hFzjyg5AAkBHOcQe5UWqspRx435sDpMYj6IYQwwVSEiJ2MKVUBWuzLSLl2HL+uxmNCGFO8yaL7RHxve6qRZoAuS4hxac8735elWVx7jrtMKL1o0Gcat9jhExHSukN/kUIFZ7MpDRtzE1isDRkAUtDvrA8ZI597FUf8gWH9P0b4gko9wAAAABJRU5ErkJggg=="
      },
      color: {
          white: [ "#ffffff", 1 ],
          black: [ "#000000", 1 ],
          grey: [ "#929096", 1 ],
          red: [ "#e74c3c", 1 ],
          orange: [ "#dc7633", 1 ],
          yellow: [ "#f7dc6f", 1 ],
          green: [ "#2Ecc71", 1 ],
          blue: [ "#93a9fd", 1 ],
          purple: [ "#663399", 1 ],
          palette: {
              "grey-05": [ "#f8f7fa", 1 ],
              "grey-40": [ "#929096", 1 ],
              "grey-70": [ "#48474b", 1 ],
              "grey-90": [ "#181819", 1 ],
              "blue-20": [ "#becffe", 1 ],
              "blue-40": [ "#93a9fd", 1 ],
              "blue-90": [ "#000033", 1 ]
          },
          material: [ "#181819", 1 ],
          materialBrand: [ "#000033", 1 ],
          overlay: [ "#181819", .7 ],
          textNeutral: [ "#f8f7fa", 1 ],
          textNeutralSecondary: [ "#f8f7fa", .7 ],
          textNeutralTertiary: [ "#f8f7fa", .1 ],
          textNeutralDisabled: [ "#f8f7fa", .5 ],
          textInverse: [ "#181819", 1 ],
          textInverseSecondary: [ "#181819", .7 ],
          textInverseTertiary: [ "#181819", .1 ],
          textInverseDisabled: [ "#181819", .5 ],
          textBrand: [ "#93a9fd", 1 ],
          textBrandSecondary: [ "#93a9fd", .7 ],
          textBrandTertiary: [ "#93a9fd", .1 ],
          textBrandDisabled: [ "#93a9fd", .5 ],
          textPositive: [ "#2Ecc71", 1 ],
          textNegative: [ "#e74c3c", 1 ],
          textInfo: [ "#93a9fd", 1 ],
          textCaution: [ "#dc7633", 1 ],
          fillTransparent: [ "#ffffff", 0 ],
          fillNeutral: [ "#f8f7fa", 1 ],
          fillNeutralSecondary: [ "#f8f7fa", .7 ],
          fillNeutralTertiary: [ "#f8f7fa", .1 ],
          fillNeutralDisabled: [ "#f8f7fa", .5 ],
          fillInverse: [ "#181819", 1 ],
          fillInverseSecondary: [ "#181819", .7 ],
          fillInverseTertiary: [ "#181819", .1 ],
          fillInverseDisabled: [ "#181819", .5 ],
          fillBrand: [ "#93a9fd", 1 ],
          fillBrandSecondary: [ "#93a9fd", .7 ],
          fillBrandTertiary: [ "#93a9fd", .1 ],
          fillBrandDisabled: [ "#93a9fd", .5 ],
          fillPositive: [ "#2Ecc71", 1 ],
          fillNegative: [ "#e74c3c", 1 ],
          fillInfo: [ "#93a9fd", 1 ],
          fillCaution: [ "#dc7633", 1 ],
          strokeNeutral: [ "#f8f7fa", 1 ],
          strokeNeutralSecondary: [ "#f8f7fa", .7 ],
          strokeNeutralTertiary: [ "#f8f7fa", .1 ],
          strokeNeutralDisabled: [ "#f8f7fa", .5 ],
          strokeInverse: [ "#181819", 1 ],
          strokeInverseSecondary: [ "#181819", .7 ],
          strokeInverseTertiary: [ "#181819", .1 ],
          strokeInverseDisabled: [ "#181819", .5 ],
          strokeBrand: [ "#93a9fd", 1 ],
          strokeBrandSecondary: [ "#93a9fd", .7 ],
          strokeBrandTertiary: [ "#93a9fd", .1 ],
          strokeBrandDisabled: [ "#93a9fd", .5 ],
          strokePositive: [ "#2Ecc71", 1 ],
          strokeNegative: [ "#e74c3c", 1 ],
          strokeInfo: [ "#93a9fd", 1 ],
          strokeCaution: [ "#dc7633", 1 ],
          interactiveNeutral: [ "#ffffff", .1 ],
          interactiveNeutralFocus: [ "#ffffff", 1 ],
          interactiveNeutralFocusSoft: [ "#ffffff", .1 ],
          interactiveInverse: [ "#48474b", undefined ],
          interactiveInverseFocus: [ "#48474b", 1 ],
          interactiveInverseFocusSoft: [ "#48474b", .1 ],
          interactiveBrand: [ "#becffe", .1 ],
          interactiveBrandFocus: [ "#becffe", 1 ],
          interactiveBrandFocusSoft: [ "#becffe", .1 ],
          shadowNeutral: [ "#000000", .7 ],
          shadowNeutralFocus: [ "#000000", .7 ],
          shadowNeutralFocusSoft: [ "#000000", .7 ],
          shadowNeutralText: [ "#000000", 1 ],
          shadowInverse: [ "#000000", .7 ],
          shadowInverseFocus: [ "#000000", .7 ],
          shadowInverseFocusSoft: [ "#000000", .7 ],
          shadowInverseText: [ "#000000", 1 ],
          shadowBrand: [ "#000000", .7 ],
          shadowBrandFocus: [ "#000000", .7 ],
          shadowBrandFocusSoft: [ "#000000", .7 ],
          shadowBrandText: [ "#000000", 1 ]
      },
      componentConfig: {
          Keyboard: {
              style: {
                  keyProps: {
                      delete: {
                          title: null,
                          icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC"
                      }
                  }
              }
          }
      },
      font: [],
      layout: {
          columnCount: 10,
          focusScale: 1.2,
          gutterX: 20,
          gutterY: 20,
          marginX: 150,
          marginY: 150,
          safe: 50,
          screenW: 1920,
          screenH: 1080
      },
      radius: {
          none: 0,
          xs: 2,
          sm: 4,
          md: 8,
          lg: 16,
          xl: 24
      },
      spacer: {
          none: 0,
          xxs: 2,
          xs: 4,
          sm: 8,
          md: 10,
          lg: 20,
          xl: 30,
          xxl: 40,
          xxxl: 50
      },
      stroke: {
          none: 0,
          sm: 2,
          md: 4,
          lg: 6,
          xl: 8
      },
      typography: {
          display1: {
              fontFamily: "Arial",
              fontSize: 75,
              lineHeight: 85,
              fontStyle: "500",
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          display2: {
              fontFamily: "Arial",
              fontSize: 50,
              lineHeight: 60,
              fontStyle: "500",
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          headline1: {
              fontFamily: "Arial",
              fontSize: 35,
              fontStyle: "500",
              lineHeight: 48,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          headline2: {
              fontFamily: "Arial",
              fontSize: 30,
              fontStyle: "500",
              lineHeight: 40,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          headline3: {
              fontFamily: "Arial",
              fontSize: 25,
              fontStyle: "500",
              lineHeight: 36,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          body1: {
              fontFamily: "Arial",
              fontSize: 25,
              fontStyle: "300",
              lineHeight: 40,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          body2: {
              fontFamily: "Arial",
              fontSize: 22,
              fontStyle: "300",
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          body3: {
              fontFamily: "Arial",
              fontSize: 20,
              fontStyle: "300",
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          button1: {
              fontFamily: "Arial",
              fontSize: 25,
              fontStyle: "500",
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          button2: {
              fontFamily: "Arial",
              fontSize: 20,
              fontStyle: "500",
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          callout1: {
              fontFamily: "Arial",
              fontSize: 20,
              fontStyle: "500",
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          caption1: {
              fontFamily: "Arial",
              fontSize: 15,
              fontStyle: "500",
              lineHeight: 24,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          tag1: {
              fontFamily: "Arial",
              fontSize: 20,
              fontStyle: "500",
              lineHeight: 24,
              verticalAlign: "middle",
              textBaseline: "bottom"
          },
          footnote1: {
              fontFamily: "Arial",
              fontSize: 22,
              fontStyle: "300",
              lineHeight: 30,
              verticalAlign: "middle",
              textBaseline: "bottom"
          }
      }
  };

  var customFontFaces = [];

  var fontLoader = fonts => {
      var promises = [];
      var _loop = function _loop() {
          var {family: family, src: src, descriptors: descriptors} = fonts[i];
          var fontSrc = src && Array.isArray(src) && src.length ? src.map((url => url.substr(0, 5) === "local" ? url : "url(".concat(url, ")"))).join(",") : "url(" + src + ")";
          var fontFace = new FontFace(family, fontSrc, descriptors || {});
          loggerInstance.info("Loading font", family);
          document.fonts.add(fontFace);
          promises.push(new Promise((resolve => {
              fontFace.load().then((() => {
                  customFontFaces.push(fontFace);
                  resolve(family);
              })).catch((err => {
                  resolve(new Error("".concat(family, ": ").concat(err.message)));
              }));
          })));
      };
      for (var i = 0; i < fonts.length; i++) {
          _loop();
      }
      return Promise.all(promises).then((fontsLoaded => {
          var loaded = fontsLoaded.filter((font => !(font instanceof Error))).join(", ");
          if (loaded) {
              loggerInstance.log("Fonts loaded: ".concat(loaded));
          }
          var failed = fontsLoaded.filter((font => font instanceof Error)).map((item => item.message)).join(", ");
          if (failed) {
              loggerInstance.error("Unable to load fonts: ".concat(failed));
          }
      }));
  };

  var cleanupFonts = function() {
      var _ref3 = _asyncToGenerator((function*(fonts) {
          if (document.fonts && "delete" in document.fonts) {
              if (!customFontFaces.length) return;
              customFontFaces = customFontFaces.filter((fontFace => {
                  if (!fonts.find((font => font.family === fontFace.family))) {
                      loggerInstance.info("Removing font", fontFace.family);
                      document.fonts.delete(fontFace);
                      return false;
                  } else {
                      return fontFace;
                  }
              }));
          } else {
              loggerInstance.info("Unable to remove manually-added fonts");
          }
      }));
      return function cleanupFonts(_x) {
          return _ref3.apply(this, arguments);
      };
  }();

  var THEME_KEY_REPLACER = {
      fontFamily: "fontFace"
  };

  var merge = {
      all: objArray => {
          var result = {};
          for (var i = 0; i < objArray.length; i++) {
              result = clone(result, objArray[i]);
          }
          return result;
      }
  };

  var base64Cache = [];

  var isSubTheme = themeName => "subTheme" === themeName.slice(0, 8);

  function getMimeTypeFromDataUri(dataUri) {
      var matches = dataUri.match(/^data:(.*?);base64,/);
      if (matches && matches.length === 2) {
          return matches[1];
      }
      return null;
  }

  function checkBase64EncodedImage(str) {
      var regex = /^data:image\/(jpeg|jpg|png|gif);base64,/;
      var isImage = regex.test(str);
      var mimeType = isImage ? getMimeTypeFromDataUri(str.match(regex)[0]) : null;
      return {
          isImage: isImage,
          mimeType: mimeType
      };
  }

  function base64ToBlobURL(base64String, mimeType) {
      var byteCharacters = atob(base64String.substring(base64String.indexOf(",") + 1));
      var byteArrays = [];
      try {
          for (var offset = 0; offset < byteCharacters.length; offset += 512) {
              var slice = byteCharacters.slice(offset, offset + 512);
              var byteNumbers = new Array(slice.length);
              for (var i = 0; i < slice.length; i++) {
                  byteNumbers[i] = slice.charCodeAt(i);
              }
              var byteArray = new Uint8Array(byteNumbers);
              byteArrays.push(byteArray);
          }
          var blob = new Blob(byteArrays, {
              type: mimeType
          });
          var blobURL = URL.createObjectURL(blob);
          return blobURL;
      } catch (error) {
          loggerInstance.info("Unable to convert base64 image to URL");
          return null;
      }
  }

  class ThemeManager {
      constructor() {
          this._cache = new Map;
          if (typeof window === "undefined") return;
          if (!window.LUI) {
              window.LUI = {};
          }
          if (!window.LUI.themeManagerInstances) {
              window.LUI.themeManagerInstances = [ {
                  themeManager: this,
                  events: events
              } ];
          } else {
              window.LUI.themeManagerInstances.push({
                  themeManager: this,
                  events: events
              });
          }
      }
      _setCache(key, payload) {
          if (typeof window === "undefined") return;
          window.LUI.themeManagerInstances.forEach((_ref4 => {
              var {themeManager: themeManager} = _ref4;
              if (themeManager) themeManager._cache.set(key, payload);
          }));
      }
      _deleteCache(key) {
          if (typeof window === "undefined") return;
          window.LUI.themeManagerInstances.forEach((_ref5 => {
              var {themeManager: themeManager} = _ref5;
              if (themeManager) themeManager._cache.delete(key);
          }));
      }
      _emit(key, payload) {
          if (typeof window === "undefined") return;
          window.LUI.themeManagerInstances.forEach((_ref6 => {
              var {events: events} = _ref6;
              events.emit(key, payload);
          }));
      }
      getTheme() {
          if (this._cache.has("theme")) {
              return this._cache.get("theme");
          }
          var theme = this._processTheme.call(this);
          this._setCache("theme", theme);
          return theme;
      }
      setTheme(themeConfig) {
          var _this = this;
          return _asyncToGenerator((function*() {
              var value;
              if (Array.isArray(themeConfig)) {
                  value = merge.all(themeConfig);
              } else {
                  value = themeConfig;
              }
              if ("object" !== typeof value || null === value) {
                  loggerInstance.warn("context theme expected an object. Received ".concat(typeof value));
                  return;
              }
              _this._clearCache();
              var theme = _this._processTheme.call(_this, [ value ], value.extensions);
              _this._setCache("theme", theme);
              yield cleanupFonts(theme.font);
              if (theme.font && theme.font.length) {
                  yield _this._loadFonts(theme.font);
              }
              _this._refreshSubThemes();
              _this._emit("themeExtensionsUpdate");
              _this._emit("themeUpdate");
              return theme;
          }))();
      }
      getSubTheme(subThemeName) {
          if (this._cache.has("subTheme".concat(subThemeName))) {
              return this._cache.get("subTheme".concat(subThemeName)).result;
          }
          return;
      }
      setSubTheme(subThemeName, value) {
          var _arguments = arguments, _this2 = this;
          return _asyncToGenerator((function*() {
              var triggerUpdate = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : true;
              if (!subThemeName) {
                  loggerInstance.warn("Sub theme name not specified");
                  return;
              }
              if ("string" !== typeof subThemeName) {
                  loggerInstance.warn("Sub theme name must be a string. Received an ".concat(typeof subThemeName));
                  return;
              }
              if ("object" !== typeof value || !Object.keys(value).length) {
                  loggerInstance.warn("Could not set subTheme ".concat(subThemeName, ", value should be an object with properties. Received an ").concat(typeof value));
                  return;
              }
              var globalTheme = _this2.getTheme();
              var subTheme = _this2._processTheme.call(_this2, [ globalTheme, value ]);
              if (subTheme.font && subTheme.font.length) {
                  yield _this2._loadFonts(subTheme.font);
              }
              _this2._setCache("subTheme".concat(subThemeName), {
                  original: value,
                  result: subTheme
              });
              if (triggerUpdate) _this2._emit("themeUpdate".concat(subThemeName));
              return subTheme;
          }))();
      }
      _refreshSubThemes() {
          [ ...this._cache.keys() ].forEach((key => {
              if ("string" === typeof key && isSubTheme(key)) {
                  var _cache = this._cache.get(key);
                  if (_cache.original) this.updateSubTheme(key.replace(/^subTheme/, ""), _cache.original);
              }
          }));
      }
      _loadFonts(fontArray) {
          return _asyncToGenerator((function*() {
              try {
                  yield fontLoader(fontArray);
              } catch (err) {
                  loggerInstance.error("Unable to load font: ".concat(err));
              }
          }))();
      }
      updateTheme(themeConfig) {
          var _this3 = this;
          return _asyncToGenerator((function*() {
              var value;
              if (Array.isArray(themeConfig)) {
                  value = merge.all(themeConfig);
              } else {
                  value = themeConfig;
              }
              var currentTheme = {};
              if (_this3._cache.has("theme")) {
                  currentTheme = _this3._cache.get("theme");
              }
              _this3._clearCache();
              var theme = _this3._processTheme.call(_this3, [ currentTheme, value ], value.extensions || currentTheme.extensions);
              _this3._setCache("theme", theme);
              if (theme.font && theme.font.length) {
                  yield _this3._loadFonts(theme.font);
              }
              _this3._refreshSubThemes();
              if (value.extensions) _this3._emit("themeExtensionsUpdate");
              _this3._emit("themeUpdate");
              return theme;
          }))();
      }
      _clearCache() {
          base64Cache.filter((image => {
              if (window.URL && typeof window.URL.revokeObjectURL === "function") URL.revokeObjectURL(image);
              return false;
          }));
          this._cache.forEach(((value, key) => {
              if ("string" !== typeof key || !isSubTheme(key)) {
                  this._deleteCache(key);
              }
          }));
          this._cache.forEach(((value, key) => {
              if ("string" === typeof key && isSubTheme(key)) {
                  this.setSubTheme(key.replace("subTheme", ""), value.original, false);
              }
          }));
      }
      updateSubTheme(subThemeName, value) {
          var _arguments2 = arguments, _this4 = this;
          return _asyncToGenerator((function*() {
              var triggerUpdate = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : true;
              if (!subThemeName) {
                  loggerInstance.warn("Sub theme name not specified");
                  return;
              }
              if ("object" !== typeof value || !Object.keys(value).length) {
                  loggerInstance.warn("Could not update subTheme ".concat(subThemeName, " due to invalid value"));
                  return;
              }
              var globalTheme = _this4.getTheme();
              var currentTheme = {};
              if (_this4._cache.has("subTheme".concat(subThemeName))) {
                  currentTheme = _this4._cache.get("subTheme".concat(subThemeName)).original;
              }
              var subTheme = _this4._processTheme.call(_this4, [ globalTheme, currentTheme, value ]);
              if (subTheme.font && subTheme.font.length) {
                  yield _this4._loadFonts(subTheme.font);
              }
              _this4._setCache("subTheme".concat(subThemeName), {
                  original: clone(currentTheme, value),
                  result: subTheme
              });
              if (triggerUpdate) _this4._emit("themeUpdate".concat(subThemeName));
              return subTheme;
          }))();
      }
      removeSubTheme(subThemeName) {
          if (this._cache.has("subTheme".concat(subThemeName))) {
              this._deleteCache("subTheme".concat(subThemeName));
          }
          this._emit("themeUpdate".concat(subThemeName));
      }
      _getComponentUUID(id) {
          return "componentStyle".concat(id);
      }
      _processTheme() {
          var themeArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var extensions = arguments.length > 1 ? arguments[1] : undefined;
          if (!Array.isArray(themeArray)) {
              throw new Error("context processTheme expected an array. Received ".concat(typeof themeArray));
          }
          var theme = merge.all([ baseTheme, ...themeArray ]);
          var themeFunctions = {};
          var themeString = JSON.stringify(theme, ((key, originalValue) => {
              var value = originalValue;
              if (value && typeof value === "object") {
                  var replacement = originalValue;
                  for (var k in value) {
                      if (Object.hasOwnProperty.call(value, k) && THEME_KEY_REPLACER[k]) {
                          replacement[k && THEME_KEY_REPLACER[k]] = value[k];
                          delete replacement[k];
                      }
                  }
                  value = replacement;
              }
              var {isImage: isImage, mimeType: mimeType} = checkBase64EncodedImage(value);
              if (window.URL && typeof window.URL.createObjectURL === "function" && isImage) {
                  try {
                      var blobURL = base64ToBlobURL(value, mimeType);
                      base64Cache.push(blobURL);
                      return blobURL;
                  } catch (error) {
                      return value;
                  }
              }
              if (Array.isArray(value) && 2 === value.length && !value[0].targetComponent && value[0].length && typeof value[0] === "string" && value[0].substr(0, 1) === "#" && typeof value[1] === "number") {
                  return getHexColor(value[0], value[1]);
              } else if ("extensions" === key || "function" === typeof value || "object" === typeof value && value !== null && "Object" !== value.constructor.name && !Array.isArray(value)) {
                  themeFunctions[key] = value;
                  return;
              } else if ("string" === typeof value && value.includes("theme.")) {
                  var themeValue = getValFromObjPath({
                      theme: theme
                  }, value);
                  if (themeValue) {
                      return themeValue;
                  } else {
                      return value;
                  }
              } else {
                  var validColor = getValidColor(value);
                  if (validColor) {
                      return validColor;
                  }
                  return value;
              }
          }));
          return _objectSpread(_objectSpread(_objectSpread({}, JSON.parse(themeString)), themeFunctions), {}, {
              extensions: extensions
          });
      }
  }

  var themeManagerInstance = new ThemeManager;

  class Context {
      get theme() {
          return themeManagerInstance.getTheme();
      }
      set theme(value) {
          loggerInstance.warn("Context.theme must be set using context.setTheme or context.updateTheme");
      }
      get keyMetricsCallback() {
          return metricsInstance.keyMetricsCallback;
      }
      set keyMetricsCallback(value) {
          loggerInstance.warn("Context.keyMetricsCallback must be set using context.setKeyMetricsCallback");
      }
      get debug() {
          return loggerInstance.debug;
      }
      set debug(value) {
          loggerInstance.debug = value;
      }
      on() {
          return events.on(...arguments);
      }
      off() {
          return events.off(...arguments);
      }
      emit() {
          return events.emit(...arguments);
      }
      log() {
          loggerInstance.log(...arguments);
      }
      info() {
          loggerInstance.info(...arguments);
      }
      warn() {
          loggerInstance.warn(...arguments);
      }
      error() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
          }
          loggerInstance.error(args);
      }
      setTheme(value) {
          return themeManagerInstance.setTheme(value);
      }
      updateTheme(value) {
          return themeManagerInstance.updateTheme(value);
      }
      getSubTheme(subThemeName) {
          return themeManagerInstance.getSubTheme(subThemeName);
      }
      setSubThemes(subThemesObj) {
          if ("object" !== typeof subThemesObj) {
              loggerInstance.warn("subThemes must be an object");
              return;
          }
          for (var subTheme in subThemesObj) {
              themeManagerInstance.setSubTheme(subTheme, subThemesObj[subTheme]);
          }
      }
      setSubTheme(subThemeName, value) {
          return themeManagerInstance.setSubTheme(subThemeName, value);
      }
      updateSubTheme(subThemeName, value) {
          return themeManagerInstance.updateSubTheme(subThemeName, value);
      }
      removeSubTheme(subThemeName) {
          themeManagerInstance.removeSubTheme(subThemeName);
      }
      setLogCallback(value) {
          loggerInstance.logCallback = value;
      }
      setKeyMetricsCallback(value) {
          metricsInstance.keyMetricsCallback = value;
      }
      config() {
          var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var configKeys = Object.keys(config);
          for (var i = 0; i < configKeys.length; i++) {
              var setMethod = this["set" + capitalizeFirstLetter(configKeys[i])];
              if (setMethod) {
                  setMethod(config[configKeys[i]]);
              }
          }
          return this;
      }
  }

  var contextInstance = new Context;

  class GlobalUpdateManager {
      constructor() {
          this._updateThemeSet = new Set;
          this._requestUpdateSet = new Set;
          this._timeout = null;
          this._runUpdatesTimeoutHandler = this._runUpdatesTimeoutHandler.bind(this);
      }
      _runUpdatesTimeoutHandler() {
          this._timeout = null;
          this._updateThemeSet.forEach((component => {
              try {
                  component._updateThemeComponent();
              } catch (e) {
                  contextInstance.error("Error updating component themes", e);
              }
          }));
          this._updateThemeSet.clear();
          this._requestUpdateSet.forEach((component => {
              try {
                  component.requestUpdate();
              } catch (e) {
                  contextInstance.error("Error updating component", e);
              }
          }));
          this._requestUpdateSet.clear();
      }
      flush() {
          if (!this._timeout) return;
          clearTimeout(this._timeout);
          this._runUpdatesTimeoutHandler();
      }
      addUpdateTheme(component) {
          this._updateThemeSet.add(component);
          if (!this._timeout) {
              this._timeout = setTimeout(this._runUpdatesTimeoutHandler, 0);
          }
      }
      deleteUpdateTheme(component) {
          this._updateThemeSet.delete(component);
      }
      addRequestUpdate(component) {
          this._requestUpdateSet.add(component);
          if (!this._timeout) {
              this._timeout = setTimeout(this._runUpdatesTimeoutHandler, 0);
          }
      }
      deleteRequestUpdate(component) {
          this._requestUpdateSet.delete(component);
      }
      hasQueuedRequestFor(component) {
          return this._requestUpdateSet.has(component);
      }
  }

  var updateManager = new GlobalUpdateManager;

  function capital(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function mergeProps(componentConfigProp, prop) {
      var _result;
      var result = prop;
      if (typeof componentConfigProp === "object" && Object.keys(componentConfigProp).length && typeof prop === "object") {
          result = clone(componentConfigProp, prop);
      }
      return (_result = result) !== null && _result !== void 0 ? _result : componentConfigProp;
  }

  function getPropertyDescriptor$1(name, key) {
      return {
          get() {
              var _this$__componentConf3;
              var customGetter = this["_get".concat(capital(name))];
              if (customGetter && typeof customGetter === "function") {
                  var _this$__componentConf, _this$__componentConf2;
                  var value = customGetter.call(this, this[key]);
                  this[key] = value || ((_this$__componentConf = this.__componentConfigProps) === null || _this$__componentConf === void 0 ? void 0 : _this$__componentConf[name]);
                  return mergeProps((_this$__componentConf2 = this.__componentConfigProps) === null || _this$__componentConf2 === void 0 ? void 0 : _this$__componentConf2[name], value);
              }
              return mergeProps((_this$__componentConf3 = this.__componentConfigProps) === null || _this$__componentConf3 === void 0 ? void 0 : _this$__componentConf3[name], this[key]);
          },
          set(value) {
              var oldValue = this[key];
              if (value !== oldValue) {
                  var changeHandler = this["_set".concat(capital(name))];
                  if (changeHandler && typeof changeHandler === "function") {
                      value = changeHandler.call(this, value);
                  }
                  var newValue = key === "style" ? clone(this[key], value) : value;
                  if (typeof this[key] === "object" && this[key] !== null && this[key].style) {
                      var style = clone(this[key].style, value.style || {});
                      newValue.style = style;
                  }
                  this[key] = newValue;
                  this.queueRequestUpdate();
              }
          },
          configurable: true,
          enumerable: true
      };
  }

  function getAliasPropertyDescriptor(prev, curr) {
      var deprecationWarning = 'The property "'.concat(prev, '" is deprecated and will be removed in a future release. Please use "').concat(curr, '" instead.');
      return {
          get() {
              console.warn(deprecationWarning);
              return this[curr];
          },
          set(value) {
              console.warn(deprecationWarning);
              this[curr] = value;
          }
      };
  }

  function withUpdates(Base) {
      return class extends Base {
          static get name() {
              return Base.name;
          }
          _construct() {
              var prototype = Object.getPrototypeOf(this);
              if (!prototype._withUpdatesInitialized) {
                  var props = this.constructor.properties || [];
                  props.forEach((name => {
                      var key = "_" + name;
                      var descriptor = getPropertyDescriptor$1(name, key);
                      if (descriptor !== undefined) {
                          Object.defineProperty(prototype, name, descriptor);
                      }
                  }));
                  var aliasProps = this.constructor.aliasProperties || [];
                  aliasProps.forEach((alias => {
                      if (alias && typeof alias.prev === "string" && typeof alias.curr === "string") {
                          var descriptor = getAliasPropertyDescriptor(alias.prev, alias.curr);
                          if (descriptor !== undefined) {
                              Object.defineProperty(prototype, alias.prev, descriptor);
                          }
                      }
                  }));
                  prototype._withUpdatesInitialized = true;
              }
              this._whenEnabled = new Promise((resolve => {
                  this._whenEnabledResolver = resolve;
              }));
              super._construct && super._construct();
          }
          queueRequestUpdate() {
              if (!this._isAttached()) return;
              updateManager.addRequestUpdate(this);
          }
          _firstEnable() {
              this._readyForUpdates = true;
              this._whenEnabledResolver();
              updateManager.deleteRequestUpdate(this);
              this.requestUpdate();
              super._firstEnable && super._firstEnable();
          }
          requestEarlyUpdate() {
              this._readyForUpdates = true;
              if (updateManager.hasQueuedRequestFor(this)) {
                  updateManager.deleteRequestUpdate(this);
                  this._readyForUpdates = true;
                  this.requestUpdate();
                  return true;
              }
              return false;
          }
          _detach() {
              super._detach();
              updateManager.deleteRequestUpdate(this);
          }
          requestUpdate() {
              var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              if (this._readyForUpdates || force) {
                  var result = this._update();
                  if (typeof result === "object" && result !== null && result.catch) {
                      result.catch((e => {
                          contextInstance.error("asyncronous _update() error in '".concat(this.constructor.__componentName, "'"), this, e);
                      }));
                  }
              }
          }
          logPropTable() {
              console.table(this._propTable);
          }
          get _propTable() {
              return this.constructor.properties.reduce(((acc, prop) => {
                  acc[prop] = this[prop];
                  return acc;
              }), {});
          }
      };
  }

  function getPropertyDescriptor(path) {
      return {
          get() {
              return this.tag(path);
          },
          configurable: true,
          enumerable: true
      };
  }

  function withTags(Base) {
      return class extends Base {
          static get name() {
              return Base.name;
          }
          _construct() {
              var prototype = Object.getPrototypeOf(this);
              if (!prototype._withTagsInitialized) {
                  var tags = this.constructor.tags || [];
                  tags.forEach((tag => {
                      if (typeof tag === "object") {
                          var {name: name, path: path} = tag;
                      } else {
                          var name = tag;
                          var path = tag;
                      }
                      var key = "_" + name;
                      var descriptor = getPropertyDescriptor(path);
                      Object.defineProperty(prototype, key, descriptor);
                  }));
                  prototype._withTagsInitialized = true;
              }
              super._construct && super._construct();
          }
      };
  }

  function withHandleKey(Base) {
      return class extends Base {
          static get name() {
              return Base.name;
          }
          _handleKey(keyEvent) {
              return this._processEvent(keyEvent);
          }
          _handleKeyRelease(keyEvent) {
              return this._processEvent(keyEvent, "Release");
          }
          _processEvent(keyEvent) {
              var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
              var keyMap = this.stage.application.__keymap || {};
              var key = keyMap[keyEvent.keyCode];
              if (!key) {
                  key = keyEvent.key;
              }
              if (key && typeof this["on".concat(key).concat(suffix)] === "function") {
                  this._invokeKeyPayloadCallback(key + suffix);
                  return this["on".concat(key).concat(suffix)].call(this, this, keyEvent);
              }
              return false;
          }
          _invokeKeyPayloadCallback(key) {
              if (this.metricsPayload && typeof contextInstance.keyMetricsCallback === "function") {
                  contextInstance.keyMetricsCallback(key, this.metricsPayload);
              }
          }
      };
  }

  function withLayout(Base) {
      return class extends Base {
          _construct() {
              super._construct && super._construct();
              this._previousDimensionData = null;
          }
          get itemLayout() {
              return this._itemLayout;
          }
          set itemLayout(v) {
              var componentName = this.constructor._componentName || this.constructor.name;
              var itemLayout;
              if (v) {
                  itemLayout = JSON.parse(JSON.stringify(v, ((k, v) => {
                      if (k !== "circle" && v < 0) {
                          contextInstance.error("itemLayout for ".concat(componentName, " received an invalid value of ").concat(v, " for ").concat(k));
                          return;
                      } else if (k === "circle") {
                          return Boolean(v);
                      }
                      return v;
                  })));
              }
              if (!stringifyCompare(this._itemLayout, itemLayout)) {
                  if (itemLayout && !itemLayout.upCount) {
                      this._originalW = this.w;
                      this._originalH = this.h;
                      this._itemLayout = _objectSpread({
                          w: this._originalW,
                          h: this._originalH
                      }, itemLayout);
                  } else {
                      this._itemLayout = itemLayout;
                  }
                  this._updateItemLayout();
              }
          }
          _allowUpdate() {
              var {w: w = "", h: h = "", circle: circle = "", ratioX: ratioX = "", ratioY: ratioY = "", upCount: upCount = ""} = this._itemLayout || {};
              var layoutString = Object.values(contextInstance.theme.layout).join("") + "".concat(w).concat(h).concat(circle ? 1 : 0).concat(ratioX).concat(ratioY).concat(upCount);
              if (layoutString !== this._previousDimensionData) {
                  this._previousDimensionData = layoutString;
                  return true;
              }
              return false;
          }
          _updateItemLayout() {
              if (!this._allowUpdate()) return;
              var {w: w, h: h} = getDimensions(this.theme, this._itemLayout);
              if (h || w) {
                  var width = contextInstance.theme.layout.screenW;
                  var height = contextInstance.theme.layout.screenH;
                  var calculatedWidth = w || h * (width / height);
                  var calculatedHeight = h || w * (height / width);
                  this.w = this._itemLayout && this._itemLayout.circle ? calculatedHeight : calculatedWidth;
                  this.h = calculatedHeight;
                  if (this._itemLayout && this._itemLayout.circle && this.style.radius) {
                      this._circleSet = true;
                      this._originalRadius = this.style.radius;
                      this.style = _objectSpread(_objectSpread({}, this.style), {}, {
                          radius: calculatedHeight / 2
                      });
                  } else if (this._circleSet) {
                      this.style = _objectSpread(_objectSpread({}, this.style), {}, {
                          radius: this._originalRadius
                      });
                      this._originalRadius = undefined;
                      this._circleSet = false;
                  }
                  this.queueRequestUpdate && this.queueRequestUpdate();
                  this.fireAncestors("$itemChanged");
              }
          }
      };
  }

  var getCharacterValue = (char, index) => char.charCodeAt(0) * (index + 1);

  var sortObject = obj => {
      var sortedObj = {};
      Object.keys(obj).sort().forEach((key => {
          if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
              sortedObj[key] = sortObject(obj[key]);
          } else {
              sortedObj[key] = obj[key];
          }
      }));
      return sortedObj;
  };

  var getCharacterSum = obj => {
      var sortedObj = sortObject(obj);
      var str = JSON.stringify(sortedObj).replace(/[{}:",\s]/g, "");
      var sum = 0;
      for (var i = 0; i < str.length; i++) {
          sum += getCharacterValue(str[i], i);
      }
      return sum;
  };

  var getHash = obj => {
      var str = JSON.stringify(obj);
      return str.length + "-" + getCharacterSum(obj);
  };

  function executeWithContextRecursive(objOrFunction, theme) {
      if (typeof objOrFunction === "function") {
          var result = objOrFunction(theme);
          return executeWithContextRecursive(result, theme);
      } else if (Array.isArray(objOrFunction)) {
          return objOrFunction.map((item => executeWithContextRecursive(item, theme)));
      } else if (typeof objOrFunction === "object" && objOrFunction !== null) {
          var _result2 = {};
          for (var key in objOrFunction) {
              if (objOrFunction.hasOwnProperty(key)) {
                  _result2[key] = executeWithContextRecursive(objOrFunction[key], theme);
              }
          }
          return _result2;
      } else {
          return objOrFunction;
      }
  }

  function isPlainObject(value) {
      return typeof value === "object" && value !== null && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && !(value instanceof Function) && !(value instanceof Error);
  }

  var getSubTheme = obj => {
      while (obj && (!obj.subTheme || typeof obj.subTheme !== "string")) {
          obj = obj.p;
      }
      return obj ? obj.subTheme : undefined;
  };

  var getComponentConfig = obj => {
      var _obj$theme;
      if (!isPlainObject(obj)) return {};
      return (obj === null || obj === void 0 || (_obj$theme = obj.theme) === null || _obj$theme === void 0 || (_obj$theme = _obj$theme.componentConfig) === null || _obj$theme === void 0 ? void 0 : _obj$theme[obj.constructor.__componentName]) || {};
  };

  function removeEmptyObjects(obj) {
      for (var key in obj) {
          if (obj.hasOwnProperty(key) && isPlainObject(obj[key])) {
              removeEmptyObjects(obj[key]);
              if (Object.keys(obj[key]).length === 0) {
                  delete obj[key];
              }
          }
      }
      return obj;
  }

  function createSharedReferences() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var seenObjects = new Map;
      function hash(object) {
          return JSON.stringify(object, Object.keys(object).sort());
      }
      function process(currentObj) {
          for (var key in currentObj) {
              if (currentObj.hasOwnProperty(key)) {
                  var value = currentObj[key];
                  if (typeof value === "object" && value !== null) {
                      var valueHash = hash(value);
                      if (seenObjects.has(valueHash)) {
                          currentObj[key] = seenObjects.get(valueHash);
                      } else {
                          seenObjects.set(valueHash, value);
                          process(value);
                      }
                  }
              }
          }
      }
      process(obj);
      return obj;
  }

  function getUniqueProperties() {
      var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (!Array.isArray(defaultProps)) {
          throw new TypeError("Expected defaultProps to be an array of strings.");
      }
      return [ ...new Set(defaultProps) ];
  }

  function generatePayload(base, defaultStyle, toneItem, modeItem, tone, mode) {
      var _tone$toneItem, _mode$modeItem;
      var payload = clone(defaultStyle, base);
      payload = clone(payload, tone === null || tone === void 0 ? void 0 : tone[toneItem]);
      payload = clone(payload, mode === null || mode === void 0 ? void 0 : mode[modeItem]);
      payload = clone(payload, (tone === null || tone === void 0 || (_tone$toneItem = tone[toneItem]) === null || _tone$toneItem === void 0 || (_tone$toneItem = _tone$toneItem.mode) === null || _tone$toneItem === void 0 ? void 0 : _tone$toneItem[modeItem]) || {});
      payload = clone(payload, (mode === null || mode === void 0 || (_mode$modeItem = mode[modeItem]) === null || _mode$modeItem === void 0 || (_mode$modeItem = _mode$modeItem.tone) === null || _mode$modeItem === void 0 ? void 0 : _mode$modeItem[toneItem]) || {});
      return payload;
  }

  function findNestedKeys(obj, keyToFind) {
      var nestedKeys = [];
      function searchNestedKeys(obj) {
          if (typeof obj === "object" && obj !== null) {
              for (var key in obj) {
                  if (obj.hasOwnProperty(key)) {
                      nestedKeys.push(key);
                  }
              }
          }
      }
      function searchForKey(obj) {
          if (typeof obj === "object" && obj !== null) {
              for (var key in obj) {
                  if (obj.hasOwnProperty(key)) {
                      if (key === keyToFind) {
                          searchNestedKeys(obj[key]);
                          break;
                      }
                      searchForKey(obj[key]);
                  }
              }
          }
      }
      searchForKey(obj);
      return nestedKeys;
  }

  var generateSolution = function generateSolution(_ref7) {
      var {base: base = {}, tone: tone = {}, mode: mode = {}, defaultStyle: defaultStyle = {}} = _ref7;
      var modeKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var toneKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var solution = {};
      var uniqueModes = getUniqueProperties([ "focused", "disabled", ...modeKeys, "unfocused" ]);
      var uniqueTones = getUniqueProperties([ "neutral", "inverse", "brand", ...toneKeys ]);
      for (var modeItem of uniqueModes) {
          for (var toneItem of uniqueTones) {
              var payload = generatePayload(base, defaultStyle, toneItem, modeItem, tone, mode);
              solution["".concat(modeItem, "_").concat(toneItem)] = payload;
          }
      }
      return solution;
  };

  var DEFAULT_KEYS = [ "unfocused_neutral", "unfocused_inverse", "unfocused_brand", "focused_neutral", "focused_inverse", "focused_brand", "disabled_neutral", "disabled_inverse", "disabled_brand" ];

  function enforceContract(inputObj) {
      var result = {};
      for (var key of [ ...DEFAULT_KEYS, ...Object.keys(inputObj) ]) {
          if (!inputObj.hasOwnProperty(key)) {
              var fallbackKey = DEFAULT_KEYS.find((fallback => inputObj.hasOwnProperty(fallback)));
              if (fallbackKey) {
                  var fallback = inputObj[fallbackKey];
                  result[key] = typeof fallback !== "object" ? {} : fallback;
              } else {
                  result[key] = {};
              }
          } else {
              if (typeof inputObj[key] !== "object") {
                  result[key] = {};
              } else {
                  result[key] = inputObj[key];
              }
          }
      }
      return result;
  }

  var generateComponentStyleSource = function generateComponentStyleSource() {
      var {theme: theme = {}, styleChain: styleChain = [], inlineStyle: inlineStyle = {}, alias: alias = []} = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (typeof theme !== "object") {
          throw new Error("Expected theme to be an object");
      }
      if (!Array.isArray(styleChain)) {
          throw new Error("Expected styleChain to be an array");
      }
      if (typeof inlineStyle !== "object") {
          throw new Error("Expected inlineStyle to be an object");
      }
      if (!Array.isArray(alias)) {
          throw new Error("Expected alias to be an array");
      }
      var componentDefault = styleChain.map((_ref8 => {
          var {style: style} = _ref8;
          if (typeof style === "object" && !style.base && !style.mode && !style.tone && !style.default) {
              return {
                  base: style
              };
          } else {
              var {base: _base = {}, mode: _mode = {}, tone: _tone = {}} = style;
              var componentConfigDefaultStyle;
              if (style) {
                  var defaultStyle = JSON.parse(JSON.stringify(style));
                  delete defaultStyle.base;
                  delete defaultStyle.tone;
                  delete defaultStyle.mode;
                  componentConfigDefaultStyle = defaultStyle;
              }
              return {
                  defaultStyle: componentConfigDefaultStyle || {},
                  base: _base,
                  mode: _mode,
                  tone: _tone
              };
          }
      }));
      var localDefaultStyle;
      if (inlineStyle) {
          var defaultStyle = JSON.parse(JSON.stringify(inlineStyle));
          delete defaultStyle.base;
          delete defaultStyle.tone;
          delete defaultStyle.mode;
          localDefaultStyle = defaultStyle;
      }
      var local = {
          defaultStyle: localDefaultStyle || {},
          base: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.base) || {},
          mode: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.mode) || {},
          tone: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.tone) || {}
      };
      var merged = [ ...componentDefault, local ];
      var parsedStyles = merged.map((style => executeWithContextRecursive(style, theme)));
      var modeKeys = findNestedKeys(parsedStyles, "mode");
      var toneKeys = findNestedKeys(parsedStyles, "tone");
      var solution = parsedStyles.reduce(((acc, style) => clone(acc, generateSolution(style, modeKeys, toneKeys))), {});
      var final = formatStyleObj(removeEmptyObjects(colorParser({
          theme: theme
      }, solution)) || {}, alias);
      var cleanObj = createSharedReferences(final);
      return enforceContract(cleanObj);
  };

  var colorParser = (targetObject, styleObj) => {
      if (typeof targetObject !== "object" || targetObject === null) {
          throw new TypeError("targetObject must be an object.");
      }
      if (typeof styleObj !== "object" || styleObj === null) {
          throw new TypeError("styleObj must be an object.");
      }
      var processedStyle = JSON.stringify(styleObj, ((_, value) => {
          if (-1 < [ "tone", "mode" ].indexOf(_)) return value;
          if (typeof value === "string" && value.startsWith("theme.")) {
              return getValFromObjPath(targetObject, value);
          }
          function isValidColor(num) {
              return num >= 0 && num <= 4294967295;
          }
          if (Array.isArray(value) && value.length === 2 && (typeof value[0] === "string" && value[0].startsWith("#") || typeof value[0] === "number" && isValidColor(value[0])) && typeof value[1] === "number") {
              return getHexColor(value[0], value[1]) || value;
          }
          return value;
      }));
      return JSON.parse(processedStyle || {});
  };

  var generateStyle = function generateStyle(component) {
      var componentStyleSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!isPlainObject(component)) return {};
      var {mode: mode = "unfocused", tone: tone = "neutral"} = component;
      return componentStyleSource["".concat(mode, "_").concat(tone)] || componentStyleSource["unfocused_neutral"] || {};
  };

  function generateNameFromPrototypeChain(obj) {
      var _proto$constructor;
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      if (!obj) return name;
      var proto = Object.getPrototypeOf(obj);
      if (!proto || !proto.constructor) return name;
      var componentName = "".concat(name ? name + "." : "").concat((proto === null || proto === void 0 || (_proto$constructor = proto.constructor) === null || _proto$constructor === void 0 ? void 0 : _proto$constructor.__componentName) || "").replace(/\.*$/, "").trim();
      var result = generateNameFromPrototypeChain(proto, componentName);
      return result;
  }

  var styleChainCache = {};

  var clearStyleChainCache = () => {
      for (var key in styleChainCache) {
          if (styleChainCache.hasOwnProperty(key)) {
              delete styleChainCache[key];
          }
      }
  };

  var getStyleChainMemoized = componentObj => {
      var cacheKey = generateNameFromPrototypeChain(componentObj);
      if (styleChainCache[cacheKey]) {
          return styleChainCache[cacheKey];
      }
      var styleChain = getStyleChain(componentObj);
      styleChainCache[cacheKey] = styleChain;
      return styleChain;
  };

  var getStyleChain = componentObj => {
      var styleMap = new Map;
      var proto;
      do {
          var _proto;
          proto = !proto ? componentObj : Object.getPrototypeOf(proto);
          if (((_proto = proto) === null || _proto === void 0 ? void 0 : _proto.constructor) === Object) break;
          if (proto && typeof proto === "object" && proto.hasOwnProperty("constructor")) {
              var {style: componentConfigStyle} = getComponentConfig(proto);
              if (Object.keys(componentConfigStyle || {}).length) {
                  if (!styleMap.has(componentConfigStyle)) {
                      styleMap.set(componentConfigStyle, {
                          style: componentConfigStyle
                      });
                  }
              }
              var themeStyle = proto.constructor.hasOwnProperty("__themeStyle") && proto.constructor.__themeStyle;
              if (Object.keys(themeStyle || {}).length) {
                  if (!styleMap.has(themeStyle)) {
                      styleMap.set(themeStyle, {
                          style: _objectSpread({}, themeStyle)
                      });
                  }
              } else if (typeof themeStyle === "function") {
                  if (!styleMap.has(themeStyle)) {
                      styleMap.set(themeStyle, {
                          style: themeStyle
                      });
                  }
              }
              var mixinStyle = proto.constructor.hasOwnProperty("__mixinStyle") && proto.constructor.__mixinStyle;
              if (Object.keys(mixinStyle || {}).length) {
                  if (!styleMap.has(mixinStyle)) {
                      styleMap.set(mixinStyle, {
                          style: mixinStyle
                      });
                  }
              }
          }
      } while (proto);
      var uniqueStyles = Array.from(styleMap.values());
      return uniqueStyles.map((style => style)).reverse();
  };

  var formatStyleObj = function formatStyleObj(originalObj) {
      var aliasStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (typeof originalObj !== "object" || originalObj === null) {
          throw new Error("The originalObj parameter must be an object.");
      }
      var formatters = new Set;
      formatters.add([ replaceAliasValues, [ aliasStyles ] ]);
      var formattersArray = Array.from(formatters);
      return formattersArray.reduce(((obj, _ref9) => {
          var [func, args] = _ref9;
          return func(obj, ...args);
      }), originalObj);
  };

  var replaceAliasValues = function replaceAliasValues(value) {
      var aliasStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (typeof value !== "object" || value === null) {
          throw new Error("Value must be an object");
      }
      if (!Array.isArray(aliasStyles)) {
          throw new Error("Alias styles must be an array");
      }
      var str = JSON.stringify(value);
      var aliasProps = [ {
          prev: "height",
          curr: "h",
          skipWarn: true
      }, {
          prev: "width",
          curr: "w",
          skipWarn: true
      }, ...aliasStyles || [] ];
      aliasProps.forEach((alias => {
          if (alias && typeof alias.prev === "string" && typeof alias.curr === "string") {
              !alias.skipWarn && str.search('"'.concat(alias.prev, '":')) >= 0 && loggerInstance.warn('The style property "'.concat(alias.prev, '" is deprecated and will be removed in a future release. Please use "').concat(alias.curr, '" instead.'));
              str = str.replace(new RegExp('"'.concat(alias.prev, '":'), "gi"), '"'.concat(alias.curr, '":'));
          }
      }));
      return JSON.parse(str);
  };

  var themeStyleCache = new Map;

  contextInstance.on("themeUpdate", (() => {
      themeStyleCache.clear();
  }));

  var cache = themeStyleCache;

  class StyleManager extends lng$1.EventEmitter {
      constructor() {
          var {component: component = {}} = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          super(...arguments);
          this.init(component);
      }
      init(component) {
          this.isActive = true;
          this.component = component;
          this.setupListeners();
          this._style = {};
          this.update();
      }
      setupListeners() {
          this._boundThemeUpdate = this._onThemeUpdate.bind(this);
          this._hasSubTheme = Boolean(this.component._targetSubTheme);
          if (!this.component._targetSubTheme) {
              contextInstance.on("themeUpdate", this._boundThemeUpdate);
          } else {
              contextInstance.on("themeUpdate".concat(this.component._targetSubTheme), this._boundThemeUpdate);
          }
      }
      clearListeners() {
          if (!this._boundThemeUpdate) return;
          if (!this.component._targetSubTheme) {
              contextInstance.off("themeUpdate", this._boundThemeUpdate);
          } else {
              contextInstance.off("themeUpdate".concat(this.component._targetSubTheme), this._boundThemeUpdate);
          }
      }
      destroy() {
          this.isActive = false;
          this._cleanupCache();
          this.clearListeners();
          this._styleCache = null;
          this._boundThemeUpdate = null;
          this.component = null;
      }
      _onThemeUpdate() {
          clearStyleChainCache();
          this.clearSourceCache();
          this.clearStyleCache();
          this.update();
      }
      clearStyleChainCache() {
          clearStyleChainCache();
      }
      clearSourceCache() {
          if (!this.component) return;
          var sourceKey = this._generateCacheKey("styleSource");
          this._removeCache(sourceKey);
      }
      clearStyleCache() {
          if (!this.component) return;
          var {tone: tone, mode: mode} = this.component;
          var styleKey = this._generateCacheKey("style_".concat(mode, "_").concat(tone));
          cache.delete(styleKey);
      }
      _generateCacheKey(name) {
          var cacheKey = [ name, this.component._targetSubTheme, this.component.constructor.__componentName, this._customStyleHash ].filter(Boolean).join("_");
          return cacheKey;
      }
      _addCache(name, payload) {
          var key = this._generateCacheKey(name);
          var existing = cache.get(key);
          cache.set(key, {
              ids: [ ...new Set([ ...(existing === null || existing === void 0 ? void 0 : existing.ids) || [], this.component.__id ]) ],
              payload: payload
          });
      }
      _cleanupCache() {
          if (!this.component) return;
          cache.forEach(((_ref10, name) => {
              var {ids: ids, payload: payload} = _ref10;
              var removeIndex = ids && ids.length && ids.indexOf(this.component.__id);
              if (removeIndex > -1 && ids.length > 1) {
                  cache.set(name, {
                      ids: ids.slice(0, removeIndex).concat(ids.slice(removeIndex + 1)),
                      payload: payload
                  });
              } else if (removeIndex > -1) {
                  cache.delete(name);
              }
          }));
      }
      _removeCache(name) {
          cache.delete(name);
      }
      _getCache(name) {
          var key = this._generateCacheKey(name);
          return cache.get(key);
      }
      update() {
          if (!this.component) return;
          var {mode: mode, tone: tone} = this.component;
          try {
              var _this$_getCache, _this$_getCache2;
              var styleSource = (_this$_getCache = this._getCache("styleSource")) === null || _this$_getCache === void 0 ? void 0 : _this$_getCache.payload;
              if (!styleSource) {
                  styleSource = generateComponentStyleSource({
                      alias: this.component.constructor.aliasStyles,
                      inlineStyle: this.component._componentLevelStyle,
                      styleChain: getStyleChainMemoized(this.component),
                      theme: this.component.theme
                  });
                  this._addCache("styleSource", styleSource);
              }
              var style = (_this$_getCache2 = this._getCache("style_".concat(mode, "_").concat(tone))) === null || _this$_getCache2 === void 0 ? void 0 : _this$_getCache2.payload;
              if (!style) {
                  style = generateStyle(this.component, styleSource);
                  this._addCache("style_".concat(mode, "_").concat(tone), style);
              }
              this._style = style;
              this.emit("styleUpdate", this.style);
          } catch (error) {
              contextInstance.error("styleManager: ", error.message);
          }
      }
      set style(v) {
          contextInstance.warn("styleManager: Cannot mutate style directly");
      }
      get style() {
          return this._style;
      }
      set props(v) {
          contextInstance.warn("styleManager: Cannot mutate props directly");
      }
      get props() {
          return Object.keys(this.component._componentConfig).reduce(((acc, key) => {
              if (![ "base", "tone", "mode", "style", "styleConfig" ].includes(key)) {
                  acc[key] = this.component._componentConfig[key];
              }
              return acc;
          }), {});
      }
      get _customStyleHash() {
          var hasCustomStyle = Boolean(Object.keys(this.component.constructor.__mixinStyle || {}).length) || Boolean(Object.keys(this.component._componentLevelStyle || {}).length);
          if (hasCustomStyle) {
              return getHash(clone(this.component.constructor.__mixinStyle || {}, this.component._componentLevelStyle || {}));
          }
          return undefined;
      }
  }

  function mergeObjectsWithSecondDominant(firstObj, secondObj) {
      if (firstObj !== null && typeof firstObj === "object") {
          if (Array.isArray(firstObj)) {
              return firstObj.map(((item, index) => mergeObjectsWithSecondDominant(item, Array.isArray(secondObj) ? secondObj[index] : undefined)));
          } else {
              var result = {};
              var allKeys = new Set([ ...Object.keys(firstObj), ...Object.keys(secondObj) ]);
              allKeys.forEach((key => {
                  if (typeof firstObj[key] === "object" && firstObj[key] !== null) {
                      result[key] = mergeObjectsWithSecondDominant(firstObj[key], secondObj[key] || {});
                  } else if (typeof secondObj[key] === "object" && secondObj[key] !== null) {
                      result[key] = mergeObjectsWithSecondDominant(firstObj[key] || {}, secondObj[key]);
                  } else {
                      result[key] = secondObj.hasOwnProperty(key) ? secondObj[key] : undefined;
                  }
              }));
              return result;
          }
      } else {
          return firstObj;
      }
  }

  function withThemeStyles(Base) {
      var mixinStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return class extends Base {
          _construct() {
              if (this._withThemeStylesSetupComplete) {
                  super._construct();
                  return;
              }
              this._hSetByUser = false;
              this._wSetByUser = false;
              this._styleManager = new StyleManager({
                  component: this
              });
              this._style = this._styleManager.style;
              this._updatePropDefaults();
              this._styleManager.on("styleUpdate", (() => {
                  this._style = this._styleManager.style;
                  this._updatePropDefaults();
                  this.queueThemeUpdate();
              }));
              this._withThemeStylesSetupComplete = true;
              super._construct();
          }
          _setup() {
              super._setup && super._setup();
              this._targetSubTheme = getSubTheme(this);
              if (this._targetSubTheme) {
                  this._styleManager.clearListeners();
                  this._styleManager.setupListeners();
                  this._styleManager.clearStyleChainCache();
                  this._styleManager.clearStyleCache();
                  this._styleManager.clearSourceCache();
                  this._styleManager.update();
              }
          }
          _updatePropDefaults() {
              if (!Object.keys(this._styleManager.props).length || JSON.stringify(this._styleManager.props) === JSON.stringify(this._prevComponentConfigProps)) {
                  return;
              }
              var payload = this._prevComponentConfigProps ? mergeObjectsWithSecondDominant(this._prevComponentConfigProps || {}, this._styleManager.props || {}) : this._styleManager.props || {};
              this._prevComponentConfigProps = this._styleManager.props && JSON.parse(JSON.stringify(this._styleManager.props));
              this.__componentConfigProps = payload;
          }
          _attach() {
              super._attach();
              if (!this._styleManager.isActive) {
                  this._styleManager.init(this);
              }
          }
          _detach() {
              super._detach();
              this._styleManager.destroy();
          }
          _unfocus() {
              if (this._isFocusedMode) this.mode = "unfocused";
              super._unfocus();
          }
          _focus() {
              if (!this._isDisabledMode) this.mode = "focused";
              super._focus();
          }
          _checkDimensionUpdates() {
              var dimensionUpdateRequired = false;
              if (!this._wSetByUser && this.style.w && this._w !== this.style.w) {
                  this._w = this.style.w;
                  dimensionUpdateRequired = true;
              }
              if (!this._hSetByUser && this.style.h && this._h !== this.style.h) {
                  this._h = this.style.h;
                  dimensionUpdateRequired = true;
              }
              if (dimensionUpdateRequired) {
                  this._updateDimensions();
              }
          }
          _updateThemeComponent() {
              if (!this.style) return;
              if (!this._isAttached()) return;
              this._checkDimensionUpdates();
              this.queueRequestUpdate ? this.queueRequestUpdate() : this._update && this._update();
              this._updateItemLayout && this._updateItemLayout();
          }
          queueThemeUpdate() {
              updateManager.addUpdateTheme(this);
          }
          static get name() {
              return Base.name;
          }
          static get __componentName() {
              if (!super.__componentName) {
                  throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name, " class."));
              }
              return super.__componentName;
          }
          static get __mixinStyle() {
              return mixinStyle;
          }
          get theme() {
              var subTheme = this._targetSubTheme && contextInstance.getSubTheme(this._targetSubTheme);
              return subTheme || contextInstance.theme;
          }
          set style(v) {
              if (Object.prototype.toString.call(v) !== "[object Object]") {
                  contextInstance.error("style must be an object");
                  return;
              }
              this._componentLevelStyle = v;
              this._styleManager.clearStyleCache();
              this._styleManager.update();
          }
          get style() {
              return this._style;
          }
          get _componentStyle() {
              contextInstance.info("_componentStyle will soon be deprecated. Please use Component.style");
              return this._style;
          }
          set styleConfig(v) {
              contextInstance.info("style config is deprecated. Please use style = { base: {}, tone: {}, mode: {} }");
              this._styleConfig = v;
              this._styleManager.update();
          }
          get styleConfig() {
              return this._styleConfig;
          }
          get _componentConfig() {
              return getComponentConfig(this);
          }
          get mode() {
              var _this$_componentConfi;
              return this._mode || ((_this$_componentConfi = this._componentConfig) === null || _this$_componentConfi === void 0 ? void 0 : _this$_componentConfi.mode) || "unfocused";
          }
          set mode(v) {
              if (typeof v !== "string" || this._mode === v) return;
              this._mode = v;
              var event = this["on".concat(capitalizeFirstLetter(v))];
              if (event && typeof event === "function") event.call(this);
              this._styleManager.update();
          }
          get tone() {
              return this._tone || this._componentConfig.tone || "neutral";
          }
          set tone(v) {
              if (typeof v !== "string" || this._tone === v) return;
              this._tone = v;
              this._styleManager.update();
          }
          get w() {
              var _this$style;
              return this._wSetByUser && this._w || ((_this$style = this.style) === null || _this$style === void 0 ? void 0 : _this$style.w) || 0;
          }
          set w(v) {
              if (this._w === v) return;
              super.w = v;
              this._wSetByUser = true;
              this._updateThemeComponent();
          }
          get h() {
              var _this$style2;
              return this._hSetByUser && this._h || ((_this$style2 = this.style) === null || _this$style2 === void 0 ? void 0 : _this$style2.h) || this._h || 0;
          }
          set h(v) {
              if (this._h === v) return;
              super.h = v;
              this._hSetByUser = true;
              this._updateThemeComponent();
          }
      };
  }

  var SUFFIX = "__original";

  function withExtensions(Base) {
      if (Base.prototype.constructor._withExtensionsApplied) {
          return Base;
      }
      return class extends Base {
          static get name() {
              return Base.name;
          }
          static get __componentName() {
              if (!super.__componentName) {
                  throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name, " class."));
              }
              return super.__componentName;
          }
          static get _withExtensionsApplied() {
              return true;
          }
          get _prototypeChain() {
              if (this.__prototypeChain) return this.__prototypeChain;
              var prototypeChain = new Set;
              var proto = this;
              do {
                  proto = Object.getPrototypeOf(proto);
                  if (null !== proto && typeof proto === "object") {
                      try {
                          if (proto.constructor.__componentName) prototypeChain.add(proto.constructor.__componentName);
                      } catch (error) {}
                  }
              } while (proto);
              this.__prototypeChain = prototypeChain;
              return prototypeChain;
          }
          get _extensions() {
              var extensions = contextInstance && contextInstance.theme && contextInstance.theme.extensions;
              if (!extensions || !Array.isArray(extensions) || Array.isArray(extensions) && !extensions.length) return [];
              return extensions.filter((_ref11 => {
                  var {targetComponent: targetComponent, extension: extension} = _ref11;
                  return (typeof targetComponent === "string" || Array.isArray(targetComponent)) && typeof extension === "function";
              })).slice().reverse() || [];
          }
          get _componentExtensions() {
              return this._extensions.filter((_ref12 => {
                  var {targetComponent: targetComponent} = _ref12;
                  if (typeof targetComponent === "string") {
                      return targetComponent === this.constructor.__componentName || this._prototypeChain.has(targetComponent);
                  } else if (Array.isArray(targetComponent)) {
                      return targetComponent.find((pattern => {
                          if (pattern.startsWith("/") && pattern.endsWith("/")) {
                              var ComponentRegExp = new RegExp(pattern.slice(1, -1));
                              return Array.from(this._prototypeChain).some((name => ComponentRegExp.test(name)));
                          } else {
                              return this._prototypeChain.has(pattern);
                          }
                      }));
                  }
                  return false;
              })).reduce(((acc, _ref13) => {
                  var {extension: extension} = _ref13;
                  acc.push(extension);
                  return acc;
              }), []);
          }
          get _extensionApplied() {
              return this._currentComponentExtensionLength === this._appliedExtensionLength;
          }
          _construct() {
              this._appliedExtensionLength = 0;
              this._extendedList = {};
              this._extensionInstance = {};
              this._setupExtensionBound = this._setupExtension.bind(this);
              contextInstance.on("themeUpdate", this._setupExtensionBound);
              this._currentComponentExtensionLength = this._calculateComponentExtensionLength();
              this._createExtension();
              super._construct();
          }
          _detach() {
              super._detach();
              contextInstance.off("themeUpdate", this._setupExtensionBound);
          }
          _setupExtension() {
              this._currentComponentExtensionLength = this._calculateComponentExtensionLength();
              this._createExtension.call(this);
          }
          _resetComponent() {
              this._extensionInstance._extensionCleanup && this._extensionInstance._extensionCleanup.call(this);
              (Object.keys(this._extendedList) || []).forEach((prop => {
                  delete this[prop];
                  delete this[prop + SUFFIX];
              }));
              this._extensionInstance = {};
              this._extendedList = {};
          }
          _calculateComponentExtensionLength() {
              var extensionLength = this._componentExtensions.reduce(((acc, extensionMixin) => {
                  acc += extensionMixin.toString().length;
                  return acc;
              }), 0);
              return extensionLength;
          }
          _createExtension() {
              if (this._extensionApplied) return;
              this._resetComponent();
              var ExtendedClass = this._createExtensionClass();
              var instance = new ExtendedClass;
              this._extendedList = this._createExtensionAliases(instance);
              this._extensionInstance = instance;
              this._setComponentAliases(this._extendedList);
          }
          _createExtensionClass() {
              function ExtensionBase() {}
              var ExtendedClass = this._componentExtensions.reduce(((acc, extension) => extension(acc)), ExtensionBase);
              this._appliedExtensionLength = this._calculateComponentExtensionLength();
              return ExtendedClass;
          }
          _createExtensionAliases(obj) {
              var baseProto = obj;
              for (var i = 0; i < this._componentExtensions.length + 1; i++) {
                  baseProto = Object.getPrototypeOf(baseProto);
              }
              var extended = {};
              var extensionOverrides = this._componentExtensions.reduce(((acc, extension) => {
                  var extensionClass = new extension(class FakeClass {});
                  var instance = new extensionClass;
                  var originalComponentDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(instance));
                  Object.keys(originalComponentDescriptors).forEach((prop => {
                      if ([ "constructor" ].includes(prop)) return;
                      if (originalComponentDescriptors[prop].get || originalComponentDescriptors[prop].set) {
                          extended[prop] = {
                              type: "accessor"
                          };
                          acc[prop] = {
                              get: function get() {
                                  return this[prop + SUFFIX];
                              },
                              set: function set(v) {
                                  this[prop + SUFFIX] = v;
                              }
                          };
                          return;
                      }
                      extended[prop] = {
                          type: "method"
                      };
                      acc[prop] = {
                          value: function value() {
                              this[prop + SUFFIX] && this[prop + SUFFIX]();
                          }
                      };
                  }));
                  return acc;
              }), {});
              Object.defineProperties(baseProto, extensionOverrides);
              Object.setPrototypeOf(baseProto, this);
              return extended;
          }
          _setComponentAliases(aliasObj) {
              Object.keys(aliasObj).forEach((prop => {
                  this[prop + SUFFIX] = this[prop];
                  if (aliasObj[prop].type === "method") {
                      this[prop] = this._extensionInstance[prop];
                  } else if (aliasObj[prop].type === "accessor") {
                      Object.defineProperty(this, prop, {
                          configurable: true,
                          get() {
                              return this._extensionInstance[prop];
                          },
                          set(v) {
                              this._extensionInstance[prop] = v;
                          }
                      });
                  }
              }));
          }
      };
  }

  class Base extends lng$1.Component {
      static get __componentName() {
          return "Base";
      }
      _construct() {
          this.constructor.__componentName;
          this.skipPlinko = false;
          this.centerInParent = false;
          if (!this.loaded) this.loaded = Promise.resolve();
      }
      _init() {
          this.queueRequestUpdate();
      }
      _resetLoadedPromise() {
          this.loaded = new Promise(((resolve, reject) => {
              this._resolveLoadedPromise = resolve;
              this._rejectLoadedPromise = reject;
          }));
      }
      _update() {}
      _focus() {
          this._updateShouldSmooth();
          this.queueRequestUpdate();
      }
      _unfocus() {
          this.queueRequestUpdate();
      }
      _updateShouldSmooth() {
          if (this.shouldSmooth === undefined) this.shouldSmooth = true;
      }
      applySmooth(ref, patch, smooth) {
          if (this.shouldSmooth) {
              ref.smooth = smooth || patch;
          } else {
              ref.patch(patch);
          }
      }
      get announce() {
          return this._announce;
      }
      set announce(announce) {
          this._announce = announce;
      }
      get announceContext() {
          return this._announceContext;
      }
      set announceContext(announce) {
          this._announceContext = announce;
      }
      get shouldSmooth() {
          return this._shouldSmooth;
      }
      set shouldSmooth(shouldSmooth) {
          this._shouldSmooth = shouldSmooth;
      }
      get _isDisabledMode() {
          return this.mode === "disabled";
      }
      get _isUnfocusedMode() {
          return this.mode === "unfocused";
      }
      get _isFocusedMode() {
          return this.mode === "focused";
      }
      isFullyOnScreen(offsets) {
          return isComponentOnScreen(this, offsets);
      }
      getFocusScale() {
          return contextInstance.theme.layout.focusScale;
      }
      getUnfocusScale() {
          return 1;
      }
  }

  function withMixins(baseComponent) {
      return withExtensions(withLayout(withThemeStyles(withUpdates(withTags(withHandleKey(baseComponent))))));
  }

  var Base$1 = withMixins(Base);

  var base$R = theme => ({
      gradientTop: theme.color.fillTransparent,
      radius: theme.radius.none
  });

  var tone$p = theme => ({
      neutral: {
          gradientColor: theme.color.material
      },
      inverse: {
          gradientColor: theme.color.fillNeutral
      },
      brand: {
          gradientColor: theme.color.fillBrand
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$R,
      tone: tone$p
  });

  var base$Q = theme => ({
      animationBlurEntrance: theme.animation.utilityEntrance,
      animationBlurExit: theme.animation.utilityExit,
      animationComponentEntrance: theme.animation.utilityEntrance,
      animationGradientEntrance: theme.animation.utilityEntrance,
      animationGradientExit: theme.animation.utilityExit,
      animationImageScaleEntrance: theme.animation.standardEntrance,
      animationImageScaleExit: theme.animation.standardEntrance,
      blur: 4,
      centerImageRadius: theme.radius.md,
      fallbackSrc: undefined,
      fillColor: theme.color.overlay,
      gradientColor: theme.color.material,
      imageScale: 1,
      imageScalePivotX: .5,
      imageScalePivotY: .5,
      padding: theme.spacer.md,
      radius: 0,
      zIndexSet: {
          image: 1,
          blur: 2,
          centerImage: 3,
          fill: 4,
          gradient: 5,
          foreground: 6
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$Q
  });

  function checkFileType(str) {
      if (str.startsWith("<svg")) {
          return "SVG";
      } else if (str.startsWith("blob:")) {
          return "Blob";
      } else if (/\.(jpeg|jpg|gif|png|svg)$/i.test(str)) {
          return "Image";
      } else {
          return "Unknown";
      }
  }

  function createSvg(cb, stage, url, w, h) {
      var canvas = stage.platform.getDrawingCanvas();
      var ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      var img = new Image;
      img.onload = () => {
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          cb(null, {
              source: canvas,
              w: w,
              h: h
          });
      };
      img.onerror = err => {
          cb(err);
      };
      if (!lng$1.Utils.isPS4) {
          img.crossOrigin = "Anonymous";
      }
      img.src = url;
  }

  function imageLoader(_ref14, cb) {
      var {src: src} = _ref14;
      var image = new Image;
      if (!(src.substr(0, 5) == "data:") && !lng$1.Utils.isPS4) {
          image.crossOrigin = "Anonymous";
      }
      image.onerror = function() {
          if (image.src) {
              return cb("Image load error");
          }
      };
      image.onload = function() {
          cb(null, {
              source: image,
              renderInfo: {
                  src: src,
                  compressed: false
              },
              hasAlpha: true
          });
      };
      image.src = src;
      return function() {
          image.onerror = null;
          image.onload = null;
          image.removeAttribute("src");
      };
  }

  class CustomImageTexture extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._src = undefined;
          this._hasAlpha = false;
      }
      get src() {
          return this._src;
      }
      set src(v) {
          if (this._src !== v) {
              this._src = v;
              this._changed();
          }
      }
      get hasAlpha() {
          return this._hasAlpha;
      }
      set hasAlpha(v) {
          if (this._hasAlpha !== v) {
              this._hasAlpha = v;
              this._changed();
          }
      }
      get w() {
          return this._w;
      }
      set w(l) {
          this._w = l;
          this._changed();
      }
      get h() {
          return this._h;
      }
      set h(l) {
          this._h = l;
          this._changed();
      }
      _getIsValid() {
          return !!this._src;
      }
      _getLookupId() {
          return this._src;
      }
      _getSourceLoader() {
          var w = this._w;
          var h = this._h;
          var src = this._src;
          var hasAlpha = this._hasAlpha;
          if (this.stage.getOption("srcBasePath")) {
              var fc = src.charCodeAt(0);
              if (src.indexOf("//") === -1 && (fc >= 65 && fc <= 90 || fc >= 97 && fc <= 122 || fc == 46)) {
                  src = this.stage.getOption("srcBasePath") + src;
              }
          }
          return cb => {
              var fileType = checkFileType(src);
              switch (fileType) {
                case "SVG":
                  return createSvg(cb, this.stage, "data:image/svg+xml,".concat(encodeURIComponent(src)), w, h);

                case "Blob":
                  return imageLoader({
                      src: src
                  }, cb);

                default:
                  return this.stage.platform.loadSrcTexture({
                      src: src,
                      hasAlpha: hasAlpha
                  }, cb);
              }
          };
      }
      getNonDefaults() {
          var obj = super.getNonDefaults();
          if (this._src) {
              obj.src = this._src;
          }
          return obj;
      }
  }

  var tone$o = theme => ({
      neutral: {
          color: theme.color.fillNeutral
      },
      inverse: {
          color: theme.color.fillInverse
      },
      brand: {
          color: theme.color.fillBrand
      }
  });

  Object.freeze({
      __proto__: null,
      tone: tone$o
  });

  var base$P = theme => ({
      contentSpacing: theme.spacer.xs,
      offsetY: 1,
      paddingX: theme.spacer.md,
      paddingY: theme.spacer.xs,
      radius: theme.radius.sm,
      strokeWidth: theme.stroke.sm,
      textStyle: _objectSpread(_objectSpread({}, theme.typography.tag1), {}, {
          textAlign: "center"
      })
  });

  var tone$n = theme => ({
      neutral: {
          backgroundColor: theme.color.fillInverseSecondary,
          iconColor: theme.color.textNeutral,
          textStyle: {
              textColor: theme.color.textNeutral
          },
          strokeColor: theme.color.strokeNeutralSecondary
      },
      inverse: {
          backgroundColor: theme.color.fillNeutralSecondary,
          iconColor: theme.color.textInverse,
          textStyle: {
              textColor: theme.color.textInverse
          },
          strokeColor: theme.color.strokeInverseSecondary
      },
      brand: {
          backgroundColor: theme.color.fillBrand,
          iconColor: theme.color.textNeutral,
          textStyle: {
              textColor: theme.color.textNeutral
          },
          strokeColor: theme.color.strokeInverseSecondary
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$P,
      tone: tone$n
  });

  var base$O = theme => ({
      width: 0,
      justify: "center",
      minWidth: getWidthByColumnSpan(theme, 3),
      paddingX: theme.spacer.xxxl,
      paddingXNoTitle: theme.spacer.xl,
      paddingY: theme.spacer.xl,
      radius: theme.radius.sm,
      contentSpacing: theme.spacer.md,
      itemSpacing: theme.spacer.md,
      textStyle: _objectSpread(_objectSpread({}, theme.typography.button1), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutral
      }),
      contentColor: theme.color.fillNeutral
  });

  var mode$g = theme => ({
      focused: {
          textStyle: {
              textColor: theme.color.textInverse
          },
          contentColor: theme.color.fillInverse,
          tone: {
              inverse: {
                  textStyle: {
                      textColor: theme.color.textNeutral
                  },
                  contentColor: theme.color.fillNeutral
              },
              brand: {
                  contentColor: theme.color.fillNeutral
              }
          }
      },
      disabled: {
          textStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          contentColor: theme.color.fillNeutralDisabled
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$O,
      mode: mode$g
  });

  var base$N = theme => ({
      alwaysScroll: false,
      itemSpacing: theme.layout.gutterX,
      itemTransition: theme.animation.utility,
      neverScroll: false,
      scrollIndex: 0
  });

  Object.freeze({
      __proto__: null,
      base: base$N
  });

  var base$M = theme => ({
      itemSpacing: theme.layout.gutterX,
      scrollIndex: 0,
      alwaysScroll: false,
      neverScroll: false,
      itemTransition: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
          duration: theme.animation.duration.fast
      })
  });

  Object.freeze({
      __proto__: null,
      base: base$M
  });

  var base$L = theme => ({
      backgroundColor: theme.color.interactiveNeutral,
      radius: theme.radius.md,
      animation: {}
  });

  var tone$m = theme => ({
      inverse: {
          backgroundColor: theme.color.interactiveInverse
      }
  });

  var mode$f = theme => ({
      focused: {
          backgroundColor: theme.color.interactiveNeutralFocus,
          tone: {
              inverse: {
                  backgroundColor: theme.color.interactiveInverseFocus
              }
          }
      },
      disabled: {
          backgroundColor: theme.color.fillNeutralDisabled
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$L,
      mode: mode$f,
      tone: tone$m
  });

  var base$K = theme => ({
      offsetY: theme.spacer.xxs,
      offsetX: 0,
      textStyle: theme.typography.body1
  });

  var tone$l = theme => ({
      neutral: {
          textStyle: {
              textColor: theme.color.fillNeutral
          }
      },
      inverse: {
          textStyle: {
              textColor: theme.color.fillInverse
          }
      },
      brand: {
          textStyle: {
              textColor: theme.color.fillBrand
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$K,
      tone: tone$l
  });

  var base$J = theme => ({
      textY: 0,
      iconWidth: theme.spacer.xxl + theme.spacer.xs,
      iconHeight: theme.spacer.xxl + theme.spacer.xs,
      contentSpacing: theme.spacer.md,
      marginBottom: 0,
      strikethroughRatio: .08,
      strikethroughColor: theme.color.textNeutral,
      textStyle: _objectSpread({}, theme.typography.body1),
      maxLines: 1,
      justify: "flex-start"
  });

  Object.freeze({
      __proto__: null,
      base: base$J
  });

  var base$I = theme => ({
      fadeWidth: 100,
      offset: theme.spacer.xxl,
      shouldSmooth: false,
      textStyle: theme.typography.body1
  });

  Object.freeze({
      __proto__: null,
      base: base$I
  });

  class FadeShader extends lng$1.shaders.WebGLDefaultShader {
      constructor(context) {
          super(context);
          this._margin = {
              left: 0,
              right: 0
          };
      }
      set positionLeft(v) {
          this._positionLeft = v;
      }
      set positionRight(v) {
          this._positionRight = v;
      }
      setupUniforms(operation) {
          super.setupUniforms(operation);
          var owner = operation.shaderOwner;
          if (this._positionLeft === 0) {
              this._positionLeft = .001;
          }
          if (this._positionRight === 0) {
              this._positionRight = .001;
          }
          var renderPrecision = this.ctx.stage.getRenderPrecision();
          this._setUniform("margin", [ this._positionLeft * renderPrecision, this._positionRight * renderPrecision ], this.gl.uniform1fv);
          this._setUniform("resolution", new Float32Array([ owner._w * renderPrecision, owner._h * renderPrecision ]), this.gl.uniform2fv);
      }
  }

  FadeShader.fragmentShaderSource = "\n  #ifdef GL_ES\n  # ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  # else\n  precision lowp float;\n  # endif\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";

  Object.entries(Object.getOwnPropertyDescriptors(lng$1.textures.TextTexture.prototype)).reduce(((acc, _ref18) => {
      var [prop] = _ref18;
      var value = lng$1.textures.TextTexture.prototype[prop];
      if (prop.startsWith("_") || [ "undefined", "function" ].includes(typeof value)) return acc;
      return _objectSpread({
          [prop]: value
      }, acc);
  }), {});

  var base$H = theme => ({
      minWidth: getWidthByColumnSpan(theme, 1),
      paddingX: theme.spacer.xxl,
      paddingXNoTitle: theme.spacer.lg,
      paddingY: theme.spacer.lg,
      textStyle: theme.typography.button2
  });

  Object.freeze({
      __proto__: null,
      base: base$H
  });

  var base$G = theme => ({
      height: theme.spacer.xxl * 12,
      paddingHorizontal: theme.spacer.xl,
      paddingVertical: theme.spacer.xl,
      radius: theme.radius.md,
      titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
          wordWrap: true,
          maxLines: 2,
          textColor: theme.color.textNeutral
      }),
      width: utils$1.getWidthByUpCount(theme, 6)
  });

  var mode$e = theme => ({
      focused: {
          tone: {
              neutral: {
                  backgroundColor: theme.color.interactiveNeutralFocusSoft
              },
              inverse: {
                  backgroundColor: theme.color.interactiveInverseFocusSoft
              },
              brand: {
                  backgroundColor: theme.color.interactiveBrandFocusSoft
              }
          }
      },
      disabled: {
          titleTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$G,
      mode: mode$e
  });

  var base$F = theme => ({
      titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
          wordWrap: true,
          maxLines: 2,
          textColor: theme.color.textNeutral
      }),
      descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          textColor: theme.color.textNeutral,
          wordWrap: true,
          maxLines: 3
      }),
      detailsTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
          textColor: theme.color.textNeutral,
          wordWrap: true,
          maxLines: 1
      })
  });

  var mode$d = theme => ({
      disabled: {
          descriptionTextStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          detailsTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$F,
      mode: mode$d
  });

  var base$E = theme => ({
      descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          textColor: theme.color.textNeutralSecondary,
          wordWrap: true,
          maxLines: 8
      }),
      height: theme.spacer.xxxl * 15,
      subtitleTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
          maxLines: 2,
          textColor: theme.color.textNeutral,
          wordWrap: true
      }),
      width: utils$1.getWidthByColumnSpan(theme, 4)
  });

  var mode$c = theme => ({
      disabled: {
          descriptionTextStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          subtitleTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$E,
      mode: mode$c
  });

  var base$D = theme => {
      var size = theme.spacer.xxl;
      return {
          alpha: theme.alpha.primary,
          width: size,
          height: size,
          knobHeight: size / 2,
          knobWidth: size / 2,
          radius: size / 2,
          strokeWidth: theme.stroke.sm
      };
  };

  var tone$k = theme => ({
      neutral: {
          backgroundColor: theme.color.fillInverseSecondary,
          backgroundColorChecked: theme.color.fillNeutral,
          knobColor: theme.color.fillInverse,
          strokeColor: theme.color.strokeNeutralSecondary
      },
      inverse: {
          backgroundColor: theme.color.fillNeutralSecondary,
          backgroundColorChecked: theme.color.fillInverse,
          knobColor: theme.color.fillNeutral,
          strokeColor: theme.color.strokeInverseSecondary
      },
      brand: {
          backgroundColor: theme.color.fillNeutralSecondary,
          backgroundColorChecked: theme.color.fillBrand,
          knobColor: theme.color.fillInverse,
          strokeColor: theme.color.strokeNeutralSecondary
      }
  });

  var mode$b = theme => ({
      disabled: {
          alpha: theme.alpha.inactive
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$D,
      mode: mode$b,
      tone: tone$k
  });

  var base$C = theme => {
      var size = theme.spacer.xl;
      return {
          width: size,
          height: size,
          knobHeight: size / 2,
          knobWidth: size / 2,
          radius: size / 2
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$C
  });

  var base$B = theme => ({
      height: theme.spacer.xxl * 5,
      iconWidth: theme.spacer.xxl,
      iconHeight: theme.spacer.xxl,
      width: utils$1.getWidthByColumnSpan(theme, 3)
  });

  Object.freeze({
      __proto__: null,
      base: base$B
  });

  var base$A = theme => {
      var strokeWidth = theme.stroke.sm;
      var size = theme.spacer.xxl;
      return {
          alpha: theme.alpha.primary,
          width: size,
          height: size,
          iconWidth: theme.spacer.lg,
          iconHeight: theme.spacer.lg,
          icon: theme.asset.check,
          radius: theme.radius.xs,
          strokeWidth: strokeWidth
      };
  };

  var tone$j = theme => ({
      neutral: {
          strokeColor: theme.color.strokeNeutralSecondary,
          checkColor: theme.color.fillInverse,
          backgroundColor: theme.color.fillInverseSecondary,
          backgroundColorChecked: theme.color.fillNeutral
      },
      inverse: {
          strokeColor: theme.color.strokeInverseSecondary,
          checkColor: theme.color.fillNeutral,
          backgroundColor: theme.color.fillNeutralSecondary,
          backgroundColorChecked: theme.color.fillInverse
      },
      brand: {
          strokeColor: theme.color.strokeNeutralSecondary,
          checkColor: theme.color.fillInverse,
          backgroundColor: theme.color.fillNeutralSecondary,
          backgroundColorChecked: theme.color.fillBrand
      }
  });

  var mode$a = theme => ({
      disabled: {
          alpha: theme.alpha.inactive
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$A,
      mode: mode$a,
      tone: tone$j
  });

  var base$z = theme => ({
      radius: [ theme.radius.md, theme.radius.md, theme.radius.md, theme.radius.none ],
      paddingX: theme.spacer.lg,
      paddingY: theme.spacer.md,
      offsetY: theme.spacer.xxs,
      textStyle: theme.typography.caption1
  });

  var tone$i = theme => ({
      neutral: {
          textStyle: {
              textColor: theme.color.textInverse
          },
          backgroundColor: theme.color.fillNeutral
      },
      inverse: {
          textStyle: {
              textColor: theme.color.textNeutral
          },
          backgroundColor: theme.color.fillInverse
      },
      brand: {
          textStyle: {
              textColor: theme.color.textNeutral
          },
          backgroundColor: theme.color.fillBrand
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$z,
      tone: tone$i
  });

  var base$y = theme => ({
      descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          maxLines: 1
      }),
      fadeWidth: 100,
      logoWidth: theme.typography.body3.lineHeight,
      logoHeight: theme.typography.body3.lineHeight,
      logoPadding: theme.spacer.lg,
      detailsTextStyle: theme.typography.body3,
      subtitleTextStyle: theme.typography.body3,
      titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
          maxLines: 1
      }),
      marqueeSync: true,
      alpha: theme.alpha.primary
  });

  var mode$9 = theme => ({
      disabled: {
          detailsTextStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          alpha: theme.alpha.inactive
      }
  });

  var tone$h = theme => ({
      neutral: {
          titleTextStyle: {
              textColor: theme.color.textNeutral
          },
          subtitleTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          detailsTextStyle: {
              textColor: theme.color.textNeutral
          },
          descriptionTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          mode: {
              disabled: {
                  titleTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      inverse: {
          titleTextStyle: {
              textColor: theme.color.textInverse
          },
          subtitleTextStyle: {
              textColor: theme.color.textInverseSecondary
          },
          detailsTextStyle: {
              textColor: theme.color.textInverse
          },
          descriptionTextStyle: {
              textColor: theme.color.textInverseSecondary
          },
          mode: {
              disabled: {
                  titleTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  subtitleTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      brand: {
          titleTextStyle: {
              textColor: theme.color.textNeutral
          },
          subtitleTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          detailsTextStyle: {
              textColor: theme.color.textNeutral
          },
          descriptionTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          mode: {
              disabled: {
                  titleTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$y,
      mode: mode$9,
      tone: tone$h
  });

  var base$x = theme => ({
      titleTextStyle: theme.typography.headline3,
      descriptionTextStyle: theme.typography.body3
  });

  var tone$g = theme => ({
      neutral: {
          detailsTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          descriptionTextStyle: {
              textColor: theme.color.textNeutral
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      inverse: {
          detailsTextStyle: {
              textColor: theme.color.textInverseSecondary
          },
          descriptionTextStyle: {
              textColor: theme.color.textInverse
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      brand: {
          detailsTextStyle: {
              textColor: theme.color.textNeutralSecondary
          },
          descriptionTextStyle: {
              textColor: theme.color.textNeutral
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  },
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$x,
      tone: tone$g
  });

  var base$w = theme => ({
      height: theme.spacer.md,
      animation: theme.animation.utility,
      radius: theme.radius.xs
  });

  var tone$f = theme => ({
      neutral: {
          barColor: theme.color.fillNeutralTertiary,
          progressColor: theme.color.fillNeutral
      },
      inverse: {
          barColor: theme.color.fillInverseTertiary,
          progressColor: theme.color.fillInverse
      },
      brand: {
          barColor: theme.color.fillNeutralTertiary,
          progressColor: theme.color.fillBrand
      }
  });

  var styles$w = Object.freeze({
      __proto__: null,
      base: base$w,
      tone: tone$f
  });

  class ProgressBar extends Base$1 {
      static _template() {
          return {
              Bar: {
                  zIndex: 1
              },
              Progress: {
                  alpha: 0,
                  zIndex: 2
              }
          };
      }
      static get __themeStyle() {
          return styles$w;
      }
      static get __componentName() {
          return "ProgressBar";
      }
      static get properties() {
          return [ "progress" ];
      }
      static get tags() {
          return [ "Bar", "Progress" ];
      }
      _construct() {
          super._construct && super._construct();
          this._progress = 0;
      }
      _update() {
          this._updateTextures();
          this._updateProgress();
          if (this._progressChanged) {
              this.fireAncestors("$announce", this.announce);
              this._progressChanged = false;
          }
      }
      _updateTextures() {
          var w = this._getProgressWidth();
          var radius = getMaxRoundRadius(this.style.radius, this.w - 2, this.h);
          this._Bar.texture = lng$1.Tools.getRoundRect(this.w - 2, this.h, radius, 0, 0, true, this.style.barColor);
          this._Progress.texture = lng$1.Tools.getRoundRect(w + 1, this.h, radius, 0, 0, true, this.style.progressColor);
      }
      _updateProgress() {
          var w = this._getProgressWidth();
          this._Progress.smooth = {
              w: [ w, this.style.animation ],
              alpha: Number(w > 0)
          };
      }
      _setProgress(progress) {
          this._progressChanged = progress !== this._progress;
          return progress;
      }
      set announce(announce) {
          super.announce = announce;
      }
      get announce() {
          if (this._announce !== undefined && this._announce !== null) {
              return this._announce;
          }
          var progress = this.progress;
          if (progress > 1) {
              progress = 1;
          } else if (progress < 0) {
              progress = 0;
          }
          return "".concat(Math.round(progress * 100), "%");
      }
      _getProgressWidth() {
          var p = this.w * this._progress;
          var w = p <= 0 ? 0 : Math.min(p, this.w);
          return w;
      }
  }

  var base$v = theme => ({
      animationEntrance: theme.animation.standardEntrance,
      animationExit: theme.animation.standardExit,
      logoWidth: theme.spacer.lg * 5,
      logoHeight: theme.spacer.xxl + theme.spacer.md,
      metadataLocation: "standard",
      paddingX: theme.spacer.xl,
      paddingY: theme.spacer.lg,
      paddingYProgress: theme.spacer.xl,
      paddingYBetweenContent: theme.spacer.md,
      radius: theme.radius.md,
      alpha: theme.alpha.primary
  });

  var tone$e = theme => ({
      neutral: {
          mode: {
              focused: {
                  backgroundColor: theme.color.interactiveNeutralFocusSoft
              }
          }
      },
      inverse: {
          mode: {
              focused: {
                  backgroundColor: theme.color.interactiveInverseFocusSoft
              }
          }
      },
      brand: {
          mode: {
              focused: {
                  backgroundColor: theme.color.interactiveBrandFocusSoft
              }
          }
      }
  });

  var mode$8 = theme => ({
      disabled: {
          alpha: theme.alpha.inactive
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$v,
      mode: mode$8,
      tone: tone$e
  });

  function base$u(theme) {
      return {
          alpha: theme.alpha.primary,
          counterTextStyle: theme.typography.headline3,
          itemSize: theme.layout.gutterX * 2,
          itemSpacing: theme.spacer.md,
          radius: theme.radius.sm
      };
  }

  var mode$7 = theme => ({
      disabled: {
          alpha: theme.alpha.inactive
      }
  });

  var tone$d = theme => ({
      neutral: {
          counterBackgroundColor: theme.color.fillInverseSecondary
      },
      inverse: {
          counterBackgroundColor: theme.color.fillNeutralSecondary
      },
      brand: {
          counterBackgroundColor: theme.color.fillInverseSecondary
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$u,
      mode: mode$7,
      tone: tone$d
  });

  var base$t = theme => ({
      detailsTextStyle: theme.typography.body3,
      descriptionTextStyle: {
          maxLines: 3
      },
      descriptionDetailsStyle: {
          paddingY: 5
      },
      fadeWidth: theme.spacer.md * theme.spacer.md,
      provider: {
          itemSize: theme.spacer.xxxl + theme.spacer.md
      }
  });

  var tone$c = theme => ({
      neutral: {
          detailsTextStyle: {
              textColor: theme.color.textNeutral
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      inverse: {
          detailsTextStyle: {
              textColor: theme.color.textInverse
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      },
      brand: {
          detailsTextStyle: {
              textColor: theme.color.textNeutral
          },
          mode: {
              disabled: {
                  detailsTextStyle: {
                      textColor: theme.color.textNeutralDisabled
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$t,
      tone: tone$c
  });

  var base$s = theme => ({
      expandedWidth: utils$1.getWidthByUpCount(theme, 2),
      expandedHeight: utils$1.getDimensions(theme, {
          ratioX: 16,
          ratioY: 9,
          upCount: 4
      }).h,
      imageSize: {
          width: utils$1.getDimensions(theme, {
              ratioX: 16,
              ratioY: 9,
              upCount: 4
          }).w,
          height: utils$1.getDimensions(theme, {
              ratioX: 16,
              ratioY: 9,
              upCount: 4
          }).h
      },
      metadata: {
          descriptionTextStyle: {
              maxLines: 2
          }
      },
      paddingVertical: theme.spacer.md * 1.5
  });

  Object.freeze({
      __proto__: null,
      base: base$s
  });

  var base$r = theme => {
      var {w: w, h: h} = utils$1.getDimensions(theme, {
          ratioX: 16,
          ratioY: 9,
          upCount: 3
      });
      return {
          expandedWidth: utils$1.getWidthByColumnSpan(theme, 8),
          expandedHeight: h,
          imageSize: {
              width: w,
              height: h
          },
          metadata: {
              descriptionTextStyle: {
                  maxLines: 3
              }
          }
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$r
  });

  var base$q = theme => ({
      expandedWidth: utils$1.getWidthByUpCount(theme, 4),
      expandedHeight: utils$1.getDimensions(theme, {
          ratioX: 16,
          ratioY: 9,
          upCount: 4
      }).h + theme.spacer.xxxl * 7 + theme.spacer.lg + theme.spacer.xxs,
      metadata: {
          descriptionTextStyle: {
              maxLines: 3
          }
      },
      marqueeOnFocus: true
  });

  Object.freeze({
      __proto__: null,
      base: base$q
  });

  var base$p = theme => ({
      expandedHeight: utils$1.getDimensions(theme, {
          ratioX: 16,
          ratioY: 9,
          upCount: 4
      }).h + theme.spacer.md * 14,
      metadata: {
          descriptionTextStyle: {
              maxLines: 1
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$p
  });

  var base$o = theme => {
      var strokeWidth = theme.stroke.sm;
      var size = theme.spacer.xl;
      return {
          width: size,
          height: size,
          iconWidth: theme.spacer.md,
          iconHeight: theme.spacer.md,
          radius: theme.radius.xs,
          strokeWidth: strokeWidth
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$o
  });

  var base$n = theme => ({
      itemSpacing: theme.layout.gutterY,
      scrollIndex: 0,
      itemTransition: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
          duration: theme.animation.duration.fast
      })
  });

  Object.freeze({
      __proto__: null,
      base: base$n
  });

  var base$m = theme => {
      var paddingX = theme.spacer.lg;
      var radius = theme.radius.xl;
      var logoRadius = Math.max(radius - paddingX / 2, 0);
      return {
          height: theme.spacer.md * 8,
          iconStyle: {
              radius: radius,
              width: theme.spacer.xxxl,
              height: theme.spacer.xxxl
          },
          logoStyle: {
              radius: logoRadius,
              width: theme.spacer.md * 7,
              height: theme.spacer.md * 6
          },
          minWidth: theme.spacer.md * 9,
          paddingX: paddingX,
          paddingXNoTitle: theme.spacer.md,
          prefixPadding: theme.spacer.md,
          radius: radius,
          contentSpacing: theme.spacer.md
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$m
  });

  var base$l = theme => {
      var parentStyle = base$m(theme);
      var height = theme.spacer.md * 7;
      var radiusOffset = (parentStyle.height - height) / 2;
      var radius = Math.max(parentStyle.radius - radiusOffset, 0);
      var logoRadius = Math.max(radius - parentStyle.paddingX / 2, 0);
      return {
          height: height,
          logoStyle: {
              radius: logoRadius,
              height: theme.spacer.md * 5,
              width: theme.spacer.md * 6
          },
          radius: radius,
          minWidth: theme.spacer.md * 8,
          textStyle: theme.typography.button2
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$l
  });

  var base$k = theme => ({
      width: getWidthByUpCount(theme, 1),
      titleMarginBottom: theme.spacer.lg,
      titleMarginLeft: theme.layout.gutterX,
      titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
          textColor: theme.color.textNeutral
      })
  });

  var tone$b = theme => ({
      neutral: {
          titleTextStyle: {
              textColor: theme.color.textNeutral
          }
      },
      inverse: {
          titleTextStyle: {
              textColor: theme.color.textInverse
          }
      },
      brand: {
          titleTextStyle: {
              textColor: theme.color.textNeutral
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$k,
      tone: tone$b
  });

  var base$j = theme => ({
      extraItemSpacing: theme.spacer.lg
  });

  Object.freeze({
      __proto__: null,
      base: base$j
  });

  var base$i = theme => ({
      propertyTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
          textColor: theme.color.textNeutral
      }),
      valueTextStyle: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
          textColor: theme.color.textNeutral
      })
  });

  Object.freeze({
      __proto__: null,
      base: base$i
  });

  var base$h = theme => ({
      cursorStyle: {
          textColor: theme.color.textNeutral,
          blink: true,
          width: theme.spacer.xs,
          height: theme.spacer.xxl
      },
      eyebrowTextStyle: _objectSpread(_objectSpread({}, theme.typography.caption1), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutral
      }),
      textStyle: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutral
      }),
      helpTextStyle: _objectSpread(_objectSpread({}, theme.typography.caption1), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutralSecondary
      }),
      minWidth: getWidthByUpCount(theme, 4),
      paddingX: theme.spacer.xl,
      paddingY: theme.spacer.xl,
      backgroundColor: theme.color.interactiveNeutral
  });

  var mode$6 = theme => ({
      disabled: {
          eyebrowTextStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          helpTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      },
      focused: {
          cursorStyle: {
              textColor: theme.color.textInverse
          },
          eyebrowTextStyle: {
              textColor: theme.color.textNeutral
          },
          helpTextStyle: {
              textColor: theme.color.textNeutralSecondary
          }
      }
  });

  var tone$a = theme => ({
      inverse: {
          mode: {
              focused: {
                  eyebrowTextStyle: {
                      textColor: theme.color.textNeutral
                  },
                  helpTextStyle: {
                      textColor: theme.color.textNeutral
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$h,
      mode: mode$6,
      tone: tone$a
  });

  var base$g = theme => {
      var textStyle = theme.typography.headline2;
      return {
          height: theme.spacer.md * 9,
          minWidth: theme.spacer.md * 7,
          paddingX: theme.spacer.md,
          textStyle: textStyle,
          sizes: {
              sm: 1,
              md: 2,
              lg: 3,
              xl: 4,
              xxl: 5
          },
          baseWidth: theme.spacer.md * 7,
          iconWidth: textStyle.lineHeight,
          iconHeight: textStyle.lineHeight
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$g
  });

  var base$f = theme => ({
      keySpacing: theme.spacer.md,
      screenW: theme.layout.screenW,
      marginX: theme.layout.marginX,
      inputSpacing: theme.spacer.md * 10 + theme.spacer.md,
      inputStyle: {
          radius: theme.radius.md
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$f
  });

  var base$e = theme => {
      var size = theme.spacer.lg;
      return {
          width: size,
          height: size,
          radius: size / 2
      };
  };

  var tone$9 = theme => ({
      neutral: {
          circleColor: theme.color.interactiveNeutralFocus,
          mode: {
              disabled: {
                  circleColor: theme.color.fillNeutralDisabled
              }
          }
      },
      inverse: {
          circleColor: theme.color.interactiveInverseFocus,
          mode: {
              disabled: {
                  circleColor: theme.color.fillInverseDisabled
              }
          }
      },
      brand: {
          circleColor: theme.color.interactiveBrandFocus,
          mode: {
              disabled: {
                  circleColor: theme.color.fillInverseDisabled
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$e,
      tone: tone$9
  });

  var base$d = theme => ({
      alpha: theme.alpha.primary,
      descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutralSecondary
      }),
      height: theme.spacer.xxl * 3,
      logoStyle: {
          width: theme.spacer.xxl * 2,
          height: theme.spacer.xxl * 2,
          radius: theme.radius.sm
      },
      paddingX: theme.spacer.xl,
      contentSpacing: theme.spacer.lg,
      titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutral
      }),
      width: utils$1.getWidthByColumnSpan(theme, 3)
  });

  var mode$5 = theme => ({
      disabled: {
          alpha: theme.alpha.inactive,
          descriptionTextStyle: {
              textColor: theme.color.textNeutralDisabled
          },
          titleTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      },
      focused: {
          descriptionTextStyle: {
              textColor: theme.color.textInverseSecondary
          },
          titleTextStyle: {
              textColor: theme.color.textInverse
          }
      }
  });

  var tone$8 = theme => ({
      inverse: {
          mode: {
              focused: {
                  descriptionTextStyle: {
                      textColor: theme.color.textNeutral
                  },
                  titleTextStyle: {
                      textColor: theme.color.textNeutral
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$d,
      mode: mode$5,
      tone: tone$8
  });

  var base$c = () => ({
      showArrows: false,
      showKnob: false
  });

  var mode$4 = () => ({
      focused: {
          showArrows: true
      }
  });

  var tone$7 = theme => ({
      neutral: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillInverse,
                  progressBar: {
                      barColor: theme.color.fillInverseTertiary,
                      progressColor: theme.color.fillInverse
                  }
              }
          }
      },
      inverse: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillNeutral,
                  progressBar: {
                      barColor: theme.color.fillNeutralTertiary,
                      progressColor: theme.color.fillNeutral
                  }
              }
          }
      },
      brand: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillInverse,
                  progressBar: {
                      barColor: theme.color.fillBrandTertiary,
                      progressColor: theme.color.fillBrand
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$c,
      mode: mode$4,
      tone: tone$7
  });

  var base$b = theme => {
      var size = theme.spacer.lg;
      return {
          arrowAlphaValue: theme.alpha.primary,
          arrowAlphaValueLimit: theme.alpha.secondary,
          arrowHeight: theme.spacer.xxl,
          arrowSpacing: theme.spacer.md,
          arrowWidth: theme.spacer.xxl,
          arrowColor: theme.color.fillNeutral,
          containerHeight: theme.spacer.lg + theme.spacer.xs,
          iconLeftSrc: theme.asset.arrowLeft,
          iconRightSrc: theme.asset.arrowRight,
          minWidth: getWidthByColumnSpan(theme, 2),
          progressBar: {},
          width: size,
          height: size,
          radius: size / 2,
          showArrows: true,
          showKnob: true,
          circleAnimation: {}
      };
  };

  var mode$3 = () => ({
      disabled: {
          arrowAlphaValue: 0
      }
  });

  var tone$6 = theme => ({
      neutral: {
          arrowColor: theme.color.fillNeutral,
          circleColor: theme.color.interactiveNeutralFocus
      },
      inverse: {
          arrowColor: theme.color.fillInverse,
          circleColor: theme.color.interactiveInverseFocus
      },
      brand: {
          arrowColor: theme.color.fillNeutral,
          circleColor: theme.color.interactiveNeutralFocus
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$b,
      mode: mode$3,
      tone: tone$6
  });

  var base$a = theme => ({
      paddingY: theme.spacer.md + theme.spacer.xs,
      valueTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
          maxLines: 1,
          textColor: theme.color.textNeutralSecondary
      })
  });

  var mode$2 = theme => ({
      disabled: {
          valueTextStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      },
      focused: {
          valueTextStyle: {
              textColor: theme.color.textInverseSecondary
          }
      }
  });

  var tone$5 = theme => ({
      neutral: {
          mode: {
              focused: {
                  valueTextStyle: {
                      textColor: theme.color.textInverseSecondary
                  }
              }
          }
      },
      inverse: {
          mode: {
              focused: {
                  valueTextStyle: {
                      textColor: theme.color.textNeutralSecondary
                  }
              }
          }
      },
      brand: {
          mode: {
              focused: {
                  valueTextStyle: {
                      textColor: theme.color.textInverseSecondary
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$a,
      mode: mode$2,
      tone: tone$5
  });

  var base$9 = theme => ({
      arrowAlphaValue: theme.alpha.primary,
      arrowAlphaValueLimit: theme.alpha.secondary,
      arrowWidth: theme.spacer.xxl,
      arrowHeight: theme.spacer.xxl,
      iconLeftSrc: theme.asset.arrowLeft,
      iconRightSrc: theme.asset.arrowRight
  });

  var tone$4 = theme => ({
      neutral: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillInverse
              }
          }
      },
      inverse: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillNeutral
              }
          }
      },
      brand: {
          mode: {
              focused: {
                  arrowColor: theme.color.fillInverse
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$9,
      tone: tone$4
  });

  var base$8 = theme => ({
      textStyle: theme.typography.body2,
      fadeHeight: 100,
      scroll: {
          timingFunction: "linear",
          duration: theme.animation.duration.xfast
      },
      contentMarginTop: theme.spacer.md,
      contentMarginLeft: theme.spacer.xl,
      sliderMarginLeft: theme.spacer.lg + theme.spacer.xxs
  });

  Object.freeze({
      __proto__: null,
      base: base$8
  });

  var base$7 = theme => {
      var {scroll: scroll} = base$8(theme);
      return {
          progressBar: {
              animation: scroll
          },
          circleAnimation: scroll
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$7
  });

  var base$6 = theme => ({
      alpha: theme.alpha.none,
      animation: theme.animation.standardEntrance,
      blur: theme.spacer.xxl,
      color: theme.color.shadowNeutralFocus,
      offsetX: 0,
      offsetY: theme.spacer.lg,
      radius: theme.radius.md,
      spread: theme.spacer.md * -1,
      maxOffsetY: theme.spacer.xxl,
      maxOffsetX: 0
  });

  var mode$1 = theme => ({
      focused: {
          alpha: theme.alpha.secondary,
          offsetY: theme.spacer.xxl
      }
  });

  var tone$3 = theme => ({
      neutral: {
          color: theme.color.shadowNeutralFocus
      },
      inverse: {
          color: theme.color.shadowInverseFocus
      },
      brand: {
          color: theme.color.shadowBrandFocus
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$6,
      mode: mode$1,
      tone: tone$3
  });

  var base$5 = theme => {
      var size = theme.spacer.xxl;
      return {
          width: size,
          height: size,
          radius: size / 2
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$5
  });

  var base$4 = theme => ({
      tabSpacing: theme.spacer.lg,
      tabsMarginBottom: theme.spacer.xxl
  });

  Object.freeze({
      __proto__: null,
      base: base$4
  });

  var base$3 = theme => ({
      radius: theme.radius.xl,
      paddingX: theme.spacer.xxxl + theme.spacer.xxs,
      paddingY: theme.spacer.md + theme.spacer.xs,
      paddingXNoTitle: theme.spacer.xl,
      iconSize: theme.spacer.xxxl,
      iconMarginRight: theme.spacer.md,
      textStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
          textColor: theme.color.textNeutral
      }),
      backgroundColor: theme.color.fillTransparent,
      contentColor: theme.color.fillNeutral
  });

  var mode = theme => ({
      focused: {
          backgroundColor: theme.color.interactiveNeutralFocus,
          contentColor: theme.color.fillInverse,
          textStyle: {
              textColor: theme.color.textInverse
          }
      },
      selected: {
          backgroundColor: theme.color.interactiveNeutralFocusSoft,
          contentColor: theme.color.fillNeutral,
          textStyle: {
              textColor: theme.color.textNeutral
          }
      },
      disabled: {
          backgroundColor: theme.color.fillTransparent,
          contentColor: theme.color.fillNeutralDisabled,
          textStyle: {
              textColor: theme.color.textNeutralDisabled
          }
      }
  });

  var tone$2 = theme => ({
      neutral: {},
      inverse: {
          mode: {
              focused: {
                  contentColor: theme.color.fillNeutral,
                  textStyle: {
                      textColor: theme.color.textNeutral
                  }
              }
          }
      },
      brand: {
          mode: {
              focused: {
                  contentColor: theme.color.fillNeutral,
                  textStyle: {
                      textColor: theme.color.textNeutral
                  }
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$3,
      mode: mode,
      tone: tone$2
  });

  var base$2 = theme => {
      var knobSize = theme.spacer.xl;
      var knobPadding = theme.spacer.xs;
      var strokeWidth = theme.stroke.sm;
      return {
          height: knobSize + (knobPadding + strokeWidth) * 2,
          knobWidth: knobSize,
          knobHeight: knobSize,
          knobRadius: knobSize / 2,
          knobPadding: knobPadding,
          strokeWidth: strokeWidth,
          width: (strokeWidth + knobPadding * 2 + knobSize) * 2
      };
  };

  var tone$1 = theme => ({
      neutral: {
          strokeColor: theme.color.fillNeutral,
          backgroundColor: theme.color.fillInverseTertiary,
          backgroundColorChecked: theme.color.fillNeutral,
          knobColor: theme.color.fillNeutral,
          knobColorChecked: theme.color.fillInverse,
          mode: {
              disabled: {
                  strokeColor: theme.color.fillNeutralDisabled,
                  backgroundColor: theme.color.fillInverseDisabled,
                  backgroundColorChecked: theme.color.fillNeutralDisabled,
                  knobColor: theme.color.fillNeutralDisabled,
                  knobColorChecked: theme.color.fillInverseDisabled
              }
          }
      },
      inverse: {
          strokeColor: theme.color.fillInverse,
          backgroundColor: theme.color.fillNeutralTertiary,
          backgroundColorChecked: theme.color.fillInverse,
          knobColor: theme.color.fillInverse,
          knobColorChecked: theme.color.fillNeutral,
          mode: {
              disabled: {
                  strokeColor: theme.color.fillInverseDisabled,
                  backgroundColor: theme.color.fillNeutralDisabled,
                  backgroundColorChecked: theme.color.fillInverseDisabled,
                  knobColor: theme.color.fillInverseDisabled,
                  knobColorChecked: theme.color.fillNeutralDisabled
              }
          }
      },
      brand: {
          strokeColor: theme.color.fillBrand,
          backgroundColor: theme.color.fillBrandTertiary,
          backgroundColorChecked: theme.color.fillBrand,
          knobColor: theme.color.fillBrand,
          knobColorChecked: theme.color.fillInverse,
          mode: {
              disabled: {
                  strokeColor: theme.color.fillNeutralDisabled,
                  backgroundColor: theme.color.fillInverseDisabled,
                  backgroundColorChecked: theme.color.fillNeutralDisabled,
                  knobColor: theme.color.fillNeutralDisabled,
                  knobColorChecked: theme.color.fillInverseDisabled
              }
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base$2,
      tone: tone$1
  });

  var base$1 = theme => {
      var knobSize = theme.spacer.lg;
      var knobPadding = theme.spacer.xxs;
      var strokeWidth = theme.stroke.sm;
      return {
          height: knobSize + (knobPadding + strokeWidth) * 2,
          knobWidth: knobSize,
          knobHeight: knobSize,
          knobRadius: knobSize / 2,
          knobPadding: knobPadding,
          strokeWidth: strokeWidth,
          width: (strokeWidth + knobPadding * 2 + knobSize) * 2
      };
  };

  Object.freeze({
      __proto__: null,
      base: base$1
  });

  class Bubble extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._w = 0;
          this._h = 0;
          this._radius = 0;
          this._pointerWidth = 0;
          this._pointerHeight = 0;
          this._strokeWidth = 0;
          this._color = "white";
      }
      set w(w) {
          this._w = w;
          this._changed();
      }
      get w() {
          return this._w;
      }
      set h(h) {
          this._h = h;
          this._changed();
      }
      get h() {
          return this._h;
      }
      set radius(radius) {
          if (Array.isArray(radius)) {
              this._radius = new Array(4).fill().map(((_, index) => radius[index] || 0));
          } else {
              this._radius = radius;
          }
          this._changed();
      }
      get radius() {
          return this._radius;
      }
      set pointerWidth(pointerWidth) {
          this._pointerWidth = pointerWidth;
          this._changed();
      }
      get pointerWidth() {
          return this._pointerWidth;
      }
      set pointerHeight(pointerHeight) {
          this._pointerHeight = pointerHeight;
          this._changed();
      }
      get pointerHeight() {
          return this._pointerHeight;
      }
      set strokeWidth(strokeWidth) {
          this._strokeWidth = strokeWidth;
          this._changed();
      }
      get strokeWidth() {
          return this._strokeWidth;
      }
      set color(color) {
          this._color = lng$1.StageUtils.getRgbaString(color);
          this._changed();
      }
      get color() {
          return this._color;
      }
      createBubble(_ref24) {
          var {stage: stage, w: w = 0, h: h = 0, radius: radius = 0, pointerWidth: pointerWidth = 0, pointerHeight: pointerHeight = 0, strokeWidth: strokeWidth = 1, color: color = "white"} = _ref24;
          var canvas = stage.platform.getDrawingCanvas();
          var ctx = canvas.getContext("2d");
          canvas.width = w + strokeWidth + 4;
          canvas.height = h + strokeWidth + 4;
          ctx.imageSmoothingEnabled = true;
          ctx.fillStyle = color;
          ctx.strokeStyle = color;
          ctx.lineWidth = strokeWidth;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          var initialCoord = .5 * strokeWidth + 1;
          var leftX = initialCoord;
          var rightX = leftX + w;
          var topY = initialCoord;
          var bottomY = topY + h;
          var bottomBubbleY = bottomY - pointerHeight;
          var isRadiusAnArray = Array.isArray(radius);
          ctx.beginPath();
          ctx.moveTo(leftX + (isRadiusAnArray ? radius[0] : radius), topY);
          ctx.lineTo(rightX - (isRadiusAnArray ? radius[0] : radius), topY);
          ctx.arcTo(rightX, topY, rightX, topY + (isRadiusAnArray ? radius[1] : radius), isRadiusAnArray ? radius[1] : radius);
          ctx.lineTo(rightX, bottomBubbleY - (isRadiusAnArray ? radius[2] : radius));
          ctx.arcTo(rightX, bottomBubbleY, rightX - (isRadiusAnArray ? radius[2] : radius), bottomBubbleY, isRadiusAnArray ? radius[2] : radius);
          ctx.lineTo(w / 2 + pointerWidth / 2, bottomBubbleY);
          ctx.arcTo(w / 2, bottomY, w / 2 - pointerWidth / 2, bottomBubbleY, 2);
          ctx.lineTo(w / 2 - pointerWidth / 2, bottomBubbleY);
          ctx.lineTo(leftX + (isRadiusAnArray ? radius[3] : radius), bottomBubbleY);
          ctx.arcTo(leftX, bottomBubbleY, leftX, bottomBubbleY - (isRadiusAnArray ? radius[3] : radius), isRadiusAnArray ? radius[3] : radius);
          ctx.lineTo(leftX, topY + (isRadiusAnArray ? radius[0] : radius));
          ctx.arcTo(leftX, topY, leftX + (isRadiusAnArray ? radius[0] : radius), topY, isRadiusAnArray ? radius[0] : radius);
          ctx.stroke();
          ctx.fill();
          return canvas;
      }
      _getLookupId() {
          var {w: w, h: h, radius: radius, pointerWidth: pointerWidth, pointerHeight: pointerHeight, color: color} = this;
          return "__bubble_".concat(w, "x").concat(h, "_radius-").concat(radius, "_pointer-").concat(pointerWidth, "x").concat(pointerHeight, "_fill-").concat(color);
      }
      _getSourceLoader() {
          return cb => {
              cb(null, {
                  source: this.createBubble(this)
              });
          };
      }
  }

  var base = theme => ({
      marginBottom: theme.spacer.xl,
      paddingX: theme.spacer.lg,
      paddingY: theme.spacer.md,
      pointerWidth: theme.spacer.xxl,
      pointerHeight: theme.spacer.lg,
      radius: theme.radius.sm,
      textStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
          textColor: theme.color.textInverse
      }),
      transition: theme.animation.utility
  });

  var tone = theme => ({
      neutral: {
          backgroundColor: theme.color.fillNeutral,
          textStyle: {
              textColor: theme.color.textInverse
          }
      },
      inverse: {
          backgroundColor: theme.color.fillInverse,
          textStyle: {
              textColor: theme.color.textNeutral
          }
      },
      brand: {
          backgroundColor: theme.color.fillBrand,
          textStyle: {
              textColor: theme.color.textNeutral
          }
      }
  });

  Object.freeze({
      __proto__: null,
      base: base,
      tone: tone
  });

  var defaultAbbreviations = [ {
      pattern: "TV-14",
      replacer: "Rated TV-14"
  }, {
      pattern: "CC",
      replacer: "Closed Captions available"
  }, {
      pattern: "HD",
      replacer: "High Definition available"
  }, {
      pattern: /ENG(?!\+)/,
      replacer: "English Available"
  }, {
      pattern: /ENG\+ES/,
      replacer: "Available in English and Spanish"
  }, {
      pattern: "AD",
      replacer: "Audio Description available"
  }, {
      pattern: "RT",
      replacer: "Rotten Tomatoes"
  }, {
      pattern: /(S)+(\d+)+(E)+(\d+)+/,
      replacer: (match, p1, p2, p3, p4) => "Season ".concat(p2, " Episode ").concat(p4)
  } ];

  generateAbbrevConfig(defaultAbbreviations);

  function wrapWithBoundary(str) {
      return "\\b".concat(str, "\\b");
  }

  function getNumberOfCaptureGroups(regExp) {
      return new RegExp(regExp.toString() + "|").exec("").length - 1;
  }

  function generateAbbrevConfig() {
      var abbreviations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAbbreviations;
      var extendDefault = arguments.length > 1 ? arguments[1] : undefined;
      var abbrev = extendDefault ? [ ...defaultAbbreviations, ...abbreviations ] : abbreviations;
      var stringPatternMap = {};
      var regExpPatternMap = {};
      var abbreviationsPattern = "";
      var patternGroupOffset = 0;
      abbrev.forEach(((_ref27, idx) => {
          var {pattern: pattern, replacer: replacer} = _ref27;
          var stringPattern;
          if (pattern instanceof RegExp) {
              var patternMapIdx = idx + patternGroupOffset;
              regExpPatternMap[patternMapIdx] = {
                  pattern: pattern,
                  replacer: replacer
              };
              stringPattern = wrapWithBoundary(pattern.source);
              patternGroupOffset += getNumberOfCaptureGroups(pattern);
          } else {
              stringPatternMap[pattern] = {
                  replacer: replacer
              };
              stringPattern = wrapWithBoundary(pattern);
          }
          abbreviationsPattern = abbreviationsPattern === "" ? "(".concat(stringPattern, ")") : "".concat(abbreviationsPattern, "|(").concat(stringPattern, ")");
      }));
      abbreviationsPattern = new RegExp(abbreviationsPattern, "g");
      return {
          abbreviationsPattern: abbreviationsPattern,
          stringPatternMap: stringPatternMap,
          regExpPatternMap: regExpPatternMap
      };
  }

  var rad = deg => deg * Math.PI / 180;

  var deg = rad => rad * 180 / Math.PI;

  var getBreakpoints = (width, height) => {
      var a = height / 2;
      var b = width / 2;
      var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
      var C = 90;
      var A = Math.ceil(deg(Math.asin(a * Math.sin(rad(C)) / c)));
      var B = 180 - C - A;
      return [ B, 90, 90 + A, 180, 180 + B, 270, 270 + A, 360 ];
  };

  var points = (degrees, width, height) => {
      var breakAngles = getBreakpoints(width, height);
      var breakIndex = breakAngles.findIndex((angle => angle >= degrees));
      var b = height / 2;
      var max = width / 2;
      if ([ 1, 2, 5, 6 ].includes(breakIndex)) {
          b = width / 2;
          max = height / 2;
      }
      if ([ 2, 4, 6 ].includes(breakIndex)) {
          degrees = degrees - breakAngles[breakIndex - 1];
      } else if (breakIndex > 0) {
          degrees = breakAngles[breakIndex] - degrees;
      }
      var A = degrees;
      var B = 90 - A;
      var a = Math.ceil(Math.sin(rad(A)) * b / Math.sin(rad(B)));
      if (a > max) {
          a = max;
      }
      var x0 = 0;
      var y0 = 0;
      var x1 = 0;
      var y1 = 0;
      switch (breakIndex) {
        case 0:
          x0 = width / 2 + a;
          break;

        case 1:
          x0 = width;
          y0 = height / 2 - a;
          break;

        case 2:
          x0 = width;
          y0 = height / 2 + a;
          break;

        case 3:
          x0 = width / 2 + a;
          y0 = height;
          break;

        case 4:
          x0 = width / 2 - a;
          y0 = height;
          break;

        case 5:
          y0 = height / 2 + a;
          break;

        case 6:
          y0 = height / 2 - a;
          break;

        case 7:
          x0 = width / 2 - a;
          break;
      }
      if (x0 == 0) {
          x1 = width;
          y1 = height - y0;
      }
      if (y0 == 0) {
          y1 = height;
          x1 = width - x0;
      }
      if (x0 == width) {
          x1 = 0;
          y1 = height - y0;
      }
      if (y0 == height) {
          y1 = 0;
          x1 = width - x0;
      }
      return {
          x0: x0,
          y0: y0,
          x1: x1,
          y1: y1
      };
  };

  class LinearGradient extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._w = 0;
          this._h = 0;
          this._steps = [];
          this._degrees = 0;
      }
      get w() {
          return this._w;
      }
      set w(w) {
          this._w = w;
          this._changed();
      }
      get h() {
          return this._h;
      }
      set h(h) {
          this._h = h;
          this._changed();
      }
      get steps() {
          return this._steps;
      }
      set steps(steps) {
          this._steps = steps;
          this._changed();
      }
      get degrees() {
          return this._degrees;
      }
      set degrees(degrees) {
          this._degrees = degrees;
          this._changed();
      }
      _getLookupId() {
          return "__linearGradient_".concat(this._h, "_").concat(this._w, "_").concat(this._steps.count, "_").concat(this._degrees);
      }
      _getSourceLoader() {
          var w = this._w;
          var h = this._h;
          var d = this._degrees;
          var p = points(d, w, h);
          var {x0: x0, y0: y0, x1: x1, y1: y1} = p;
          var steps = this._steps;
          var strokeWidth = this.strokeWidth;
          var strokeRadius = this.strokeRadius ? Array.isArray(this.strokeRadius) && this.strokeRadius.length === 4 ? this.strokeRadius : Array(4).fill(this.strokeRadius) : Array(4).fill(0);
          return function(cb) {
              var canvas = this.stage.platform.getDrawingCanvas();
              canvas.width = w + strokeWidth + 2;
              canvas.height = h + strokeWidth + 2;
              var ctx = canvas.getContext("2d");
              var gradient = ctx.createLinearGradient(x0, y0, x1, y1);
              steps.forEach((step => {
                  gradient.addColorStop(step.percent, step.color);
              }));
              if (strokeWidth) {
                  var x = .5 * strokeWidth + 1, y = .5 * strokeWidth + 1;
                  ctx.beginPath();
                  ctx.moveTo(x + strokeRadius[0], y);
                  ctx.lineTo(x + w - strokeRadius[1], y);
                  ctx.arcTo(x + w, y, x + w, y + strokeRadius[1], strokeRadius[1]);
                  ctx.lineTo(x + w, y + h - strokeRadius[2]);
                  ctx.arcTo(x + w, y + h, x + w - strokeRadius[2], y + h, strokeRadius[2]);
                  ctx.lineTo(x + strokeRadius[3], y + h);
                  ctx.arcTo(x, y + h, x, y + h - strokeRadius[3], strokeRadius[3]);
                  ctx.lineTo(x, y + strokeRadius[0]);
                  ctx.arcTo(x, y, x + strokeRadius[0], y, strokeRadius[0]);
                  ctx.closePath();
                  ctx.lineWidth = strokeWidth;
                  ctx.strokeStyle = gradient;
                  ctx.stroke();
              } else {
                  ctx.fillStyle = gradient;
                  ctx.fillRect(0, 0, w, h);
              }
              cb(null, {
                  source: canvas,
                  w: w,
                  h: h
              });
          };
      }
  }

  class Circle extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._color = "rgb(0,0,0)";
          this._fill = true;
          this._radius = 100;
          this._stroke = false;
          this._strokeColor = "rgb(0,0,0)";
          this._strokeWidth = 1;
      }
      get fill() {
          return this._fill;
      }
      set fill(fill) {
          this._fill = fill;
          this._changed();
      }
      get radius() {
          return this._radius;
      }
      set radius(radius) {
          this._radius = radius;
          this._changed();
      }
      get color() {
          return this._color;
      }
      set color(color) {
          this._color = color;
          this._changed();
      }
      get stroke() {
          return this._stroke;
      }
      set stroke(stroke) {
          this._stroke = stroke;
          this._changed();
      }
      get strokeWidth() {
          return this._strokeWidth;
      }
      set strokeWidth(strokeWidth) {
          this._strokeWidth = strokeWidth;
          this._changed();
      }
      get strokeColor() {
          return this._strokeColor;
      }
      set strokeColor(strokeColor) {
          this._strokeColor = strokeColor;
          this._changed();
      }
      _getLookupId() {
          return "__circle_".concat(this._radius);
      }
      _getSourceLoader() {
          var color = this._color;
          var fill = this._fill;
          var radius = this._radius;
          var stroke = this._stroke;
          var strokeColor = this._strokeColor;
          var strokeWidth = this._strokeWidth;
          var canvas = this.stage.platform.getDrawingCanvas();
          var dimension = radius;
          if (stroke) {
              dimension = radius + strokeWidth * 2;
          }
          canvas.width = dimension * 2;
          canvas.height = dimension * 2;
          return function(cb) {
              var ctx = canvas.getContext("2d");
              ctx.lineWidth = strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.fillStyle = color;
              ctx.beginPath();
              ctx.arc(dimension, dimension, radius, 0, 2 * Math.PI);
              if (fill) {
                  ctx.fill();
              }
              if (stroke) {
                  ctx.stroke();
              }
              cb(null, {
                  source: canvas,
                  radius: radius
              });
          };
      }
  }

  class Arrow extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._color = "rgb(13, 13, 15)";
          this._w = 0;
          this._h = 0;
          this._direction = "right";
      }
      get w() {
          return this._w;
      }
      set w(l) {
          this._w = l;
          this._changed();
      }
      get h() {
          return this._h;
      }
      set h(l) {
          this._h = l;
          this._changed();
      }
      get direction() {
          return this._direction;
      }
      get color() {
          return this._color;
      }
      set color(color) {
          this._color = color;
          this._changed();
      }
      set direction(direction) {
          this._direction = direction;
          this._changed();
      }
      _getLookupId() {
          return "__triangle_".concat(this._direction, "_").concat(this._w, "x").concat(this._h);
      }
      _getSourceLoader() {
          var color = this._color;
          var w = this._w;
          var h = this._h;
          var direction = this._direction;
          var canvas = this.stage.platform.getDrawingCanvas();
          return function(cb) {
              var ctx = canvas.getContext("2d");
              canvas.width = w;
              canvas.height = h;
              ctx.fillStyle = color;
              ctx.strokeStyle = ctx.fillStyle;
              ctx.lineWidth = 2;
              ctx.lineCap = "round";
              ctx.lineJoin = "round";
              var p = ctx.lineWidth / 2;
              ctx.beginPath();
              if (direction === "right") {
                  ctx.moveTo(p, p);
                  ctx.lineTo(p, h - p);
                  ctx.lineTo(w - p, h / 2);
              } else if (direction === "down") {
                  ctx.moveTo(p, p);
                  ctx.lineTo(w - p, p);
                  ctx.lineTo(w / 2, h - p);
              } else {
                  ctx.moveTo(p, h / 2);
                  ctx.lineTo(w - p, p);
                  ctx.lineTo(w - p, h - p);
              }
              ctx.closePath();
              ctx.stroke();
              ctx.fill();
              cb(null, {
                  source: canvas,
                  w: w,
                  h: h,
                  direction: direction
              });
          };
      }
  }

  class Line extends lng$1.Texture {
      constructor(stage) {
          super(stage);
          this._w = 0;
          this._h = 0;
          this._rounded = false;
      }
      get w() {
          return this._w;
      }
      set w(l) {
          this._w = l;
          this._changed();
      }
      get h() {
          return this._h;
      }
      set h(l) {
          this._h = l;
          this._changed();
      }
      get rounded() {
          return this._rounded;
      }
      set rounded(rounded) {
          this._rounded = rounded;
          this._changed();
      }
      _getLookupId() {
          return "__line_".concat(this._w, "x").concat(this._h).concat(this._rounded ? "_rounded" : "");
      }
      _getSourceLoader() {
          var w = this._w;
          var h = this._h;
          var rounded = this._rounded;
          var canvas = this.stage.platform.getDrawingCanvas();
          return function(cb) {
              var ctx = canvas.getContext("2d");
              canvas.width = w;
              canvas.height = h;
              ctx.lineWidth = h;
              if (rounded) {
                  ctx.lineCap = "round";
              }
              ctx.strokeStyle = "white";
              ctx.beginPath();
              ctx.moveTo(rounded ? 2 : 0, h / 2);
              ctx.lineTo(rounded ? w - 2 : w, h / 2);
              ctx.stroke();
              cb(null, {
                  source: canvas,
                  w: w,
                  h: h,
                  rounded: rounded
              });
          };
      }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2023 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance = null;
  class LISA {
    constructor() {
      this.thunder = thunderJS$1(CONFIG.thunderConfig);
      this.callsign = 'LISA';
      this.INFO = function () {};
      this.LOG = console.log;
      this.ERR = console.error;
      this.metadata = null;
    }
    static get() {
      if (instance === null) {
        instance = new LISA();
      }
      return instance;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO("LISA: activate result:", result);
          resolve(true);
        }).catch(err => {
          this.ERR("LISA: activate error: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error while Thunder Controller LisaApi activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          this.INFO("LISA: deactivate result:", result);
          resolve(true);
        }).catch(err => {
          this.ERR("LISA: deactivate error: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error while Thunder Controller LisaApi deactivate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getMetadata() {
      return new Promise((resolve, reject) => {
        if (this.metadata != null && Object.prototype.hasOwnProperty.call(this.metadata, "dacBundlePlatformNameOverride") && Object.prototype.hasOwnProperty.call(this.metadata, "dacBundleFirmwareCompatibilityKey") && Object.prototype.hasOwnProperty.call(this.metadata, "configUrl")) {
          this.INFO("LISA: getMetadata using cached value.");
          resolve(this.metadata);
        } else {
          // "version" is reserved by ThunderJS; use "versionAsParameter" to avoid "unsupported version error".
          let params = {
            "id": "lisa.dac.config",
            "type": "application/LISA",
            "versionAsParameter": "0"
          };
          this.thunder.call(this.callsign, 'getMetadata', params).then(result => {
            this.INFO("LISA: getMetadata result: ", result);
            if (Object.prototype.hasOwnProperty.call(result, "auxMetadata")) {
              let metadata = {};
              result.auxMetadata.forEach(item => {
                metadata[item.key] = item.value;
              });
              this.metadata = metadata;
              resolve(this.metadata);
            }
            reject(false);
          }).catch(err => {
            this.ERR("LISA: getMetadata error: ", err);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi getMetaData " + JSON.stringify(err), false, null);
            this.metadata = null;
            reject(err);
          });
        }
      });
    }
    install(params) {
      return new Promise((resolve, reject) => {
        this.LOG("LISA: install params:", params);
        this.thunder.call(this.callsign, 'install', params).then(result => {
          this.INFO("LISA: install result: ", result);
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi install " + JSON.stringify(err), false, null);
          this.ERR("LISA: install error: ", err);
          reject(err);
        });
      });
    }
    uninstall(params) {
      return new Promise((resolve, reject) => {
        this.LOG("LISA: uninstall params:", params);
        this.thunder.call(this.callsign, 'uninstall', params).then(result => {
          this.INFO("LISA: uninstall result: ", result);
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi uninstall " + JSON.stringify(err), false, null);
          this.ERR("LISA: uninstall error: ", err);
          reject(err);
        });
      });
    }
    getStorageDetails(params) {
      return new Promise((resolve, reject) => {
        this.LOG("LISA: getStorageDetails params:", params);
        this.thunder.call(this.callsign, 'getStorageDetails', params).then(result => {
          this.INFO("LISA: getStorageDetails result: ", result);
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi getStaorageDetails " + JSON.stringify(err), false, null);
          this.ERR("LISA: getStorageDetails error: ", err);
          reject(err);
        });
      });
    }
    getList() {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getList').then(result => {
          this.INFO("LISA: getList result: ", result);
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi getList " + JSON.stringify(err), false, null);
          this.ERR("LISA: getList error: ", err);
          reject(err);
        });
      });
    }
    getProgress(handle) {
      return new Promise((resolve, reject) => {
        this.thunder.call(this.callsign, 'getProgress', {
          handle: handle
        }).then(result => {
          this.LOG("LISA: getProgress result: ", result);
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "LisaApiError", "Error in Thunder LisaApi getProgress " + JSON.stringify(err), false, null);
          this.ERR("LISA: getProgress error: ", err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let platform = null;
  let thunder$a = null;
  function thunderJS() {
    if (thunder$a) return thunder$a;
    thunder$a = thunderJS$1(CONFIG.thunderConfig);
    return thunder$a;
  }
  async function registerListener(plugin, eventname, cb) {
    return await LISA.get().thunder.on(plugin, eventname, notification => {
      console.log("DACApi Received event " + plugin + ":" + eventname, notification);
      if (cb != null) {
        cb(notification, eventname, plugin);
      }
    });
  }
  async function addEventHandler(eventHandlers, pluginname, eventname, cb) {
    eventHandlers.push(await registerListener(pluginname, eventname, cb));
  }
  function translateLisaProgressEvent(evtname) {
    if (evtname === "DOWNLOADING") {
      return "Downloading";
    } else if (evtname === "UNTARING") {
      return "Extracting";
    } else if (evtname === "UPDATING_DATABASE") {
      return "Installing";
    } else if (evtname === "FINISHED") {
      return "Finished";
    } else {
      return evtname;
    }
  }
  async function registerLISAEvents(id, progress) {
    let eventHandlers = [];
    if (progress === undefined) {
      console.log("DACApi progress undefined, return");
      return;
    }
    progress.reset();
    let handleProgress = (notification, eventname, plugin) => {
      console.log('DACApi handleProgress: ' + plugin + ' ' + eventname);
      if (plugin !== 'LISA') {
        return;
      }
      if (notification.status === 'Progress') {
        let parts = notification.details.split(" ");
        if (parts.length >= 2) {
          let pc = parseFloat(parts[1]) / 100.0;
          progress.setProgress(pc, translateLisaProgressEvent(parts[0]));
        }
      } else if (notification.status === 'Success') {
        progress.fireAncestors('$fireDACOperationFinished', true);
        eventHandlers.map(h => {
          h.dispose();
        });
        eventHandlers = [];
      } else if (notification.status === 'Failed') {
        progress.fireAncestors('$fireDACOperationFinished', false, 'Failed');
        eventHandlers.map(h => {
          h.dispose();
        });
        eventHandlers = [];
      }
    };
    addEventHandler(eventHandlers, 'LISA', 'operationStatus', handleProgress);
  }
  const installDACApp = async (app, progress) => {
    let platName = await getPlatformNameForDAC();
    let url = app.url;
    if (!Storage$1.get("CloudAppStore")) {
      url = app.url.replace(/ah212/g, platName);
    }
    registerLISAEvents(app.id, progress);
    let param = {
      id: app.id,
      type: 'application/dac.native',
      appName: app.name,
      category: app.category,
      versionAsParameter: app.version,
      url: url
    };
    try {
      console.info("installDACApp LISA.install with param:", JSON.stringify(param));
      app.handle = await LISA.get().install(param);
    } catch (error) {
      console.error('DACApi Error on installDACApp: ' + error.code + ' ' + error.message);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", 'DACApi Error on installDACApp: ' + JSON.stringify(err), true, null);
      app.errorCode = error.code;
      return false;
    }
    return true;
  };
  const uninstallDACApp = async (app, progress) => {
    // Could be same app is running; lets end it if so.
    await thunderJS()['org.rdk.RDKShell'].getClients().then(response => {
      if (Array.isArray(response.clients) && response.clients.includes(app.id.toLowerCase())) {
        console.log("DACApi killing " + app.id + " as we got a match in getClients response.");
        thunderJS()['org.rdk.RDKShell'].kill({
          client: app.id
        });
      }
    });
    registerLISAEvents(app.id, progress);
    let param = {
      id: app.id,
      type: 'application/dac.native',
      versionAsParameter: app.version,
      uninstallType: 'full'
    };
    try {
      console.info("uninstallDACApp LISA.uninstall with params:", JSON.stringify(param));
      if (Object.prototype.hasOwnProperty.call(app, "errorCode")) delete app.errorCode;
      await LISA.get().uninstall(param);
    } catch (error) {
      console.error('DACApi Error on LISA uninstall: ' + error.code + ' ' + error.message);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", 'DACApi Error on LISA uninstall: ' + JSON.stringify(err), true, null);
      app.errorCode = error.code;
      return false;
    }
    return true;
  };
  const getInstalledDACApps = async () => {
    let result = null;
    try {
      result = await LISA.get().getList();
    } catch (error) {
      console.error('DACApi Error on LISA getList: ', error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", 'DACApi Error on LISA getList: ' + JSON.stringify(err), false, null);
    }
    return result == null ? [] : result.apps ? result.apps : [];
  };
  const getPlatformNameForDAC = async () => {
    //code temporarily added based on new api implementation
    platform = await getPlatform();
    if (platform == null || platform === "") {
      platform = await getDeviceName();
      platform = platform.split('-')[0];
      console.info("getPlatformNameForDAC platform after split: ", JSON.stringify(platform));
    } else {
      return platform;
    }
    if (platform.startsWith('raspberrypi4')) {
      return 'rpi4';
    } else if (platform.startsWith('raspberrypi')) {
      return 'rpi3';
    } else if (platform === 'brcm972180hbc') {
      return '7218c';
    } else if (platform === 'brcm972127ott') {
      return '72127ott';
    } else if (platform === 'vip7802') {
      return '7218c';
    } else if (platform === 'm393') {
      return '7218c';
    } else if (platform.toLowerCase().includes('hp44h')) {
      return 'ah212';
    } else if (platform.toLowerCase().includes('amlogic')) {
      return 'ah212';
    } else if (platform.toLowerCase().includes('mediaclient')) {
      return 'rtd1319';
    } else if (platform.toLowerCase().includes('blade')) {
      return 'rtd1319';
    } else {
      // default
      return 'rpi3';
    }
  };
  const getDeviceName = async () => {
    let result = null;
    try {
      result = await thunderJS().DeviceInfo.systeminfo();
    } catch (error) {
      console.error('DAC Api Error on systeminfo: ', error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", 'DAC Api Error on systeminfo: ' + JSON.stringify(err), false, null);
    }
    return result == null ? "unknown" : result.devicename;
  };
  const startDACApp = async app => {
    console.log('DACApi startDACApp invoked with data:' + app);
    let result = null;
    try {
      if (app.type === 'application/dac.native') {
        result = await thunderJS()['org.rdk.RDKShell'].launchApplication({
          client: app.id,
          mimeType: app.type,
          uri: app.id + ';' + app.version + ';' + app.type,
          topmost: true,
          focus: true
        });
      } else if (app.type === 'application/html') {
        result = await thunderJS()['org.rdk.RDKShell'].launch({
          callsign: app.id,
          uri: app.url,
          type: 'HtmlApp'
        });
      } else if (app.type === 'application/lightning') {
        result = await thunderJS()['org.rdk.RDKShell'].launch({
          callsign: app.id,
          uri: app.url,
          type: 'LightningApp'
        });
      } else {
        console.warn('DACApi Unsupported app type: ' + app.type);
        return false;
      }
    } catch (error) {
      console.error('DACApi Error on launchApplication: ', error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", 'DACApi Error on launchApplication: ' + JSON.stringify(err), false, null);
      return false;
    }
    if (result == null) {
      console.error('DACApi launch error returned result: ', result);
      return false;
    } else if (!result.success) {
      // Could be same app is in suspended mode.
      await thunderJS()['org.rdk.RDKShell'].getClients().then(response => {
        if (Array.isArray(response.clients) && response.clients.includes(app.id.toLowerCase())) {
          console.log("DACApi " + app.id + " got a match in getClients response; could be in suspended mode, resume it.");
          thunderJS()['org.rdk.RDKShell'].resumeApplication({
            client: app.id
          }).then(result => {
            if (!result.success) {
              return false;
            } else if (result.success) {
              if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
                thunder$a.call('org.rdk.RDKShell', 'setVisibility', {
                  "client": GLOBALS.selfClientName,
                  "visible": false
                });
              }
            }
          });
        }
      });
    } else if (result.success) {
      if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
        thunder$a.call('org.rdk.RDKShell', 'setVisibility', {
          "client": GLOBALS.selfClientName,
          "visible": false
        });
      }
    } else ;
    try {
      result = await thunderJS()['org.rdk.RDKShell'].moveToFront({
        client: app.id
      });
    } catch (error) {
      console.log('DACApi Error on moveToFront: ', error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "Error in Thunder RDKShell moveToFront DACApiError" + JSON.stringify(err), false, null);
    }
    try {
      result = await thunderJS()['org.rdk.RDKShell'].setFocus({
        client: app.id
      });
      GLOBALS.topmostApp = app.id + ';' + app.version + ';' + app.type;
    } catch (error) {
      console.log('DACApi Error on setFocus: ', error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "Error in Thunder DACApi setFocus" + JSON.stringify(err), false, null);
      return false;
    }
    return result == null ? false : result.success;
  };

  /* WorkAround until proper cloud based App Catalog support */
  const getAppCatalogInfo = async () => {
    Storage$1.set("CloudAppStore", true);
    let appListArray = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-path")) {
          Storage$1.set("CloudAppStore", false);
          console.log("Fetching apps from local server");
          let url = data["app-catalog-path"];
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("DACApi fetch result: ", result);
            if (Object.prototype.hasOwnProperty.call(result, "applications")) {
              appListArray = result["applications"];
            } else {
              console.error("DACApi result does not have applications");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", JSON.stringify(err), false, null);
              Storage$1.set("CloudAppStore", true);
            }
          }).catch(error => {
            console.error("DACApi fetch error from local server", error);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", JSON.stringify(err), false, null);
            Storage$1.set("CloudAppStore", true);
          });
        } else if (Storage$1.get("CloudAppStore") && data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-cloud")) {
          console.log("Fetching apps from cloud server");
          let cloud_data = data["app-catalog-cloud"];
          if (cloud_data && Object.prototype.hasOwnProperty.call(cloud_data, "url")) {
            let url = cloud_data["url"] + "?platform=arm:v7:linux&category=application";
            await fetch(url, {
              method: 'GET',
              cache: "no-store"
            }).then(response => response.text()).then(result => {
              result = JSON.parse(result);
              console.log("DACApi fetch result: ", result);
              if (Object.prototype.hasOwnProperty.call(result, "applications")) {
                appListArray = result["applications"];
              } else {
                console.error("DACApi result does not have applications");
                Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "DACApi result does not have applications", false, null);
              }
            }).catch(error => {
              console.log("DACApi fetch error from cloud", error);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", JSON.stringify(error), false, null);
            });
          } else {
            console.error("DACApi app-catalog-cloud does not have URL property.");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "DACApi app-catalog-cloud does not have URL property.", false, null);
          }
        }
      } else {
        let asms = await getAsmsUrlObj();
        let myHeaders = new Headers();
        if (asms.password !== null && asms.username !== null) {
          myHeaders.append("Authorization", "Basic " + btoa(asms.username + ':' + asms.password));
        }
        let requestOptions = {
          method: 'GET',
          headers: myHeaders,
          redirect: 'follow'
        };
        await fetch(asms.url, requestOptions).then(response => response.json()).then(result => {
          if (Object.prototype.hasOwnProperty.call(result, "applications")) {
            appListArray = result["applications"];
          } else {
            console.error("DACApi result does not have applications");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "DACApi result does not have applications", false, null);
          }
        }).catch(error => {
          console.log("DACApi fetch error from cloud", error);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
        });
      }
    } catch (error) {
      console.log("DACApi Using new getMetadata API.");
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "DACApi Using new getMetadata API.", false, null);
      let asms = await getAsmsUrlObj();
      let myHeaders = new Headers();
      if (asms.password !== null && asms.username !== null) {
        myHeaders.append("Authorization", "Basic " + btoa(asms.username + ':' + asms.password));
      }
      let requestOptions = {
        method: 'GET',
        headers: myHeaders,
        redirect: 'follow'
      };
      await fetch(asms.url, requestOptions).then(response => response.json()).then(result => {
        if (Object.prototype.hasOwnProperty.call(result, "applications")) {
          appListArray = result["applications"];
        } else {
          console.error("DACApi result does not have applications");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "DACApi result does not have applications", false, null);
        }
      }).catch(error => {
        console.log("DACApi fetch error from cloud", error);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
      });
    }
    return appListArray == null ? undefined : appListArray;
  };
  const getFirmwareVersion = async () => {
    let firmwareVerList = null,
      firmwareVer = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          if (Object.prototype.hasOwnProperty.call(cloud_data, "firmwareVersions")) {
            firmwareVerList = cloud_data['firmwareVersions'];
            let i = 0;
            while (i < firmwareVerList.length) {
              if ((await getPlatformNameForDAC()) === firmwareVerList[i].platform) {
                firmwareVer = firmwareVerList[i].ver;
                break;
              }
              i += 1;
            }
            if (firmwareVer === null) {
              console.error("Platform not supported");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "Platform not supported", false, null);
            }
          } else {
            console.error("Firmware version not available");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "Firmware version not available", false, null);
          }
        }
      } else {
        //code temporarily added based on new api implementation
        firmwareVer = await getFirmareVer();
      }
    } catch (error) {
      console.log("DACApi getFirmwareVersion Error: ", error);
      //code temporarily added based on new api implementation
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
      firmwareVer = await getFirmareVer();
    }
    return firmwareVer;
  };
  const fetchAppIcon = async (id, version) => {
    let appIcon = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          let url = cloud_data["url"] + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("fetchAppIcon fetch result: ", result);
            if (Object.prototype.hasOwnProperty.call(result, "header")) {
              appIcon = result.header.icon;
            } else {
              console.error("fetchAppIcon App does not have URL");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchAppIcon App does not have URL", false, null);
            }
          }).catch(error => {
            console.log("App Icon fetch error", error);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
          });
        }
      } else {
        //code temporarily added based on new api implementation
        let asms = await getAsmsUrlObj();
        let myHeaders = new Headers();
        if (asms.password !== null && asms.username !== null) {
          myHeaders.append("Authorization", "Basic " + btoa(asms.username + ':' + asms.password));
        }
        let requestOptions = {
          method: 'GET',
          headers: myHeaders,
          redirect: 'follow'
        };
        let url = asms.url + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
        await fetch(url, requestOptions).then(response => response.text()).then(result => {
          result = JSON.parse(result);
          if (Object.prototype.hasOwnProperty.call(result, "header")) {
            appIcon = result.header.icon;
          } else {
            console.error("fetchAppIcon App does not have URL");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchAppIcon App does not have URL", false, null);
          }
        }).catch(error => {
          console.log("fetchAppIcon App Icon fetch error", error);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
        });
      }
    } catch (error) {
      console.log("DACApi fetchAppIcon try block Error: ", error);
      //code temporarily added based on new api implementation
      let asms = await getAsmsUrlObj();
      let myHeaders = new Headers();
      if (asms.password !== null && asms.username !== null) {
        myHeaders.append("Authorization", "Basic " + btoa(asms.username + ':' + asms.password));
      }
      let requestOptions = {
        method: 'GET',
        headers: myHeaders,
        redirect: 'follow'
      };
      let url = asms.url + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
      await fetch(url, requestOptions).then(response => response.json()).then(result => {
        if (Object.prototype.hasOwnProperty.call(result, "header")) {
          appIcon = result.header.icon;
        } else {
          console.error("fetchAppIcon App does not have URL");
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchAppIcon App does not have URL", false, null);
        }
      }).catch(error => {
        console.log("fetchAppIcon App Icon fetch error", error);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
      });
    }
    return appIcon == null ? undefined : appIcon;
  };
  const fetchLocalAppIcon = async id => {
    let appIcon = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-path")) {
          let url = data["app-catalog-path"];
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            if (Object.prototype.hasOwnProperty.call(result, "applications")) {
              let appListArray = result["applications"];
              for (let i = 0; i < appListArray.length; i++) {
                if (appListArray[i].id === id) {
                  appIcon = appListArray[i]["icon"];
                  break;
                }
              }
            } else {
              console.error("fetchLocalAppIcon DACApi result does not have applications");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchLocalAppIcon DACApi result does not have applications", false, null);
              Storage$1.set("CloudAppStore", true);
            }
          }).catch(error => {
            console.log("fetchLocalAppIcon App Icon fetch error", error);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
          });
        }
      } else {
        console.error("fetchLocalAppIcon Appstore info not available; DAC features won't work.");
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "etchLocalAppIcon Appstore info not available; DAC features won't work", false, null);
      }
    } catch (error) {
      console.log("fetchLocalAppIcon Appstore info Error: ", error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
    }
    return appIcon == null ? undefined : appIcon;
  };
  const fetchAppUrl = async (id, version) => {
    let appUrl = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && Object.prototype.hasOwnProperty.call(data, "app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          let url = cloud_data["url"] + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("fetchAppUrl App fetch result: ", result);
            if (Object.prototype.hasOwnProperty.call(result, "header")) {
              appUrl = result.header.url;
            } else {
              console.error("fetchAppUrl App does not have URL");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchAppUrl App does not have URL", false, null);
            }
          }).catch(error => {
            console.log("fetchAppUrl App URL fetch error", error);
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
          });
        }
      } else {
        //code temporarily added based on new api implementation
        let asms = await getAsmsUrlObj();
        let myHeaders = new Headers();
        if (asms.password !== null && asms.username !== null) {
          myHeaders.append("Authorization", "Basic " + btoa(asms.username + ":" + asms.password));
        }
        let requestOptions = {
          method: 'GET',
          headers: myHeaders,
          redirect: 'follow'
        };
        let platformName = await getPlatformNameForDAC();
        let firmwareVer = await getFirmwareVersion();
        let url = asms.url + "/" + id + ":" + version + "?platformName=" + platformName + "&firmwareVer=" + firmwareVer;
        await fetch(url, requestOptions).then(response => response.json()).then(result => {
          if (Object.prototype.hasOwnProperty.call(result, "header")) {
            appUrl = result.header.url;
          } else {
            console.error("fetchAppUrl App does not have URL");
            Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "fetchAppUrl App does not have URL", false, null);
          }
        }).catch(error => {
          console.log("fetchAppUrl App URL fetch error", error);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
        });
      }
    } catch (error) {
      console.log("fetchAppUrl DACApi Appstore info Error: ", error);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", error, false, null);
    }
    return appUrl == null ? undefined : appUrl;
  };

  //New api implementation

  const getMetadata = async () => {
    const result = await LISA.get().getMetadata();
    return result;
  };
  const getAsmsUrlObj = async () => {
    try {
      let metadata = await getMetadata();
      let response = await fetch(metadata.configUrl);
      let result = await response.json();
      if (Object.prototype.hasOwnProperty.call(result, "appstore-catalog")) {
        const appstoreCatalog = result['appstore-catalog'];
        const asmsUrl = appstoreCatalog.url + "/apps" || null;
        const authentication = appstoreCatalog.authentication || {};
        const username = authentication.user || null;
        const password = authentication.password || null;
        return {
          url: asmsUrl,
          username: username,
          password: password
        };
      } else {
        console.error("getAsmsUrlObj: Don't have ASMS URL");
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", "getAsmsUrlObj: Don't have ASMS URL", false, null);
        throw new Error('getAsmsUrlObj: Failed to parse data');
      }
    } catch (err) {
      console.error("getAsmsUrlObj FETCH error: ", err);
      Metrics$3.error(Metrics$3.ErrorType.OTHER, "DACApiError", err, false, null);
      throw new Error('getAsmsUrlObj: Failed to parse data: ' + err);
    }
  };
  const getFirmareVer = async () => {
    const firmwareVer = await getMetadata().then(metadata => {
      let key = metadata.dacBundleFirmwareCompatibilityKey;
      return key;
    });
    return firmwareVer;
  };
  const getPlatform = async () => {
    const platformName = await getMetadata().then(metadata => {
      let platName = metadata.dacBundlePlatformNameOverride;
      return platName;
    });
    return platformName;
  };

  class AppStoreItem extends lng$1.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xAA000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate('Installing'),
              fontFace: CONFIG.language.font,
              fontSize: 20
            },
            ProgressBar: {
              y: 30,
              x: -50,
              type: ProgressBar,
              w: 200,
              progress: 1,
              barColor: 4284637804,
              progressColor: 4127195135,
              animationDuration: 5
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!Object.prototype.hasOwnProperty.call(data, 'icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.installed[0].appName;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
      if (Storage$1.get("CloudAppStore")) {
        let icon = await fetchAppIcon(this.data.id, this.data.installed[0].version);
        this.tag('Image').patch({
          src: icon
        });
      } else {
        let icon = await fetchLocalAppIcon(this.data.id);
        if (icon !== undefined) {
          this.tag('Image').patch({
            src: Utils.asset(icon)
          });
        }
      }
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    async _handleEnter() {
      this._app.url = this.data.installed[0].url;
      this._app.id = this.data.id;
      this._app.name = this.data.installed[0].appName;
      this._app.version = this.data.installed[0].version;
      this._app.type = this.data.type;
      this._app.isRunning = await startDACApp(this._app);
    }
  }

  class OptionsItem extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          Text: {
            text: {
              text: '',
              fontFace: CONFIG.language.font,
              fontSize: 35,
              wordWrap: false,
              wordWrapWidth: 230,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          Bar: {
            y: 50,
            texture: lng$1.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex)
          }
        }
      };
    }
    _focus() {
      this.tag('Bar').texture = lng$1.Tools.getRoundRect(this.tag('Text').finalW, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = 'bold';
    }
    _unfocus() {
      this.tag('Bar').texture = lng$1.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = '';
    }
    static get width() {
      return 250;
    }
    _handleEnter() {
      this.fireAncestors('$selectOption', this.idx, this);
      this._focus();
    }
    _handleDown() {
      this._handleEnter();
    }
    set element(item) {
      this.tag('Text').text.text = Language$1.translate(item);
      if (this.tag('Text').text.text.length > 11) {
        this.tag('Text').text.fontSize = 25;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Progress extends lng.Component {
    static _template() {
      let RR = lng.shaders.RoundedRectangle;
      return {
        BackgroundOverlay: {
          rect: true,
          color: 0xFF000000,
          alpha: 0,
          w: 300,
          h: 168,
          x: -50,
          y: -80
        },
        Label: {
          x: 10,
          y: -28,
          text: {
            fontSize: 18,
            textColor: 0xFFFFFFFF
          }
        },
        ProgressBar: {
          Background: {
            x: -2,
            y: 0,
            w: 4,
            h: 12,
            rtt: true,
            rect: true,
            color: 0xFF666666,
            shader: {
              radius: 3,
              type: RR
            }
          },
          Progress: {
            x: 0,
            y: 0,
            w: 0,
            h: 10,
            rtt: true,
            rect: true,
            color: CONFIG.theme.hex,
            shader: {
              radius: 3,
              type: RR
            }
          }
        }
      };
    }
    getProgress() {
      return this.value;
    }
    reset() {
      this.value = 0;
      this.tag("Progress").w = 0;
      this.tag("ProgressBar").alpha = 0.0;
      this.tag("Label").text.text = "";
      this.tag("Label").alpha = 1.0;
    }
    setProgress(pc, state) {
      this.percent = pc * 100;
      this.value = pc;
      var ww = (this.w - 4) * pc;
      if (pc != 1.0) {
        this.tag("BackgroundOverlay").alpha = 0.6;
        this.tag("ProgressBar").setSmooth('alpha', 0.7, {
          duration: .1
        });
        this.tag("Progress").setSmooth('w', ww, {
          duration: 1
        });
      }
      if (state !== "") {
        this.tag("Label").text.text = state + " " + Math.floor(this.percent) + "%";
      }
      if (pc == 1.0) {
        this.tag("ProgressBar").setSmooth('alpha', 0, {
          duration: 2.3
        });
        this.tag("Label").setSmooth('alpha', 0, {
          duration: 2.3
        });
        this.tag("BackgroundOverlay").setSmooth('alpha', 0, {
          duration: 1.5
        });
      }
    }
    _init() {
      this.tag("Background").w = this.w;
      this.reset();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AppCatalogItem extends lng$1.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xFF000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate('Already installed') + "!",
              fontFace: CONFIG.language.font,
              fontSize: 20
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        StatusProgress: {
          type: Progress,
          x: 50,
          y: 80,
          w: 200
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!Object.prototype.hasOwnProperty.call(data, 'icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.name;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async $fireDACOperationFinished(success, msg) {
      if (this._app.isInstalling) {
        this._app.isInstalled = success;
        this._app.isInstalling = false;
        if (Object.prototype.hasOwnProperty.call(this._app, "handle")) delete this._app.handle;
        if (Object.prototype.hasOwnProperty.call(this._app, "errorCode")) delete this._app.errorCode;
        this.updateStatus();
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      } else if (this._app.isUnInstalling) {
        this._app.isInstalled = !success;
        this._app.isUnInstalling = false;
        this.updateStatus();
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      }
    }
    updateStatus() {
      if (this._app.isRunning) {
        this.tag('StatusProgress').setProgress(1.0, Language$1.translate('Running') + "!");
      } else {
        if (this._app.isInstalled) {
          console.log("App is installed");
          this.tag('StatusProgress').setProgress(1.0, Language$1.translate('Installed') + '!');
        } else {
          this.tag('StatusProgress').reset();
        }
      }
      if (Object.prototype.hasOwnProperty.call(this._app, "errorCode")) {
        this.tag('Overlay.OverlayText').text.text = Language$1.translate('Error') + ':' + this._app.errorCode;
        this.tag("OverlayText").text.text = this._app.code;
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
      }
    }
    async myfireINSTALL() {
      if (Object.prototype.hasOwnProperty.call(this._app, "handle") && this._app.handle.length || Object.prototype.hasOwnProperty.call(this._app, "errorCode") && this._app.errorCode) {
        let result = null;
        if (this._app.handle) {
          result = await LISA.get().getProgress(this._app.handle);
          this.tag("OverlayText").text.text = Language$1.translate("Please wait");
          this.tag("Overlay").alpha = 0.7;
          this.tag("OverlayText").alpha = 1;
          this.tag("Overlay").setSmooth('alpha', 0, {
            duration: 5
          });
        }
        if (result && result.code || this._app.errorCode) {
          this.tag("OverlayText").text.text = Language$1.translate("Status") + ':' + (result && result.code ? result.code : this._app.errorCode);
          this.tag("Overlay").alpha = 0.7;
          this.tag("OverlayText").alpha = 1;
          this.tag("Overlay").setSmooth('alpha', 0, {
            duration: 5
          });
        }
        return;
      }
      if (this._app.isInstalled) {
        console.log("App is already installed");
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
        this.tag("OverlayText").text.text = Language$1.translate('Already installed') + "!";
        this.tag("Overlay").setSmooth('alpha', 0, {
          duration: 5
        });
        return;
      }
      this._app.isInstalling = await installDACApp(this._app, this.tag('StatusProgress'));
      this.updateStatus();
    }
    _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    async _handleEnter() {
      this._app.id = this.data.id;
      this._app.name = this.data.name;
      this._app.version = this.data.version;
      this._app.type = this.data.type;
      if (Storage$1.get("CloudAppStore")) {
        this._app.description = this.data.description;
        this._app.size = this.data.size;
        this._app.category = this.data.category;
        this._app.url = await fetchAppUrl(this._app.id, this._app.version);
        console.log("fetchAppUrl:", this._app.url);
      } else {
        this._app.url = this.data.uri;
      }
      let installedApps = await getInstalledDACApps();
      this._app.isInstalled = installedApps.find(a => {
        return a.id === this._app.id;
      });
      if (this._app.isInstalled === undefined) this._app.isInstalled = false;
      if (this._app.url !== undefined) {
        this.myfireINSTALL();
      } else console.error("App url undefined");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ManageAppItem extends lng$1.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xFF000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate("Uninstalling App") + "..",
              fontFace: CONFIG.language.font,
              fontSize: 30
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        StatusProgress: {
          type: Progress,
          x: 50,
          y: 80,
          w: 200
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!Object.prototype.hasOwnProperty.call(data, 'icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.installed[0].appName;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async $fireDACOperationFinished(success, msg) {
      if (this._app.isUnInstalling) {
        this._app.isInstalled = !success;
        this._app.isUnInstalling = false;
        await this.displayLabel().then(() => {
          setTimeout(() => {
            this.fireAncestors('$refreshManagedApps');
          }, 500);
        });
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      }
    }
    displayLabel() {
      return new Promise(resolve => {
        this.tag("OverlayText").text.text = Language$1.translate("App Uninstalled");
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
        this.tag("Overlay").setSmooth('alpha', 0, {
          duration: 5
        });
        resolve();
      });
    }
    async myfireUNINSTALL() {
      this._app.isUnInstalling = await uninstallDACApp(this._app, this.tag('StatusProgress'));
      if (!this._app.isUnInstalling && "errorCode" in this._app) {
        this.tag("OverlayText").text.text = Language$1.translate("Status") + ':' + this._app.errorCode;
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
        this.tag("Overlay").setSmooth('alpha', 0, {
          duration: 5
        });
      }
    }
    async _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
      if (Storage$1.get("CloudAppStore")) {
        let icon = await fetchAppIcon(this.data.id, this.data.installed[0].version);
        this.tag('Image').patch({
          src: icon
        });
      } else {
        let icon = await fetchLocalAppIcon(this.data.id);
        if (icon !== undefined) {
          this.tag('Image').patch({
            src: Utils.asset(icon)
          });
        }
      }
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    _handleEnter() {
      this._app.url = this.data.installed[0].url;
      this._app.id = this.data.id;
      this._app.name = this.data.installed[0].appName;
      this._app.version = this.data.installed[0].version;
      this._app.type = this.data.type;
      this.myfireUNINSTALL();
    }
  }

  class AppStore extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Apps'));
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Container: {
          x: 200,
          y: 270,
          Options: {
            // x: 10,
            type: List,
            direction: 'row',
            spacing: 30
          },
          Apps: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: AppStoreItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          Catalog: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: AppCatalogItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          ManagedApps: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: ManageAppItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          }
        }
      };
    }
    async _firstEnable() {
      const Catalog = await getAppCatalogInfo();
      const options = ['My Apps', 'App Catalog', 'Manage Apps'];
      this.tag('Options').add(options.map((element, idx) => {
        return {
          type: OptionsItem,
          element: element,
          w: OptionsItem.width,
          idx
        };
      }));
      this.options = {
        0: async () => {
          const installedApplications = await getInstalledDACApps();
          this.tag('Apps').add(installedApplications.map(element => {
            return {
              h: AppStoreItem.height + 90,
              w: AppStoreItem.width,
              info: element
            };
          }));
        },
        1: async () => {
          this.tag('Catalog').add(Catalog.map(element => {
            return {
              h: AppCatalogItem.height + 90,
              w: AppCatalogItem.width,
              info: element
            };
          }));
        },
        2: async () => {
          const installedApplications = await getInstalledDACApps();
          this.tag('ManagedApps').add(installedApplications.map(element => {
            return {
              h: ManageAppItem.height + 90,
              w: ManageAppItem.width,
              info: element
            };
          }));
        }
      };
      const installedApps = await getInstalledDACApps();
      if (Object.keys(installedApps).length === 0) {
        this.tag('Options').setIndex(1);
        this.options[1]();
        this._setState('Catalog');
      } else {
        this.options[0]();
        this._setState('Apps');
      }
    }
    $selectOption(option, obj) {
      this.tag('Apps').clear();
      this.tag('Catalog').clear();
      this.tag('ManagedApps').clear();
      obj._focus();
      this.options[option]();
      switch (option) {
        case 0:
          this._setState('Apps');
          break;
        case 1:
          this._setState('Catalog');
          break;
        case 2:
          this._setState('ManagedApps');
          break;
      }
    }
    $refreshManagedApps() {
      this.tag('ManagedApps').clear();
      this.options[2]();
      this._setState('ManagedApps');
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    _handleBack() {
      Router.focusWidget('Menu');
    }
    pageTransition() {
      return 'up';
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    _focus() {
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('Options');
        }
        _handleDown() {
          this._setState('Apps');
        }
      }, class Apps extends this {
        _getFocused() {
          return this.tag('Apps');
        }
        _handleUp() {
          this._setState('Options');
        }
      }, class Catalog extends this {
        _getFocused() {
          return this.tag('Catalog');
        }
        _handleUp() {
          this._setState('Options');
        }
      }, class ManagedApps extends this {
        _getFocused() {
          return this.tag('ManagedApps');
        }
        _handleUp() {
          this._setState('Options');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items in Subscription in details screen .
   */
  let index$1 = 0;
  class SubscriptionItem extends lng$1.Component {
    static _template() {
      return {
        SubscriptionItem: {
          Title: {
            y: 40,
            mountY: 0.5,
            text: {
              text: "YouTube",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              // maxLines: 1,
              wordWrap: false,
              wordWrapWidth: 175,
              fontStyle: 'normal',
              textOverflow: 'ellipsis'
            }
          },
          SubscriptionBox: {
            x: 183,
            y: 0,
            Lines: {
              TopLine: {
                y: 0,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              },
              BottomLine: {
                y: 77,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              }
            },
            Arrows: {
              ArrowBackward: {
                h: 30,
                w: 45,
                x: 0,
                scaleX: -1,
                y: 38,
                mountY: 0.5,
                src: Utils.asset('images/settings/Arrow.png')
              },
              ArrowForward: {
                h: 30,
                w: 45,
                y: 38,
                x: 484,
                mountY: 0.5,
                mountX: 1,
                src: Utils.asset('images/settings/Arrow.png')
              }
            }
          },
          SubscriptionValues: {
            x: 433,
            y: 40,
            mount: 0.5,
            zIndex: 2,
            text: {
              text: 'Youtube',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 400,
              maxLines: 1,
              textOverflow: 'ellipsis',
              textAlign: 'center'
            }
          }
        }
      };
    }
    set item(item) {
      this._item = item;
      this.tag('Title').text.text = this._item.host["_@attribute"];
      if (Array.isArray(this._item.viewingOptions.viewingOption)) {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[0]);
        this.tag('Arrows').visible = true;
      } else if (this._item.viewingOptions.viewingOption !== null && typeof this._item.viewingOptions.viewingOption === 'object') {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption);
        this._item.viewingOptions.viewingOption = [this._item.viewingOptions.viewingOption];
        this.tag('Arrows').visible = false;
      }
      // this.tag('SubscriptionValues').text.text=`${this._item.viewingOptions.viewingOption[0].price["_@attribute"]}-${this._item.viewingOptions.viewingOption[0].license}-${this._item.viewingOptions.viewingOption[0].quality}`;
    }
    convertPricing(option) {
      let res = '';
      if (option.license !== undefined) {
        let license = option.license.toLowerCase();
        res = res + license.substr(0, 1).toUpperCase() + license.substr(1) + " ";
      }
      if (option.price !== undefined) {
        res = res + "$" + option.price["_@attribute"] + " ";
      }
      if (option.quality !== undefined) {
        res = res + option.quality;
      }
      return res;
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("TopLine").h = 5;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").h = 5;
      this.tag("TopLine").zIndex = 10;
      this.tag("BottomLine").zIndex = 10;
      this.tag('Title').text.fontStyle = 'bold';
      this.tag('SubscriptionValues').text.fontStyle = 'bold';
      // console.log(this._item)
    }
    _handleLeft() {
      // index = (3 + (--index)) % 3;
      index$1 = index$1 - 1;
      if (index$1 < 0) {
        index$1 = this._item.viewingOptions.viewingOption.length - 1;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _handleEnter() {
      // this.handleDone()
      if (this._item.host["_@attribute"].toLowerCase() === "youtube") {
        let appApi = new AppApi();
        console.log(this._item.url);
        let params = {
          url: this._item.url,
          launchLocation: "gracenote",
          appIdentifier: 'n:3'
        };
        appApi.launchApp("YouTube", params).catch(err => {
          console.log("Error in launching YouTube", JSON.stringify(err));
        });
      }
    }
    _handleRight() {
      // index = (3 + (++index)) % 3;
      index$1 = index$1 + 1;
      if (index$1 > this._item.viewingOptions.viewingOption.length - 1) {
        index$1 = 0;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _unfocus() {
      this.tag("TopLine").color = 0xFFFFFFFF;
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").color = 0xFFFFFFFF;
      this.tag("BottomLine").h = 3;
      this.tag("TopLine").zIndex = 0;
      this.tag("BottomLine").zIndex = 0;
      this.tag('Title').text.fontStyle = 'normal';
      this.tag('SubscriptionValues').text.fontStyle = 'normal';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var homeApi$1 = new HomeApi();
  class DetailsScreen extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(this.name);
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Details: {
          x: 200,
          y: 270,
          Image: {
            x: 0,
            y: 0,
            h: 493,
            w: 878
          },
          Cast: {
            Title: {
              x: 10,
              y: 520,
              text: {
                text: "",
                fontStyle: "bold",
                fontSize: 22
              }
            }
          },
          Description: {
            Title: {
              x: 10,
              y: 550,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 22,
                wordWrapWidth: 900,
                wordWrap: true
              }
            }
          },
          Subscriptions: {
            x: 950,
            y: 50,
            w: 670,
            h: 395,
            visible: false,
            clipping: true,
            List: {
              type: lng$1.components.ListComponent,
              w: 670,
              h: 390,
              y: 5,
              itemSize: 77,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          },
          Time: {
            y: 520,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Rating: {
            y: 550,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25,
                wordWrap: true,
                wordWrapWidth: 500
              }
            }
          },
          GracenoteLogo: {
            x: 925,
            y: 510,
            w: 300,
            h: 168,
            src: Utils.asset("images/powered_by_gracenote.png")
          }
        }
      };
    }
    set params(args) {
      this.rootId = args.gracenoteItem.program.tmsid;
      this.name = args.gracenoteItem.program.title;
      let imgUrl = "http://developer.tmsimg.com/" + args.gracenoteItem.program.preferredImage.uri.replace("w=1280&", "w=878&").replace("&h=720", "&h=493") + "&api_key=" + args.key;
      this.tag("Image").src = Utils.proxyUrl(imgUrl);
      this.tag("Cast.Title").text.text = "".concat(args.gracenoteItem.program.topCast[0], " \t ").concat(args.gracenoteItem.program.topCast[1], " \t ").concat(args.gracenoteItem.program.topCast[2]);
      this.tag("Description.Title").text.text = args.gracenoteItem.program.longDescription;
      this.tag("Time.Title").text.text = "".concat(args.gracenoteItem.duration, " Minutes");
      if (args.gracenoteItem.ratings) {
        this.tag("Rating.Title").text.text = "".concat(args.gracenoteItem.ratings[0].body, " \n").concat(args.gracenoteItem.ratings[0].subRating);
      } else {
        this.tag("Rating.Title").text.text = "";
      }
      homeApi$1.getMovieSubscriptions(args.gracenoteItem.program.tmsId).then(response => {
        let options = response.ovd.movie.videos.video;
        if (options) {
          this.tag("Subscriptions.List").items = options.map((item, index) => {
            return {
              w: 670,
              h: 77,
              type: SubscriptionItem,
              item: item
            };
          });
          this.tag("Subscriptions").visible = true;
        } else {
          this.tag("Subscriptions").visible = false;
        }
        this._setState("Subscriptions");
        this.tag("Subscriptions.List").setIndex(0);
      }).catch(error => console.log(error));
    }
    _init() {}
    _focus() {
      this._setState("DetailsScreen");
      this.tag("Subscriptions.List").setIndex(0);
    }
    _unfocus() {
      this.tag("Subscriptions").visible = false;
    }
    _handleBack() {
      Router.navigate("menu");
    }
    static _states() {
      return [class DetailsScreen extends this {
        _handleDown() {
          this._setState("Subscriptions");
        }
        _handleUp() {
          this._setState("Subscriptions");
        }
        _handleLeft() {
          this._setState("Subscriptions");
        }
        _handleRight() {
          this._setState("Subscriptions");
        }
        _handleEnter() {
          this._setState("Subscriptions");
        }
      }, class Subscriptions extends this {
        _getFocused() {
          return this.tag("Subscriptions.List").element;
        }
        _handleDown() {
          this.tag("Subscriptions.List").setNext();
        }
        _handleUp() {
          this.tag("Subscriptions.List").setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var detailsScreenRoutes = {
    detailsScreenRoutes: [{
      path: 'menu/details',
      component: DetailsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items with tick Icon.
   */
  class TickMarkItem extends lng$1.Component {
    /**
     * Function to render Tick mark Icon elements in the settings.
     */

    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
    }
    _init() {
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
    }
    _handleEnter() {
      this.onHandleEnter(this.uniqID); //expecting a function that gets executed on handleEnter
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Satellite extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSatellite", selected);
      this.tag("List").items = this.fireAncestors("$getSatelliteList").map((item, index) => {
        return {
          ref: "Satellite" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected.name === item.name,
          //boolean
          itemName: item.name,
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSatellite"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Polarity extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setPolarity", selected);
      this.tag("List").items = this.fireAncestors("$getPolarityList").map((item, index) => {
        return {
          ref: "Polarity" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: Language.translate(item.charAt(0).toUpperCase() + item.slice(1)),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedPolarity"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FEC extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setFEC", selected);
      this.tag("List").items = this.fireAncestors("$getFECList").map((item, index) => {
        return {
          ref: "FEC" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.replace("fec", "").replace("_", "/").toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedFEC"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Modulation extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setModulation", selected);
      this.tag("List").items = this.fireAncestors("$getModulationList").map((item, index) => {
        return {
          ref: "Modulation" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedModulation"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SearchType extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: lng$1.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSearchType", selected);
      this.tag("List").items = this.fireAncestors("$getSearchTypeList").map((item, index) => {
        return {
          ref: "SearchType" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.charAt(0).toUpperCase() + item.slice(1),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSearchType"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  const keyMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    "q": 81,
    "w": 87,
    "e": 69,
    "r": 82,
    "t": 84,
    "y": 89,
    "u": 85,
    "i": 73,
    "o": 79,
    "p": 80,
    "a": 65,
    "s": 83,
    "d": 68,
    "f": 70,
    "g": 71,
    "h": 72,
    "j": 74,
    "k": 75,
    "l": 76,
    "z": 90,
    "x": 88,
    "c": 67,
    "v": 86,
    "b": 66,
    "n": 78,
    "m": 77,
    "Q": 81,
    "W": 87,
    "E": 69,
    "R": 82,
    "T": 84,
    "Y": 89,
    "U": 85,
    "I": 73,
    "O": 79,
    "P": 80,
    "A": 65,
    "S": 83,
    "D": 68,
    "F": 70,
    "G": 71,
    "H": 72,
    "J": 74,
    "K": 75,
    "L": 76,
    "Z": 90,
    "X": 88,
    "C": 67,
    "V": 86,
    "B": 66,
    "N": 78,
    "M": 77,
    "Backspace": 8,
    "Enter": 13,
    "Space": 32,
    "PageUp": 33,
    "PageDown": 34,
    "Home": 36,
    "ArrowLeft": 37,
    "ArrowUp": 38,
    "ArrowRight": 39,
    "ArrowDown": 40,
    "AudioVolumeDown": 174,
    "AudioVolumeUp": 175,
    "AudioVolumeMute": 173,
    "MediaStop": 178,
    "MediaTrackPrevious": 177,
    "MediaPlay": 179,
    "MediaTrackNext": 176,
    "Escape": 27,
    "Pause": 179,
    "MediaRewind": 227,
    "MediaFastForward": 228,
    "F1": 112,
    "Inputs_Shortcut": 113,
    //F2
    "Picture_Setting_Shortcut": 114,
    //F3
    "Youtube": 115,
    //F4
    "Power": 116,
    // F5
    "Amazon": 117,
    //F6
    "Netflix": 118,
    //F7, F8 Voice RCU Key
    "Settings_Shortcut": 121,
    // F10
    "Guide_Shortcut": 120,
    // F9
    "AppCarousel": 122,
    // F11
    "F12": 123
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class IntegerInput extends lng$1.Component {
    static _template() {
      return {
        x: 200,
        y: 275,
        InputBox: {
          Border: {
            texture: lng$1.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false)
          },
          Arrows: {
            y: 50,
            visible: false,
            RightArrow: {
              h: 50,
              w: 50,
              x: 1600,
              mountX: 1,
              mountY: 0.5,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            },
            LeftArrow: {
              h: 50,
              w: 50,
              x: 0,
              mountX: 0,
              mountY: 0.5,
              scaleX: -1,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            }
          },
          Content: {
            x: 50,
            y: 50,
            mountY: 0.5,
            text: {
              text: Language$1.translate("Enter the value and click Done"),
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 1500,
              textOverflow: "ellipsis"
            }
          }
        },
        Keyboard: {
          x: 660,
          y: 200,
          type: Keyboard,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.numbers
        }
      };
    }
    _init() {
      this.numKeyCodes = [keyMap["0"], keyMap["1"], keyMap["2"], keyMap["3"], keyMap["4"], keyMap["5"], keyMap["6"], keyMap["7"], keyMap["8"], keyMap["9"]];
      //console.log(this.numKeyCodes) // above array order is importent as index is used as numeric value
    }
    _focus() {
      this._setState("InputBox");
      this.tag("Content").text.text = this.prevVal === "" ? Language$1.translate("Enter the value and click Done") : this.prevVal;
      this.inputValue = this.prevVal;
      console.log("presetValues: ", this.presetValues);
      this.presetValuesLength = 0;
      this.presetIdx = -1; //to accomodate previous value of the input field
      if (Array.isArray(this.presetValues)) {
        this.presetValuesLength = this.presetValues.length;
        console.log(this.presetValues, this.presetValuesLength);
        this.tag("Arrows").visible = true;
      } else {
        this.tag("Arrows").visible = false;
      }
    }
    handleDone() {
      // console.log(this.inputValue);
      this.onHandleDone(this.inputValue);
    }
    _handleKey(key) {
      let keyValue = this.numKeyCodes.indexOf(key.keyCode); //index is used as value for numeric keys
      if (keyValue >= 0) {
        this.inputValue += String(keyValue);
        this.tag("Content").text.text = this.inputValue;
      } else {
        return false; //to pass on other keys such as handleBack
      }
    }
    static _states() {
      return [class InputBox extends this {
        $enter() {
          this.tag("InputBox.Border").texture = lng$1.Tools.getRoundRect(1600, 90, 0, 3, CONFIG.theme.hex, false);
          this.tag("RightArrow").color = CONFIG.theme.hex;
          this.tag("LeftArrow").color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag("InputBox.Border").texture = lng$1.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false);
          this.tag("RightArrow").color = 0xffffffff;
          this.tag("LeftArrow").color = 0xffffffff;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleEnter() {
          this._setState("Keyboard");
        }
        _handleLeft() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx <= 0) {
              this.presetIdx = this.presetValuesLength - 1;
            } else {
              this.presetIdx -= 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleRight() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx === this.presetValuesLength - 1 || this.presetIdx < 0) {
              this.presetIdx = 0;
            } else {
              this.presetIdx += 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleUp() {
          // do nothing
        }
      }, class Keyboard extends this {
        _handleDown() {
          // do nothing
        }
        _handleUp() {
          this._setState("InputBox");
        }
        _getFocused() {
          return this.tag("Keyboard");
        }
        _handleBack() {
          this._setState("InputBox");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === "Done") {
            this.handleDone();
          } else if (key === "Clear") {
            this.inputValue = this.inputValue.substring(0, this.inputValue.length - 1);
          } else if (key === "Delete") {
            this.inputValue = "";
          } else {
            this.inputValue += key;
          }
          this.tag("Content").text.text = this.inputValue;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$3 = new DTVApi();
  const thunder$9 = thunderJS$1(CONFIG.thunderConfig);
  const systemcCallsign = "DTV";

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan$1 extends lng$1.Component {
    _onChanged() {
      this.tag("Scroller").y = 2; //to reset the position when this route is hit
      this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language$1.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language$1.translate("Please wait scan in progress"),
            0.3: Language$1.translate("Please wait scan in progress") + ".",
            0.6: Language$1.translate("Please wait scan in progress") + "..",
            0.9: Language$1.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }
    _firstActive() {
      thunder$9.on(systemcCallsign, "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
          dtvApi$3.noOfServices().then(res => {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Found ") + res + Language$1.translate(" services.");
            this.tag("ErrorNotification").visible = true;
          });
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$3.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$3.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$3.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$3.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$3.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$3.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      Router.navigate("settings/livetv/scan");
    }
    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }
    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }
    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }
    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }
    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }
    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language$1.translate("Select a") + " " + Language$1.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language$1.translate("Select a") + " " + Language$1.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language$1.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language$1.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language$1.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language$1.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language$1.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language$1.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language$1.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language$1.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language$1.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language$1.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language$1.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
        }
        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$3.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Satellite"));
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Satellite.Title").text.text = Language$1.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language$1.translate("Select a") + " " + Language$1.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });
          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Frequency"));
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Polarity"));
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Polarity.Title").text.text = Language$1.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });
          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Symbol Rate"));
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("FEC"));
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("FEC.Title").text.text = Language$1.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Modulation"));
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Modulation.Title").text.text = Language$1.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Search Mode"));
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$3.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
                dtvApi$3.noOfServices().then(res => {
                  this.tag("ErrorNotification.Content").text.text = Language$1.translate("Found ") + res + Language$1.translate(" services.");
                  this.tag("ErrorNotification").visible = true;
                });
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings / Live TV / Scan'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    _handleBack() {
      Router.navigate('settings/livetv');
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
        _handleEnter() {
          //Router.navigate()
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
        _handleEnter() {
          // Router.navigate()
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          Router.navigate('settings/livetv/scan/dvb-s-scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active$1 = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings$1 extends lng$1.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState(this.state);
      if (active$1) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    _handleBack() {
      Router.navigate("settings");
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (active$1) {
            this.dtvApi.deactivate().then(res => {
              console.log(res);
              active$1 = false;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
            });
          } else {
            this.dtvApi.activate().then(res => {
              console.log(res);
              active$1 = true;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
            });
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          Router.navigate("settings/livetv/scan");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const liveTvRoutes = [{
    path: 'settings/livetv',
    component: LiveTVSettings$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/livetv/scan',
    component: LiveTVScan$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/livetv/scan/dvb-s-scan',
    component: DvbSScan$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for ControlSettings thunder plugin apis.
   */

  class PictureSettingsApi {
    constructor() {
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
      this._events = new Map();
      this.callsign = "org.rdk.tv.ControlSettings";
      this.settingsOptions = [{
        id: "_pictureMode",
        name: "Picture Mode",
        value: ["standard", "vivid", "energysaving", "custom", "theater", "game", "sports"]
      }, {
        id: "_colorTemp",
        name: "Color Temperature",
        value: ["Standard", "Warm", "Cold", "User Defined"]
      }, {
        id: "_backlight",
        name: "Backlight",
        value: "0"
      }, {
        id: "_brightness",
        name: "Brightness",
        value: "0"
      }, {
        id: "_contrast",
        name: "Contrast",
        value: "0"
      }, {
        id: "_sharpness",
        name: "Sharpness",
        value: "0"
      }, {
        id: "_saturation",
        name: "Saturation",
        value: "0"
      }];
      this.methodNames = {
        _pictureMode: {
          get: this.getPictureMode.bind(this),
          set: this.setPictureMode.bind(this)
        },
        _colorTemp: {
          get: this.getColorTemperature.bind(this),
          set: this.setColorTemperature.bind(this)
        },
        _backlight: {
          get: this.getBacklight.bind(this),
          set: this.setBacklight.bind(this)
        },
        _brightness: {
          get: this.getBrightness.bind(this),
          set: this.setBrightness.bind(this)
        },
        _contrast: {
          get: this.getContrast.bind(this),
          set: this.setContrast.bind(this)
        },
        _sharpness: {
          get: this.getSharpness.bind(this),
          set: this.setSharpness.bind(this)
        },
        _saturation: {
          get: this.getSaturation.bind(this),
          set: this.setSaturation.bind(this)
        }
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call("Controller", "activate", {
          callsign: this.callsign
        }).then(result => {
          console.log("Activated tv.ControlSettings plugin: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Failed to activate tv.ControlSettings plugin: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error while Thunder Controller TvControlSettings activate " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSettingsValue(settingsName) {
      console.log("getSettingsValue called for : ", settingsName);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].get().then(result => {
          console.log("Result from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getSettings " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setSettingsValue(settingsName, value) {
      console.log("setSettingsValue called for : ", settingsName, " and for value: ", value);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].set(value).then(result => {
          console.log("Result from setSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from setSettingsValue API for ".concat(settingsName, " and value : ").concat(value, " | Error: ").concat(JSON.stringify(err)));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setSettings " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getOptions() {
      console.log("getOptions called: ", JSON.stringify(this.settingsOptions));
      return this.settingsOptions;
    }
    getSupportedPictureModes() {
      console.log("getSupportedPictureModes got called");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getSupportedPictureModes").then(result => {
          console.log("getSupportedPictureModes Result: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[0].value = result.SupportedPicmodes;
            resolve(true);
          }
        }).catch(err => {
          console.log("getSupportedPictureModes Error: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getSupportedPictureModes " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSupportedColorTemps() {
      console.log("getSupportedColorTemps got called");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          console.log("Log from getSupportedColorTemps API: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[1].value = result.ColorTemperature.Options;
            resolve(true);
          }
        }).catch(err => {
          console.log("Error from getSupportedColorTemps API: ", JSON.stringify(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getColorTemperature " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getPictureMode() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getPictureMode").then(result => {
          resolve(result.pictureMode);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getPictureMode " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setPictureMode(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setPictureMode", {
          "pictureMode": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setPictureMode " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getColorTemperature() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          resolve(result.ColorTemperature.Selected);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getColorTemperature " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setColorTemperature(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setColorTemperature", {
          "colorTemp": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setColorTemperature " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getBrightness() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getBrightness").then(result => {
          resolve(result.Brightness.Setting);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getBrightness " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setBrightness(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setBrightness", {
          "brightness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setBrightness " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getContrast() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getContrast").then(result => {
          resolve(result.Contrast.Setting);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getContrast " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setContrast(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setContrast", {
          "contrast": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setContrast " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSharpness() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getSharpness").then(result => {
          resolve(result.Sharpness.Setting);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getSharpness " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setSharpness(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setSharpness", {
          "sharpness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setSharpness " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getSaturation() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getSaturation").then(result => {
          resolve(result.Saturation.Setting);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getSaturation " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setSaturation(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setSaturation", {
          "saturation": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setSaturation " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    getBacklight() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "getBacklight").then(result => {
          resolve(result.Backlight.Setting);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings getBacklight " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
    setBacklight(value) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, "setBacklight", {
          "backlight": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PictureSettingsApiError", "Error in Thunder TvControlSettings setBacklight " + JSON.stringify(err), false, null);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsItem extends lng$1.Component {
    _construct() {
      this.pictureApi = new PictureSettingsApi();
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 500,
          h: 90,
          Title: {
            y: 45,
            x: 250,
            mount: 0.5,
            text: {
              text: "Setting: Sample Value",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 400,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          LeftArrow: {
            h: 45,
            w: 45,
            x: 0,
            scaleX: -1,
            y: 45,
            mountY: 0.5,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          },
          RightArrow: {
            h: 45,
            w: 45,
            y: 45,
            x: 500,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    _init() {}
    set item(item) {
      this._item = item;
      this.fetchAndUpdateValues();
    }
    fetchAndUpdateValues() {
      console.log("fetchAndUpdateValues got called!!!");
      if (Array.isArray(this._item.value)) {
        this.valueIdx = 0;
        this.valueLength = this._item.value.length;
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(array): ", JSON.stringify(res));
          let tIdx = this._item.value.indexOf(res);
          if (tIdx >= 0) {
            this.valueIdx = tIdx;
          }
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
        }).catch(err => {
          console.log("error from getSettingsValue(value is array) in set(item) in settings Item: ", JSON.stringify(err));
        });
      } else {
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(number): ", JSON.stringify(res));
          this._item.value = +res;
          this.currentVal = +res; //to change to int
          this.updateValue(this._item.value);
        }).catch(err => {
          console.log("error from getSettingsValue(value is number) in set(item) in settings Item: ", JSON.stringify(err));
        });
      }
    }
    updateValue(value) {
      this.tag("Title").text.text = "".concat(Language$1.translate(this._item.name), ": ").concat(value);
    }
    formatItemName(name) {
      return name.charAt(0).toUpperCase() + name.slice(1);
    }
    changeValueBy(val) {
      try {
        clearTimeout(this.changeValueTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (this.currentVal + val <= 100 && this.currentVal + val >= 0) {
        this.currentVal += val;
        this.updateValue(this.currentVal);
      }
      this.changeValueTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this.currentVal, " TO API: ").concat(this._item.id));
        ///////////////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this.currentVal).then(res => {
          console.log(JSON.stringify(res));
          this._item.value = this.currentVal;
          this.updateValue(this.currentVal);
        }).catch(err => {
          console.log(JSON.stringify(err));
          console.log("this._item: ", JSON.stringify(this._item));
        });
      }, 600);
    }
    changePresetValueBy(direction) {
      this.fireAncestors("$moveDownLock", true); //user switching values prevent moving down
      try {
        clearTimeout(this.changePresetTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (direction === "left") {
        this.valueIdx -= 1;
        if (this.valueIdx < 0) {
          this.valueIdx = this.valueLength - 1;
        }
      } else if (direction === "right") {
        this.valueIdx += 1;
        if (this.valueIdx >= this.valueLength) {
          this.valueIdx = 0;
        }
      }
      this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
      this.changePresetTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this._item.value[this.valueIdx], " TO API: ").concat(this._item.id));
        ///////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this._item.value[this.valueIdx]).then(res => {
          console.log(JSON.stringify(res));
          console.log(this._item.value[this.valueIdx]);
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
          this.fireAncestors("$moveDownLock", false); //api call success  user can move down
        }).catch(err => {
          console.log(JSON.stringify(err));
        });
      }, 600);
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("left");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          this.changeValueBy(-1);
        }
      }
    }
    _handleRight() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("right");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          //except for preset, this condition check can be omitted by considering the value is not an array in this case
          this.changeValueBy(1);
        }
      }
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
      this.fetchAndUpdateValues(); //fetches the value from the api and updates on ui
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsScreen extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          h: 1080,
          w: 500,
          Background: {
            h: 1080,
            w: 500,
            rect: true,
            colorLeft: 0xff000000,
            colorRight: 0x99000000
          },
          Settings: {
            w: 500,
            h: 910,
            clipping: true,
            y: 80,
            List: {
              type: lng$1.components.ListComponent,
              w: 500,
              h: 910,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -9
            }
          }
        }
      };
    }
    _firstEnable() {
      this.customLock = false; //by default its unlocked | will get locked when user switches any preset value
      this.pictureApi = new PictureSettingsApi();
      this.options = this.pictureApi.getOptions(); //#byDefault //not required //fetches the defaults dummy values //following api calls fetches the actual values from api here after
      this.pictureApi.getSupportedPictureModes().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedPictureModes: ", JSON.stringify(err));
      });
      //the getSupportedColorTemps api call has some issue when working on chrome browser
      this.pictureApi.getSupportedColorTemps().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedColorTemps: ", JSON.stringify(err));
      });
    }
    refreshList() {
      console.log("this.refreshList got called");
      this.tag("List").items = this.options.map(item => {
        return {
          w: 500,
          h: 90,
          type: TvOverlaySettingsItem,
          item: item
        };
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      console.log("index: ", this.tag("List").index);
      // this.tag("List").setIndex(0);//not necessary
    }
    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index < this.tag("List").length - 1) {
        //to prevent circular scrolling
        if (this.tag("List").index === 1) {
          //to check if user should be moving to third item
          if (!this.customLock) {
            //customLock value is true means api call is happening wait before moving down
            this.moveDownOnCustom();
          } else {
            console.log("changing the preset value cant moveDown now!!");
          }
        } else {
          this.tag("List").setNext();
        }
      }
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index > 0) {
        //to prevent circular scrolling
        this.tag("List").setPrevious();
      }
    }
    _handleLeft() {
      // do nothing
    }
    _handleRight() {
      // do nothing
    }
    async moveDownOnCustom() {
      try {
        const pictureMode = await this.pictureApi.getPictureMode();
        const colorTemp = await this.pictureApi.getColorTemperature();
        console.log("picture mode: ", pictureMode, " color temperature: ", colorTemp);
        if (pictureMode === "custom" && colorTemp === "User Defined") {
          this.tag("List").setNext();
        } else {
          this.tag("List").setIndex(1);
        }
      } catch {
        console.log("error occoured in api call");
      }
    }
    $moveDownLock(lock) {
      this.customLock = lock; //prevents user from moving down when a preset value change api call is happening
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputItem extends lng$1.Component {
    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1720,
          h: 90,
          Loader: {
            zIndex: 10,
            h: 45,
            w: 45,
            x: 1720,
            y: 45,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Loading.png"),
            color: 0xffffffff,
            visible: false
          },
          InputError: {
            x: 1500,
            y: 45,
            mountY: 0.5,
            text: {
              text: Language$1.translate("Input not available"),
              fontSize: 25,
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font
            },
            visible: false
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
      this.tag("Item.InputError").visible = false; //to remove the error text, when the list is refreshed.
    }
    _init() {
      console.log("_init from inputItem: list is getting rendered");
      this.hdmiApi = new HDMIApi();
      this.loadingAnimation = this.tag("Item.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: 0xffffffff,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
      this.tag("Item.Loader").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png";
        this.tag("Item.Loader").src = url;
      });
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
      if (!this.tag("Item.Tick").visible) {
        //to start the loader
        this.loadingAnimation.start();
        this.tag("Item.Loader").visible = true;
        this.tag("Item.InputError").visible = false;
        const minLoaderDuration = 1000; //1 sec min duration to show the loader before the tick mark appears in the ui
        /////////////////
        this.hdmiApi.getHDMIDevices() //api does not throw error, just consider error condition when result is empty
        .then(res => {
          console.log("getHDMIDevices from input Item: ", JSON.stringify(res));
          if (res.length > 0) {
            res.map(item => {
              if (item.id === this.uniqID.id) {
                if (item.connected === "true") {
                  //to check if the current item is connected
                  this.hdmiApi.setHDMIInput(item).then(() => {
                    console.log("input set to: ", JSON.stringify(item));
                    //to stop the loader and show tickmark
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                      Storage$1.set("_currentInputMode", {
                        id: item.id,
                        locator: item.locator
                      });
                      this.fireAncestors("$getInputs"); //getInputs will fetch the inputs from api,
                    }, minLoaderDuration);
                  }).catch(err => {
                    console.log("Failed to setHDMIInput", JSON.stringify(err));
                    //to stop the loader
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                    }, minLoaderDuration);
                    ///////////////////////
                    //display the error in the notification
                  });
                } else {
                  console.log("device not connected! item: ", JSON.stringify(item));
                  setTimeout(() => {
                    this.loadingAnimation.stop();
                    this.tag("Item.Loader").visible = false;
                    this.tag("Item.InputError").visible = true;
                  }, minLoaderDuration);
                }
              } else {
                console.log("ID not match! uniqID: ", JSON.stringify(this.uniqID), " item: ", JSON.stringify(item));
              }
            });
          } else {
            console.log("getHDMIDevices returned empty array"); //in case of error, getHDMIDevices api return empty array
            setTimeout(() => {
              this.loadingAnimation.stop();
              this.tag("Item.Loader").visible = false;
            }, minLoaderDuration);
          }
        }).catch(err => {
          console.log("Failed to getHDMIDevices", JSON.stringify(err));
          //to stop the loader
          setTimeout(() => {
            this.loadingAnimation.stop();
            this.tag("Item.Loader").visible = false;
          }, minLoaderDuration);
        });
      } else {
        console.log(Storage$1.get("_currentInputMode"));
      }
    }
    _focus() {
      //  this.tag("Item").color = COLORS.hightlightColor;
      this.refresh = false; //to check if the list needs a refresh // if connection status is false and user presses enter twice, hdmi input list gets refreshed
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputScreen extends lng$1.Component {
    static _template() {
      return {
        Contents: {
          h: 630,
          w: 1920,
          x: 960,
          mountX: 0.5,
          Background: {
            h: 630,
            w: 1920,
            rect: true,
            colorTop: 0xff000000,
            colorBottom: 0x99000000
          },
          Title: {
            y: 70,
            x: 100,
            text: {
              text: Language$1.translate("Video Input"),
              fontFace: CONFIG.language.font,
              textColor: CONFIG.theme.hex,
              fontSize: 40,
              wordWrap: false,
              wordWrapWidth: 370,
              fontStyle: "bold",
              textOverflow: "ellipsis"
            }
          },
          Inputs: {
            w: 1720,
            h: 370,
            clipping: true,
            y: 166,
            x: 960,
            mountX: 0.5,
            // rect: true, //
            // color: 0xffff0000, //
            List: {
              type: lng$1.components.ListComponent,
              w: 1720,
              h: 370,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -3
            }
          },
          BorderLine: {
            y: 630,
            mountY: 1,
            w: 1920,
            h: 3,
            rect: true,
            color: 0xffffffff
          }
        }
      };
    }
    refreshItems(selected) {
      console.log("refreshItems called: rendering the items");
      this.tag("List").items = this.inputItems.map((item, index) => {
        return {
          ref: "Inputs" + index,
          w: 1720,
          h: 90,
          type: TvOverlayInputItem,
          isTicked: selected.id === item.id && selected.locator === item.locator,
          itemName: this.options[index],
          //item.toUpperCase(), //pass the formated item name if required
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }
    _firstEnable() {
      this.options = ["HDMI1", "HDMI2", "HDMI3", "HDMI4"];
      this.inputItems = [{
        id: 0,
        locator: "hdmiin://localhost/deviceid/0",
        connected: true
      }, {
        id: 1,
        locator: "hdmiin://localhost/deviceid/1",
        connected: false
      }, {
        id: 2,
        locator: "hdmiin://localhost/deviceid/2",
        connected: true
      }];
      this.hdmiApi = new HDMIApi();
      this.$getInputs();
    }
    $getInputs() {
      console.log("fetching hdmi input options"); //call get inputs and refresh items after an event

      this.hdmiApi.getHDMIDevices().then(res => {
        this.inputItems = res;
        this.refreshItems(Storage$1.get("_currentInputMode"));
      }).catch(err => {
        console.log("inputScreen: getHDMIDevices Error: ", JSON.stringify(err));
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      this.$getInputs(); //fetch the input modes and refresh the list, in case input status changes
    }
    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setNext();
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setPrevious();
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }
    _handleRight() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  thunderJS$1(CONFIG.thunderConfig);
  class TvOverlayScreen extends lng$1.Component {
    set params(args) {
      this._type = args.type;
      console.log("setting to idlestate");
      setTimeout(() => {
        if (this._type === "inputs") {
          this._setState("OverlayInputScreen");
        } else if (this._type === "settings") {
          this._setState("OverlaySettingsScreen");
        }
      }, 300);
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        OverlaySettingsScreen: {
          x: -500,
          //set the x value to -500+ and add animation from left
          y: 0,
          type: TvOverlaySettingsScreen
        },
        OverlayInputScreen: {
          x: 0,
          y: -630,
          type: TvOverlayInputScreen
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.overlayTimeout = null;
      this.timeoutDuration = 30000;
      this._sidePanelAnimation = this.tag("OverlaySettingsScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -500,
            1: 0
          }
        }]
      });
      this._topPanelAnimation = this.tag("OverlayInputScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "y",
          v: {
            0: -630,
            1: 0
          }
        }]
      });
    }
    _focus() {}
    $focusOverlay() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $unfocusOverlay() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
    }
    $resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $closeOverlay() {
      this._handleBack();
    }
    _handleBack() {
      this._setState("IdleState");
      console.log("currentApp: ", GLOBALS.topmostApp);
      setTimeout(() => {
        if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
          rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
          rdkShellApisInstance.moveToFront(GLOBALS.topmostApp).then(() => {
            rdkShellApisInstance.setFocus(GLOBALS.topmostApp).catch(err => {
              console.log("Error", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'pluginError', "Thunder RDKShell setfocus error ".concat(JSON.stringify(err)), false, null);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            //don't navigate to menu if route is dtvplayer
            Router.focusPage();
          } else {
            console.log("else block navigating to menu");
            Router.navigate("menu"); //if user is currently on resident app, might not be needed as user should not be able to get on this screen while on resident app
          }
        }
      }, 500);
    }
    static _states() {
      return [class IdleState extends this {
        $enter() {
          console.log("entering overlay IdleState");
        }
        $exit() {
          console.log("exiting overlay IdleState");
        }
      }, class OverlaySettingsScreen extends this {
        $enter() {
          this._topPanelAnimation.finish();
          this._sidePanelAnimation.start();
          console.log("$enter from OverlaySettingsScreen");
        }
        $exit() {
          this._sidePanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlaySettingsScreen");
        }
      }, class OverlayInputScreen extends this {
        $enter() {
          this._sidePanelAnimation.finish();
          this._topPanelAnimation.start();
          console.log("$enter from OverlayInputScreen");
        }
        $exit() {
          this._topPanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlayInputScreen");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem extends lng$1.Component {
    static _template() {
      return {
        w: 236,
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: 'xxxxxx',
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...',
            wordWrapWidth: 232
          }
        },
        Item: {
          w: 236 - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(236, 81, 0, 1, 0xff000000, true, 0xff1d1c1c),
        }
      };
    }
    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set fontStyle(v) {
      this.tag('Title').text.fontStyle = v;
    }
    set title(val) {
      this.tag('Title').text = val;
    }
    get title() {
      return this.tag("Title").text;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Shows extends lng$1.Component {
    static _template() {
      return {
        y: 200
      }; /* this is just an empty component. used like a parent container for Cell containers */
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Cell extends lng$1.Component {
    static _template() {
      return {
        zIndex: 2
      };
    }
    set txt(ins) {
      /* the text on the Cell */
      this.patch({
        AiringOverlay: {
          zIndex: 4,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: ins ? ins : Language$1.translate("No Shows are being aired at the moment"),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...'
            }
          }
        }
      });
      this.insText = ins ? ins : Language$1.translate("No Shows are being aired at the moment");
    }
    get txt() {
      return this.insText;
    }
    set color(val) {
      let title = this.tag("Title");
      if (title) title.text.textColor = val;
    }
    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set width(w) {
      /* the horizontal width of the Cell */
      this.patch({
        Item: {
          // clipping: true,
          w: w - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(w, 81, 0, 1, 0xff000000, true, 0xff272727),
        }
      });
      this.tag('Title').text.wordWrapWidth = w - 20;
    }
    getwidth() {
      return this.width;
    }
    _init() {
      this.tag('AiringOverlay').w = this.tag('Item').w;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class CellCursor extends lng$1.Component {
    static _template() {
      return {
        zIndex: 5,
        UpperLine: {
          x: 0,
          y: 0,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        },
        LowerLine: {
          x: 0,
          y: 79,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        }
        // texture:Lightning.Tools.getRoundRect(236 ,81,0,1,0xffFFFFFF,true,0x0000ffff) // if you change this then you may wanna change the part where it patches itself too.
      };
    }
    patchCursor(x, y, w) {
      this.tag("UpperLine").patch({
        smooth: {
          x: x,
          y: y,
          w: w - 3
        }
      });
      this.tag("LowerLine").patch({
        smooth: {
          x: x,
          y: y + 79,
          w: w - 3
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let k = 5;
  const homeApi = new HomeApi();
  const dtvApi$2 = new DTVApi();
  class Epg extends lng$1.Component {
    static _template() {
      return {
        Background: {
          color: 0xff000000,
          w: 1920,
          h: 1080,
          rect: true
        },
        Loader: {
          x: 960,
          y: 540,
          mount: 0.5,
          w: 100,
          h: 100,
          src: Utils.asset("images/settings/Loading.png"),
          visible: true
        },
        Wrapper: {
          x: 200,
          y: 150,
          w: 1920,
          h: 1080,
          visible: false,
          DayLabel: {
            x: 0,
            y: 281,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('Today'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowName: {
            x: 0,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW'),
              fontFace: CONFIG.language.font,
              fontStyle: 'bold',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowTimings: {
            x: 236 * 5 + 59,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW-TIMINGS'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ChannelName: {
            x: 236 * 5 + 59,
            y: 225,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('CHANNEL-NAME'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          ShowDetails: {
            x: 0,
            y: 225,
            w: 236 * 5,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW-DETAILS'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          Channels: {
            x: 0,
            y: 81 + 200,
            w: 236
          },
          TopBar: {
            y: 200,
            x: 236,
            TimeNotifiers: {
              x: -4,
              w: 236 * 6 + 2,
              h: 81,
              clipping: true,
              TimeBar: {
                // this is the gray bar
                x: k,
                y: 81 - 12,
                // this should be the ShowLists "y" value - 9, extra -3 to accomodate margin
                rect: true,
                h: 9,
                w: 0,
                color: 0xff404040
              },
              DownTriangle: {
                // this is the little triangle over the white bar.
                x: 4,
                y: 81 - 12,
                // this should be the same as TimeBar's "y" Value, extra -3 to accomodate margin
                mountX: 0.5,
                mountY: 0.5,
                color: 0xffffffff,
                text: {
                  text: "".concat(String.fromCodePoint(9662)),
                  fontSize: 25,
                  textColor: 0xffffffff
                }
              }
            },
            TimeLabels: {
              clipping: true,
              zIndex: 2,
              w: 236 * 6,
              h: 81,
              x: k,
              y: 0
            },
            Wrapper: {
              w: 236 * 6,
              h: 81 * 9,
              clipping: true,
              Shows: {
                y: 81,
                // x: 236,
                type: Shows
              },
              CellCursor: {
                y: 81,
                type: CellCursor
              }
            }
          }
        }
      };
    }
    setChannels(channels) {
      let c = channels.map((c, i) => {
        return {
          y: 81 * i,
          w: 236,
          type: ChannelItem,
          title: c.shortname
        };
      });
      this.tag('Channels').children = c;
      this.channelGridInstance = this.tag('Channels').children;
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate("menu");
      }
    }
    getEventURI(events) {
      let showName = this.gridInstance[this.currentCellIndex].txt;
      let eventUri = null;
      for (let i = 0; i < events.length; i++) {
        if (events[i].name === showName) {
          eventUri = events[i].iptvuri;
        }
      }
      return eventUri;
    }
    async _handleEnter() {
      let channel = this.getCurrentChannel();
      let events = await dtvApi$2.getEvents(channel.dvburi);
      let eventUri = null;
      if (events != undefined) {
        eventUri = this.getEventURI(events);
      }
      if (channel.dvburi === "OTT") {
        let params = {
          launchLocation: "epgScreen",
          url: channel.url
        };
        const appIdentifiers = {
          "YouTube": "n:5",
          "YouTube": "n:4",
          "YouTube": "n:3",
          "Netflix": "n:1",
          "Amazon": "n:2"
        }; //callsign to identifier mapping
        const appIdentifier = appIdentifiers[channel.callsign];
        if (appIdentifier) {
          params.appIdentifier = appIdentifier;
        }
        this.appApi.launchApp(channel.callsign, params);
      } else if (channel.dvburi.startsWith("C_") && eventUri != null) {
        if (!Router.isNavigating()) {
          let playerParams = {
            url: eventUri,
            //video url for playing
            isChannel: true,
            channelName: channel.channelName,
            showName: this.gridInstance[this.currentCellIndex].insText,
            showDescription: this.gridInstance[this.currentCellIndex].description,
            channelIndex: this.D - 8 + this.currentlyFocusedRow
          };
          Router.navigate("player", playerParams);
        }
      } else {
        if (!Router.isNavigating()) {
          this.DTV.launchChannel(channel.dvburi).then(res => {
            console.log("launchChannel method successful: ", JSON.stringify(res));
            this.widgets.channeloverlay.$focusChannel(this.D - 8 + this.currentlyFocusedRow);
            Router.navigate("dtvplayer");
          }).catch(err => {
            console.log("launchChannel method failed: ", JSON.stringify(err));
          });
        } else {
          console.error("Router is still navigating.");
        }
      }
    }
    getCurrentChannel() {
      let currentChannel = this.activeChannels[this.currentlyFocusedRow];
      return currentChannel;
    }
    setShows4Channels(channels) {
      let headStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.strtindexesofrows = [];
      let ltp = this.ltp;
      let rtp = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      let cells = [];
      let self = this;
      function filterShowsBasedOnTimeWindow(shows, index) {
        let inc = headStart < 0 ? -1 : 1;
        let i = Math.abs(headStart);
        while (i >= 0) {
          // binary search can optimize this loop.

          shows[i].endtime = shows[i].duration + shows[i].starttime;
          if (i >= shows.length) {
            console.warn("Reached the end of data , can't traverse shows any further!");
            break;
          } else if (new Date(shows[i].starttime) <= ltp && new Date(shows[i].endtime) > ltp) {
            break;
          } else if (new Date(shows[i].starttime) > ltp) {
            console.warn("there's chance that an empty space appear in one of the rows");
            break;
          } else if (i === shows.length - 1) {
            console.warn('traversed all of the shows and none of them are airing at this time for this channel');
            return;
          }
          i += inc;
        }
        let x = 0;
        self.strtindexesofrows.push(cells.length);
        for (; i < shows.length; i++) {
          if (new Date(shows[i].starttime) >= rtp) {
            break;
          }
          let width = shows[i].duration / (1000 * 60) / 30 * 236;
          shows[i].endtime = shows[i].duration + shows[i].starttime;
          // the below code trim the left most and right most cells
          if (new Date(shows[i].starttime) < ltp) {
            width -= (ltp - new Date(shows[i].starttime)) / (1000 * 60) / 30 * 236;
          }
          if (new Date(shows[i].endtime) > rtp) {
            width -= (new Date(shows[i].endtime) - rtp) / (1000 * 60) / 30 * 236;
          }
          //------------ Trimming ends here-----------------
          if (shows[i].shortdescription === "") {
            cells.push({
              x: x,
              y: index * 81,
              w: width,
              type: Cell,
              txt: shows[i].name,
              description: shows[i].shortdescription,
              width: width,
              starttime: shows[i].starttime,
              showIndex: i,
              duration: shows[i].duration,
              endtime: shows[i].endtime
            });
          } else {
            cells.push({
              x: x,
              y: index * 81,
              w: width,
              type: Cell,
              txt: shows[i].name,
              description: shows[i].description,
              width: width,
              starttime: shows[i].starttime,
              showIndex: i,
              duration: shows[i].duration,
              endtime: shows[i].endtime
            });
          }
          shows[i].duration + shows[i].starttime;
          x += width;
        }
        // the below code actually sets the shows
        if (index === channels.length - 1) {
          let shows = self.tag('Shows');
          shows.children = cells;
          self.strtindexesofrows.push(cells.length); // this is added just for calculation.
          self.gridInstance = shows.children;
          // self.updateCursor()
          self._setState('CellSelector');
        }
      }
      channels.map((channel, i) => {
        filterShowsBasedOnTimeWindow(channel.shows, i);
      });
    }
    setTimeLabelsBetween() {
      let startTime = this.ltp;
      let endTime = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      let arr = [];
      let p = this.tag('TimeLabels');
      for (let t = startTime, i = 0; t <= endTime; t = new Date(t.getTime() + 30 * 60 * 1000), i++) {
        // the increment can probably be improvised
        let H = t.getHours();
        let M = t.getMinutes();
        M = M.toString().length < 2 ? '0' + M : M;
        arr.push({
          x: i * 236,
          y: 35,
          mountY: 0,
          text: {
            text: H >= 12 ? H === 12 ? "".concat(H, ":").concat(M, "PM") : "".concat(H - 12, ":").concat(M, "PM") : "".concat(H, ":").concat(M, "AM"),
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...'
          }
        });
        p.children = arr;
      }
    }
    initialize() {
      this.ltp = new Date();
      let currentDateTime = this.ltp;
      let temp = currentDateTime.getMinutes();
      let closest30MinRoundOff;
      //the below round off system only works if the duration of the show is a multiple of 30.
      currentDateTime.setMilliseconds(0);
      currentDateTime.setSeconds(0);
      if (temp >= 30) {
        currentDateTime.setMinutes(30);
        closest30MinRoundOff = currentDateTime;
      } else {
        currentDateTime.setMinutes(0);
        closest30MinRoundOff = currentDateTime;
      }
      this.ltp = closest30MinRoundOff;
      this.closest30MinRoundOff = closest30MinRoundOff.getTime();
      this.setTimeLabelsBetween();
      let tBar = this.tag('TimeBar');
      let dTriangle = this.tag('DownTriangle');
      let self = this;
      this.interval = setInterval(() => {
        let now = new Date();
        if (now.getHours() === 0) ;
        let t = (now - self.ltp >= 0 ? now - self.ltp : 0) / (1000 * 60 * 30) * 236;
        tBar.w = t;
        dTriangle.x = t + k;
      }, 0);
    }
    setBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].setBoldText();
      for (let i = l; i <= r; i++) {
        this.gridInstance[i].setBoldText();
      }
    }
    unsetBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].unsetBoldText();
      for (let i = l; i <= r; i++) {
        this.gridInstance[i].unsetBoldText();
      }
    }
    scrollVertically(n) {
      if (n < 0) {
        this.D--;
      } else {
        this.D++;
      }
      console.log("setting vertical scroll from ".concat(this.D - 8, " to ").concat(this.D, " based the value ").concat(n));
      this.activeChannels = this.channels.slice(this.D - 8, this.D);
      this.setChannels(this.activeChannels);
      this.setShows4Channels(this.activeChannels);
    }
    onDataProvidedX() {
      console.log("on Data Provided");
      this.initialize();
      this.scrollVertically();
      this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
      this.setBoldText();
      this.paintCell();
      this.updateCursor();
      this.verticallyNonScrollableWindow = Math.min(this.channels.length - 1, 7);
    }
    paintCell() {
      this.gridInstance[this.currentCellIndex].color = CONFIG.theme.hex;
    }
    unpaintCell() {
      this.gridInstance[this.currentCellIndex].color = 0xffffffff;
    }
    _focus() {
      this.D = 7;
      this.DTV = this.DTV ? this.DTV : new DTVApi();
      let wrapper = this.tag("Wrapper");
      let loader = this.tag("Loader");
      wrapper.visible = false;
      loader.visible = true;
      this.loadingAnimation.start();
      let self = this;
      function f(page) {
        let d = new Date();
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        d = d.getTime();
        let e = d + 7 * 24 * 60 * 60 * 1000;
        function filler(shows) {
          let diff = 0;
          let currentShowETime = d;
          diff = shows[0].starttime - d;
          if (diff > 0) {
            shows.unshift({
              name: '',
              starttime: d,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
          let memLeakAlert = shows.length - 1;
          for (let i = 0; i < shows.length - 1; i++) {
            currentShowETime = shows[i].starttime + shows[i].duration;
            diff = shows[i + 1].starttime - currentShowETime;
            if (diff > 0) {
              if (memLeakAlert < 0) {
                console.warn('Memory leak alert; aborting black cell insert');
              }
              shows.splice(i + 1, 0, {
                name: '',
                starttime: currentShowETime,
                duration: diff,
                eventid: 0,
                shortdescription: ''
              });
              memLeakAlert--;
            }
          }
          currentShowETime = shows[shows.length - 1].starttime + shows[shows.length - 1].duration;
          diff = e - currentShowETime;
          if (e > 0) {
            shows.push({
              name: '',
              starttime: currentShowETime,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
        }
        return new Promise((resolve, reject) => {
          self.DTV.serviceList().then(async channels => {
            await homeApi.checkChannelComapatability(channels).then(res => {
              channels = res;
            });
            let traversedChannels = 0;
            channels.map((channel, i) => {
              if (channel.dvburi === "OTT") {
                traversedChannels++;
                channels[i].shows = [{
                  name: Language$1.translate("click to launch") + " ".concat(channel.shortname),
                  starttime: 0,
                  duration: e,
                  eventid: 0,
                  shortdescription: ''
                }];
                if (channels.length - 1 === traversedChannels) {
                  console.log("premium apps exclusive resolve");
                  page.channels = channels;
                  resolve(true);
                }
                return 0;
              }
              self.DTV.scheduleEvents(channel.dvburi).then(shows => {
                traversedChannels++;
                // for premium apps and empty cell
                if (!shows || shows.length === 0) {
                  channels[i].shows = [{
                    name: '',
                    starttime: d,
                    duration: e,
                    eventid: 0,
                    shortdescription: ''
                  }];
                } else {
                  channels[i].shows = shows;
                  filler(channels[i].shows);
                }
                if (channels.length === traversedChannels) {
                  page.channels = channels;
                  resolve(true);
                }
              }).catch(err => {
                // console.error(err)
                // return "Home"
                console.error('error', err);
                reject(err);
              });
            });
          }).catch(err => {
            reject(err);
          });
        });
      }
      f(this).then(res => {
        self.loadingAnimation.stop();
        self.onDataProvidedX();
        loader.visible = false;
        wrapper.visible = true;
      }).catch(err => {
        console.log("error while fetching data from dtv", err);
        Router.navigate('menu');
      });
    }
    _init() {
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
      this.cursorInstance = this.tag('CellCursor');
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      //resetting all variables
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
    }
    scrollHorizontally(n) {
      if (n < 0) {
        let prevShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex - 1];
        // this.ltp = new Date(Math.max(prevShow.starttime, this.closest30MinRoundOff))
        this.ltp = new Date(Math.max(prevShow.starttime));
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow];
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      } else {
        let nextShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex + 1];
        if (nextShow.duration > 3 * 60 * 60 * 1000) {
          this.ltp = new Date(nextShow.starttime);
        } else {
          let l = nextShow.starttime + nextShow.duration - 3 * 60 * 60 * 1000;
          this.ltp = new Date(l);
        }
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      }
      this.setTimeLabelsBetween();
      this.setBoldText();
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Guide'));
    }
    pageTransition() {
      return 'up';
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    static _states() {
      return [class CellSelector extends this {
        $enter() {}
        _handleLeft() {
          this.unpaintCell();
          if (this.currentCellIndex > this.strtindexesofrows[this.currentlyFocusedRow]) {
            this.currentCellIndex--;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex > 0) {
            this.scrollHorizontally(-1);
          } else {
            console.log("can't traverse any left");
            Router.focusWidget('Menu');
          }
          this.paintCell();
        }
        _handleRight() {
          this.unpaintCell();
          this.channels[this.D - (8 - this.currentlyFocusedRow)].shortname;
          if (this.currentCellIndex < this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1) {
            this.currentCellIndex++;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex < this.channels[this.D - (8 - this.currentlyFocusedRow)].shows.length - 1) {
            //current Cell index has to be updated at last
            this.scrollHorizontally(1);
          } else console.log("can't go further right");
          this.paintCell();
        }
        binarySearch(t, left, right) {
          const lim = left;
          t = new Date(t);
          let mid;
          while (left <= right) {
            mid = left + Math.floor((right - left) / 2);
            const sTime = new Date(this.gridInstance[mid].starttime);
            const eTime = new Date(this.gridInstance[mid].endtime);
            if (t >= sTime && t < eTime) return mid;else if (sTime > t) right = mid - 1;else left = mid + 1;
          }
          mid = Math.max(lim, left - 1);
          return mid;
        }
        _handleDown() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow < this.verticallyNonScrollableWindow) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow++;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D < this.channels.length) {
            let t = this.cellTimeTracker;
            this.scrollVertically(1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further ,it's the last row");
          this.setBoldText();
          this.paintCell();
        }
        _handleUp() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow > 0) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow--;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D > 8) {
            let t = this.cellTimeTracker;
            this.scrollVertically(-1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further , it's the first row");
          this.setBoldText();
          this.paintCell();
        }
        async updateDayLabel(starttime) {
          let daylabel = this.tag('DayLabel');
          let dTriangle = this.tag('DownTriangle');
          let channel = this.getCurrentChannel();
          let eventUri = null;
          if (channel.dvburi.startsWith("C_")) {
            let events = await dtvApi$2.getEvents(channel.dvburi);
            eventUri = this.getEventURI(events);
          }
          setTimeout(function () {
            let today = new Date();
            today.setHours(0);
            today.setMinutes(0);
            today.setSeconds(0);
            today.setMilliseconds(0);
            let t = today.getTime();
            let day = 24 * 60 * 60 * 1000;
            if (starttime == 0) {
              daylabel.text.text = Language$1.translate('TODAY');
            } else if (starttime > t) {
              t = starttime - t;
              if (t < day) {
                daylabel.text.text = Language$1.translate('TODAY');
              } else {
                let cellStartTime = new Date(starttime);
                daylabel.text.text = cellStartTime.getDate() + '-' + (cellStartTime.getMonth() + 1) + '-' + cellStartTime.getFullYear();
              }
            } else {
              t = t - starttime;
              if (t < day) {
                daylabel.text.text = Language$1.translate('TODAY');
              } else {
                if (dTriangle.__active && eventUri === null) {
                  daylabel.text.text = Language$1.translate('TODAY');
                } else {
                  let cellStartTime = new Date(starttime);
                  daylabel.text.text = cellStartTime.getDate() + '-' + (cellStartTime.getMonth() + 1) + '-' + cellStartTime.getFullYear();
                }
              }
            }
          }, 0);
        }
        updateInfoLabels() {
          let currentCell = this.gridInstance[this.currentCellIndex];
          this.tag('ChannelName').text.text = this.channelGridInstance[this.currentlyFocusedRow].title.text;
          this.tag('ShowName').text.text = currentCell.txt;
          this.tag('ShowDetails').text.text = currentCell.description;
          let s = new Date(currentCell.starttime);
          let e = new Date(currentCell.endtime);
          let ehours = e.getHours();
          let eminutes = e.getMinutes();
          if (eminutes.toString().length < 2) eminutes = '0' + eminutes;
          if (ehours >= 12) {
            eminutes = eminutes + 'p';
            if (ehours > 12) {
              ehours -= 12;
            }
          }
          let shours = s.getHours();
          let sminutes = s.getMinutes();
          if (sminutes.toString().length < 2) {
            sminutes = '0' + sminutes;
          }
          if (shours > 12) {
            shours -= 12;
          }
          this.tag('ShowTimings').text.text = "".concat(shours, ":").concat(sminutes, " - ").concat(ehours, ":").concat(eminutes);
          this.updateDayLabel(currentCell.starttime);
        }
        updateCursor() {
          let x = this.gridInstance[this.currentCellIndex].x;
          let y = this.gridInstance[this.currentCellIndex].y;
          let w = this.gridInstance[this.currentCellIndex].w;
          let self = this;
          setTimeout(function () {
            self.updateInfoLabels();
          }, 0);
          this.cursorInstance.patchCursor(x, y, w);
        }
        $exit() {
          console.log('exiting from state - CellSelector');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class DTVPlayer extends lng$1.Component {
    static _template() {
      return {
        Player: {
          w: 1920,
          h: 1080
        }
      };
    }
    _firstEnable() {
      this.dtvApi = new DTVApi();
      this.appApi = new AppApi();
    }
    _handleBack() {
      this.dtvApi.exitChannel().then(res => {
        console.log("exit channel: ", JSON.stringify(res));
      }).catch(err => {
        console.log("failed to exit channel: ", JSON.stringify(err));
      });
      Router.back();
    }
    _handleLeft() {
      Router.focusWidget("ChannelOverlay");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  //applauncher screen "will" be responsible for handling all overlays as widget and splash screens for apps(if required) | currently only handles settings overlay widget
  class AppLauncherScreen extends lng$1.Component {
    static _template() {
      return {
        Overlay: {
          w: 1920,
          h: 1080
        },
        SplashImage: {
          w: 1920,
          h: 1080,
          x: 960,
          y: 540,
          mount: 0.5,
          src: "",
          visible: false
        }
      };
    }
    showSplashImage(callsign) {
      if (this.splashImages[callsign]) {
        //splash image won't be shown if the callsign and image location is mapped in this.splashImages

        //first frame event
        this.firstFrameListener = this._thunder.on("org.rdk.RDKShell", "onApplicationFirstFrame", notification => {
          console.log("onApplicationFirstFrame notification from applauncherscreen: ", notification);
          if (notification.client === callsign.toLowerCase()) {
            console.log("firstframe event triggered hiding splash image");
            this.tag("SplashImage").src = "";
            this.tag("SplashImage").visible = false;
            this.moveApptoFront(callsign);
            this.firstFrameListener.dispose(); //dispose listener after event is triggered for first time
          }
        });

        //to show the splash image
        this.splashTimeout && Registry.clearTimeout(this.splashTimeout);
        this.tag("SplashImage").src = Utils.asset(this.splashImages[callsign]);
        this.tag("SplashImage").visible = true;

        //to hide the splash image after 30 sec in case firstframe event failed
        this.splashTimeout = Registry.setTimeout(() => {
          console.log("timeout triggered hiding splash image");
          this.tag("SplashImage").src = "";
          this.tag("SplashImage").visible = false;
          rdkShellApisInstance.moveToFront(callsign);
          this.firstFrameListener.dispose(); //dispose the event listener incase event did not trigger till 30s
        }, 30000);
      }
    }
    _firstEnable() {
      console.log("AppLauncherScreen is enabled for firstTime");
      this.splashImages = {
        "Netflix": 'images/apps/App_Netflix_Splash.png'
      }; //mapping between callsigns and splash images
      this._thunder = thunderJS$1(CONFIG.thunderConfig);
    }
    _focus() {
      console.log("AppLauncherScreen is focused");
    }
    _handleKey() {
      console.log("AppLauncherScreen is in focus, returning focus to corresponding app");
      if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
        //if appLauncher screen is in focus while on residentApp
        rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
        rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
        rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
      } else {
        rdkShellApisInstance.moveToFront(GLOBALS.topmostApp);
        rdkShellApisInstance.setFocus(GLOBALS.topmostApp);
        rdkShellApisInstance.setVisibility(GLOBALS.topmostApp, true);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var thunder$8 = thunderJS$1(CONFIG.thunderConfig);
  class CodeScreen extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          BackButton: {
            x: 180,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate("Back"),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true
          },
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            Description2: {
              x: -100,
              y: 500,
              mount: 0.5,
              text: {
                text: Language$1.translate("Loading Code") + "...",
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFF00CAFF,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {
      this._setState('Description');
    }
    _focus() {
      if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
        thunder$8.Controller.activate({
          callsign: "org.rdk.VoiceControl"
        }).then(res => {
          if (Storage$1.get("alexaOTPReset")) {
            AlexaApi.get().resetAVSCredentials();
            Storage$1.remove("alexaOTPReset");
          }
          thunder$8.on("org.rdk.VoiceControl", 'onServerMessage', notification => {
            console.log("VoiceControl.onServerMessage Notification: ", notification);
            this.VoiceControlData = notification;
            if (notification.xr_speech_avs.url != undefined) {
              this.tag('Description').text.text = Language$1.translate('Enter the code at') + " ".concat(notification.xr_speech_avs.url);
            } else {
              this.tag('Description').text.text = Language$1.translate('Fetching authorization code');
            }
            this.tag("Description2").visible = true;
            if (notification.xr_speech_avs.code != undefined) {
              this.tag("Description2").text.text = "".concat(notification.xr_speech_avs.code);
            } else {
              this.tag("Description2").text.text = Language$1.translate('Please wait');
            }
            if (notification.xr_speech_avs.state === "refreshed") {
              // DAB Demo Work Around - show Alexa Error screens only after Auth is succeeded.
              AlexaApi.get().setAlexaAuthStatus("AlexaHandleError");
              AlexaApi.get().enableSmartScreen();
              Router.navigate("SuccessScreen");
            } else if (notification.xr_speech_avs.state === "uninitialized" || notification.xr_speech_avs.state === "authorizing") {
              console.log("notification state is uninitialised");
              AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
            } else if (notification.xr_speech_avs.state === "unrecoverable error") {
              console.log("notification state is unrecoverable error");
              // Could be AUTH token Timeout; refresh it.
              Router.navigate("FailureScreen");
            }
          });
        }).catch(err => {
          console.log("VoiceControl Plugin Activation ERROR!: ", err);
          Metrics$3.error(Metrics$3.ErrorType.OTHER, 'PluginError', "Thunder Controller.activate Voice Error" + JSON.stringify(err), false, null);
        });
        this._setState('Description');
      }
    }
    _active() {
      this._setState('Description');
    }
    static _states() {
      return [class Description extends this {
        $enter() {
          this._setState("Description");
        }
        _handleUp() {
          this._setState("BackButton");
        }
        $exit() {
          this.tag('Description');
        }
      }, class BackButton extends this {
        $enter() {
          this.tag("BackButton");
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('AlexaConfirmationScreen');
          }
        }
        _focus() {
          this.tag('BackButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BackButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AlexaLoginScreen extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          BackButton: {
            x: 180,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate('Back'),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true
          },
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate('Alexa welcome message'),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            SignInButton: {
              x: -100,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 350,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 180,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate('Sign in with') + " Amazon",
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF000000,
                  fontStyle: 'normal'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {}
    _focus() {
      this._setState('SignInButton');
    }
    _active() {
      this._setState('SignInButton');
    }
    static _states() {
      return [class SignInButton extends this {
        $enter() {
          this.tag("SignInButton").visible = true;
          this.tag('SignInButton.Title').text.textColor = 0xFFFFFFFF;
          this._focus();
        }
        _focus() {
          this.tag('SignInButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('SignInButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('SignInButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('SignInButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        async _handleEnter() {
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
            console.log("Code coming from AlexaLoginScreen");
            Router.navigate("CodeScreen");
          }
        }
        _handleUp() {
          this._setState("BackButton");
        }
        $exit() {
          this._unfocus();
        }
      }, class BackButton extends this {
        $enter() {
          this.tag("BackButton");
          this.tag('BackButton.Title').text.textColor = 0xFFFFFFFF;
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('AlexaConfirmationScreen');
          }
        }
        _focus() {
          this.tag('BackButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BackButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleDown() {
          this._setState("SignInButton");
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SuccessScreen extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate("You are ready to use alexa. Here are some things to try"),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            Box1: {
              x: -600,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 420,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 200,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Play some jazz music"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            },
            Box2: {
              x: -100,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 420,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 200,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Play my Flash Briefing"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            },
            Box3: {
              x: 440,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 500,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 250,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("What's your favourite movie?"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            }
          },
          DoneButton: {
            x: 1700,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate("Finished"),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true,
            alpha: 1
          }
        }
      };
    }
    _focus() {
      Registry.clear();
      this._setState('DoneButton');
    }
    _active() {
      this._setState('DoneButton');
    }
    static _states() {
      return [class DoneButton extends this {
        $enter() {
          this.tag("DoneButton");
        }
        _handleEnter() {
          AlexaApi.get().enableSmartScreen();
          Registry.setTimeout(() => {
            Router.navigate('menu');
          }, Router.isNavigating() ? 20 : 0);
        }
        _focus() {
          this.tag('DoneButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('DoneButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('DoneButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('DoneButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          //this.show()
          this.tag('DoneButton');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  thunderJS$1(CONFIG.thunderConfig);
  class FailureScreen extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate('Alexa something went wrong message'),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            }
          },
          RetryButton: {
            x: 1700,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate('Retry'),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true,
            alpha: 1
          }
        }
      };
    }
    _init() {}
    _focus() {
      this.appApi = new AppApi();
      if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
        this.tag('RetryButton.Title').patch({
          text: {
            text: Language$1.translate("Dismiss")
          }
        });
      }
      this._setState('RetryButton');
    }
    _active() {
      this._setState('RetryButton');
    }
    static _states() {
      return [class RetryButton extends this {
        $enter() {
          console.log("setState DoneButton CodeScreen");
          this.tag("RetryButton");
          this._focus();
          this.tag('RetryButton.Title').text.textColor = CONFIG.theme.hex;
        }
        _handleEnter() {
          if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
            AlexaApi.get().resetAVSCredentials().then(() => {
              console.log("avs credentials reseted");
            });
            console.log("Current app: " + GLOBALS.topmostApp + ", moving the app to front");
            rdkShellApisInstance.moveToFront(GLOBALS.topmostApp);
            rdkShellApisInstance.setFocus(GLOBALS.topmostApp).catch(err => {
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'PluginError', "Thunder RDKshell set focus error" + JSON.stringify(err), false, null);
            });
          } else {
            AlexaApi.get().resetAVSCredentials().then(async () => {
              await Router.navigate('AlexaLoginScreen');
            });
          }
        }
        _focus() {
          this.tag('RetryButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('RetryButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('RetryButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('RetryButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Reboot Confirmation Screen.
   */
  class AlexaConfirmationScreen extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Exit Alexa"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Alexa will be disabled, are you sure to exit?"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            YesButton: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Yes"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            NoButton: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("No"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('NoButton');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class YesButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied");
          Router.navigate("menu");
        }
        _handleRight() {
          this._setState('NoButton');
        }
        _focus() {
          this.tag('YesButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('YesButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class NoButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('YesButton');
        }
        _focus() {
          this.tag('NoButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('NoButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class CameraStreamingScreen extends lng$1.Component {
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          shader: {
            x: 260,
            y: 390,
            w: 910,
            h: 520,
            type: lng$1.shaders.Hole
          },
          visible: true
        },
        Riot: {
          x: 300,
          y: 300,
          mount: 0.5,
          text: {
            text: "RIoT",
            fontFace: CONFIG.language.font,
            fontSize: 32,
            textColor: 0xFFF9F9F9,
            fontStyle: 'normal',
            zIndex: 10
          }
        },
        BorderTop: {
          x: 1470,
          y: 400,
          w: 550,
          h: 6,
          rect: true,
          mountX: 0.5
        },
        Switch1: {
          Text: {
            x: 1260,
            y: 450,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 1"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 450,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom: {
            x: 1470,
            y: 500,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch2: {
          Text: {
            x: 1260,
            y: 550,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 2"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 550,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom2: {
            x: 1470,
            y: 600,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch3: {
          Text: {
            x: 1260,
            y: 650,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 3"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 650,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom3: {
            x: 1470,
            y: 700,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch4: {
          Text: {
            x: 1260,
            y: 750,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 4"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 750,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom4: {
            x: 1470,
            y: 800,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _init() {
      this._setState('Switch1');
    }
    set params(args) {
      VideoPlayer.position(350, 270);
      VideoPlayer.size(890, 600);
      VideoPlayer.open(args.cameraUrl);
      VideoPlayer.consumer(this);
    }
    $videoPlayerEvent(eventName) {
      if (eventName === "Error" || eventName === "Abort") {
        VideoPlayer.reload();
      } else if (eventName === "Ended") {
        if (!Router.isNavigating()) {
          VideoPlayer.close();
          Router.navigate('camera/player/ExitScreen');
        }
      }
    }
    _handleBack() {
      VideoPlayer.close();
      Router.navigate('menu');
    }
    static _states() {
      return [class Switch1 extends this {
        $enter() {
          this.tag('BorderTop').color = CONFIG.theme.hex;
          this.tag('BorderBottom').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderTop').color = 0xFFF9F9F9;
          this.tag('BorderBottom').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch2');
        }
        _handleEnter() {
          if (this.tag("Switch1.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch1.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch1 Turned Off");
          } else {
            this.tag("Switch1.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch1 Turned On");
          }
        }
      }, class Switch2 extends this {
        $enter() {
          this.tag('BorderBottom').color = CONFIG.theme.hex;
          this.tag('BorderBottom2').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom').color = 0xFFF9F9F9;
          this.tag('BorderBottom2').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch3');
        }
        _handleUp() {
          this._setState('Switch1');
        }
        _handleEnter() {
          if (this.tag("Switch2.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch2.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch2 Turned Off");
          } else {
            this.tag("Switch2.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch2 Turned On");
          }
        }
      }, class Switch3 extends this {
        $enter() {
          this.tag('BorderBottom2').color = CONFIG.theme.hex;
          this.tag('BorderBottom3').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom2').color = 0xFFF9F9F9;
          this.tag('BorderBottom3').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch4');
        }
        _handleUp() {
          this._setState('Switch2');
        }
        _handleEnter() {
          if (this.tag("Switch3.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch3.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch3 Turned Off");
          } else {
            this.tag("Switch3.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch3 Turned On");
          }
        }
      }, class Switch4 extends this {
        $enter() {
          this.tag('BorderBottom3').color = CONFIG.theme.hex;
          this.tag('BorderBottom4').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom3').color = 0xFFF9F9F9;
          this.tag('BorderBottom4').color = 0xFFF9F9F9;
        }
        _handleUp() {
          this._setState('Switch3');
        }
        _handleEnter() {
          if (this.tag("Switch4.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch4.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch4 Turned Off");
          } else {
            this.tag("Switch4.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch4 Turned On");
          }
        }
      }];
    }
  }

  class CameraStreamingScreenExitConfirmationScreen extends lng$1.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Streaming has Ended Please go to Home"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to go to Home!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('Confirm');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('camera/player');
      }
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Router.navigate('menu');
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let api = null;
  var routes = {
    boot: queryParam => {
      let homeApi = new HomeApi();
      homeApi.setPartnerAppsInfo(queryParam.data);
      homeApi.getAPIKey().then(data => {
        if (data.data.length > 1) {
          api = data;
        }
      });
      return Promise.resolve();
    },
    // root: 'splash',
    routes: [...splashScreenRoutes.splashScreenRoutes, ...route$1.network, ...otherSettingsRoutes.otherSettingsRoutes, ...audioScreenRoutes.audioScreenRoutes, ...detailsScreenRoutes.detailsScreenRoutes, ...liveTvRoutes, {
      path: 'settings',
      component: SettingsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'failscreen',
      component: Failscreen
    }, {
      path: 'videoplayer',
      component: LightningPlayerControls,
      widgets: ['Volume', "AppCarousel", "VideoInfoChange"]
    }, {
      path: 'usb',
      component: UsbAppsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'epg',
      component: Epg,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'apps',
      component: AppStore,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'usb/player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay", "AppCarousel"]
    }, {
      path: 'usb/image',
      component: ImageViewer,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'image',
      component: ImageViewer,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'ui',
      component: UIList,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'menu',
      component: MainView,
      before: page => {
        const homeApi = new HomeApi();
        page.tvShowItems = homeApi.getTVShowsInfo();
        // page.usbApps = homeApi.getTVShowsInfo()
        if (api) {
          page.setGracenoteData(api);
        }
        return Promise.resolve();
      },
      widgets: ['Menu', 'Fail', 'Volume', "AppCarousel", "VideoInfoChange"]
    }, {
      path: 'tv-overlay/:type',
      component: TvOverlayScreen,
      options: {
        preventStorage: true
      }
    }, {
      path: 'applauncher',
      component: AppLauncherScreen,
      widgets: ['Volume', 'SettingsOverlay', "AppCarousel"] //other overlays needs to be added to improve ovelay functionality.
    }, {
      path: 'player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay", "AppCarousel"]
    }, {
      path: 'camera/player',
      component: CameraStreamingScreen,
      widgets: ['Menu']
    }, {
      path: 'camera/player/ExitScreen',
      component: CameraStreamingScreenExitConfirmationScreen
    }, {
      path: 'dtvplayer',
      component: DTVPlayer,
      widgets: ['Volume', 'TvOverlays', 'ChannelOverlay', "SettingsOverlay", "AppCarousel"]
    }, {
      path: '!',
      component: Error$1
    }, {
      path: '*',
      component: LogoScreen
    }, {
      path: "FailureScreen",
      component: FailureScreen
    }, {
      path: "SuccessScreen",
      component: SuccessScreen
    }, {
      path: "AlexaLoginScreen",
      component: AlexaLoginScreen
    }, {
      path: "CodeScreen",
      component: CodeScreen
    }, {
      path: "AlexaConfirmationScreen",
      component: AlexaConfirmationScreen
    }],
    afterEachRoute: request => {
      console.log("Routed to:" + JSON.stringify(request.hash));
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        Metrics$3.page(request.hash).then(success => {
          console.log("successfully routed to page  ==>", request.hash);
        }).catch(err => console.log("error in metrics.page", err));
      }
      AlexaApi.get().reportApplicationState(request.hash, true);
      if (request.hash === "menu") {
        /* To prevent the onboarding screen appearing next time. */
        Storage$1.set("setup", true);
      }
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in side panel.
   */
  class SidePanelItem extends lng$1.Component {
    /**
     * Function to render various elements in the side panel item.
     */
    static _template() {
      return {
        Item: {
          rect: true,
          Image: {
            w: 70,
            H: 70
          },
          Title: {
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: 0xffffffff
            }
          }
        }
      };
    }
    _init() {
      this.tag('Image').patch({
        src: Utils.asset(this.data.url),
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
    setColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }
    clearColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for side panel in home UI */
  class SidePanel extends lng$1.Component {
    static _template() {
      return {
        color: 0xff000000,
        rect: true,
        y: 270,
        w: 200,
        h: 810,
        SidePanel: {
          x: 0,
          y: 127,
          w: 240,
          h: 750,
          type: lng$1.components.ListComponent,
          roll: true,
          horizontal: false,
          invertDirection: true
        }
      };
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
      this.sidePanelData = this.homeApi.getSidePanelInfo();
      this._setState('SidePanel');
      this.indexVal = 0;
      this.prevIndex = 0;
    }

    /**
     * Function to set items in side panel.
     */
    set sidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 105
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        this.data = info;
        return {
          w: 50,
          h: 50,
          y: index == 0 ? 20 : (index + 1) * 20,
          type: SidePanelItem,
          data: info,
          focus: 1.1,
          unfocus: 1,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }

    /**
     * Function to reset items in side panel.
     */
    set resetSidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 0
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        return {
          w: 204,
          h: 184,
          y: index == 0 ? 25 : index == 1 ? 105 : index == 2 ? 260 : 470,
          type: SidePanelItem,
          data: info,
          focus: 0.7,
          unfocus: 0.4,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }
    /**
     * Function to set scaling to side panel.
     */
    set scale(scale) {
      this.tag('SidePanel').patch({
        scale: scale
      });
    }

    /**
     * Function to set x coordinate of side panel.
     */
    set x(x) {
      this.tag('SidePanel').patch({
        x: x
      });
    }

    /**
     * Function to set index value of side panel.
     */
    set index(index) {
      this.tag('SidePanel').items[this.prevIndex].clearColor();
      this.indexVal = index;
    }
    set deFocus(val) {
      if (val) {
        this.tag('SidePanel').items[this.prevIndex].clearColor();
      } else {
        this.tag('SidePanel').items[this.prevIndex].setColor();
      }
    }
    set scrollableLastRow(bool) {
      this.isLastRowScrollable = bool;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          if (this.tag('SidePanel').length) {
            return this.tag('SidePanel').items[this.indexVal];
          }
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight || key.keyCode == keyMap.Enter) {
            if (this.prevIndex != this.indexVal) {
              this.tag('SidePanel').items[this.prevIndex].clearColor();
            }
            this.prevIndex = this.indexVal;
            this.fireAncestors('$goToMainView', this.tag('SidePanel').items[this.indexVal], this.indexVal);
          } else if (key.keyCode == keyMap.ArrowDown) {
            if (this.tag('SidePanel').length - 1 != this.indexVal) {
              this.indexVal = this.indexVal + 1;
            }
            return this.tag('SidePanel').items[this.indexVal];
          } else if (key.keyCode == keyMap.ArrowUp) {
            if (0 === this.indexVal) {
              this.fireAncestors('$goToTopPanel', 0);
            } else {
              this.indexVal = this.indexVal - 1;
              return this.tag('SidePanel').items[this.indexVal];
            }
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for top panel in home UI */
  class TopPanel extends lng$1.Component {
    static _template() {
      return {
        TopPanel: {
          color: 0xff000000,
          rect: true,
          w: 1920,
          h: 270,
          Mic: {
            x: 105,
            // zIndex: 2,
            y: 87,
            src: Utils.asset('/images/topPanel/microphone.png'),
            w: 50,
            h: 50
          },
          Logo: {
            x: 200,
            y: 90,
            src: Utils.asset('/images/' + CONFIG.theme.logo),
            w: 227,
            h: 43
          },
          Page: {
            x: 200,
            y: 184,
            // mountY: 0.5,
            text: {
              fontSize: 40,
              text: Language$1.translate('home'),
              textColor: CONFIG.theme.hex,
              fontStyle: 'bolder',
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          Settings: {
            x: 1825 - 105 - 160 - 37 + 30,
            y: 111,
            mountY: 0.5,
            src: Utils.asset('/images/topPanel/setting.png'),
            w: 37,
            h: 37
          },
          Time: {
            x: 1920 - 105 - 160,
            y: 111,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 35,
              fontFace: CONFIG.language.font
            },
            w: 160,
            h: 60
          }
        }
      };
    }
    changeTimeZone(time) {
      this.zone = time;
    }
    updateZone(res) {
      this.zone = res;
    }
    _construct() {
      this.indexVal = 1;
      this.audiointerval = null;
      this.zone = null; // declaring this variable to keep track of zone changes
      this.appApi = new AppApi();
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.appApi.getZone().then(res => {
          this.updateZone(res);
        });
      } else {
        FireBoltApi.get().localization.getTimeZone().then(timezone => {
          this.updateZone(timezone);
        });
      }
      this.zone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    set index(index) {
      this.indexVal = index;
    }
    _focus() {
      this._setState('Setting');
      this.tag('Settings').color = CONFIG.theme.hex;
    }
    set changeText(text) {
      this.tag('Page').text.text = text;
      if (text === 'Home') {
        this.tag('Settings').color = 0xffffffff;
      }
    }

    /**
    *
    * @param {boolean} toggle
    * Function to change the mic icon.
    */
    set changeMic(toggle) {
      if (toggle) {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone_mute.png');
      } else {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone.png');
      }
    }
    _build() {
      Registry.setInterval(() => {
        let _date = this._updateTime(this.zone);
        if (this.zone) {
          this.tag('Time').patch({
            text: {
              text: _date.strTime
            }
          });
        }
      }, 1000);
    }
    updateIcon(tagname, url) {
      this.tag(tagname).patch({
        src: Utils.asset(url)
      });
    }

    /**
     * Function to update time in home UI.
     */
    _updateTime(zone) {
      if (zone != null) {
        let date = new Date();
        date = new Date(date.toLocaleString('en-US', {
          timeZone: zone
        }));
        // get day
        let days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let strDay = days[date.getDay()];

        // get month
        let month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let strMonth = month[date.getMonth()];
        let strDate = date.toLocaleDateString('en-US', {
          day: '2-digit'
        }) + ' ' + strMonth + ' ' + date.getFullYear();
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12;
        minutes = minutes < 10 ? '0' + minutes : minutes;
        let strTime = hours + ':' + minutes + ' ' + ampm;
        return {
          strTime,
          strDay,
          strDate
        };
      } else {
        return "";
      }
    }
    static _states() {
      return [class Mic extends this {
        $enter() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        _getFocused() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('Mic').color = 0xffffffff;
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight) {
            this._setState('Setting');
          } else if (key.keyCode == keyMap.ArrowDown) {
            this.tag('Mic').color = 0xffffffff;
            this.fireAncestors('$goToSidePanel', 0);
          }
        }
      }, class Setting extends this {
        $enter() {
          this.tag('Settings').color = CONFIG.theme.hex;
        }
        _handleKey(key) {
          if (key.keyCode === keyMap.ArrowDown) {
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          } else if (key.keyCode === keyMap.ArrowLeft) ; else if (key.keyCode === keyMap.Enter) {
            //this.tag('Page').text.text = Language.translate('settings')
            Router.navigate('settings');
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          }
        }
        $exit() {
          this.tag('Settings').color = 0xffffffff;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var route = {
    1: () => {
      Router.navigate('epg');
      Router.focusPage();
    },
    3: () => {
      Router.navigate('apps');
      Router.focusPage();
    },
    'default': () => {
      Router.navigate('menu');
      Router.focusPage();
    }
  };
  class Menu extends lng$1.Component {
    static _template() {
      return {
        TopPanel: {
          type: TopPanel
        },
        SidePanel: {
          type: SidePanel
        }
      };
    }
    pageTransition() {
      return 'down';
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
    }
    _focus() {
      if (!this.mainView) {
        this.mainView = Router.activePage();
      }
      this._setState('SidePanel');
    }
    _handleRight() {
      Router.focusPage();
    }
    $goToTopPanel() {
      this._setState('TopPanel');
      Router.focusWidget('Menu');
    }
    $goToSidePanel() {
      this._setState('SidePanel');
    }
    $goToMainView(sidePanelInstance, index) {
      if (route[index]) {
        route[index]();
      } else {
        route['default']();
      }
      sidePanelInstance.setColor();
      return;
    }
    refreshMainView() {
      if (this.mainView) {
        this.mainView.refreshFirstRow();
      }
    }
    setIndex(index) {
      this.tag('SidePanel').index = index;
    }
    notify(val) {
      if (val === 'TopPanel') {
        Router.focusWidget('Menu');
        this._setState('TopPanel');
      }
    }
    $scroll(val) {
      if (this.mainView) {
        this.mainView.scroll(val);
      }
    }
    updateTimeZone(timezone) {
      this.tag('TopPanel').changeTimeZone(timezone);
    }
    updateTopPanelText(text) {
      this.tag('TopPanel').changeText = text;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          return this.tag('SidePanel');
        }
      }, class TopPanel extends this {
        _getFocused() {
          return this.tag('TopPanel');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$7 = thunderJS$1(CONFIG.thunderConfig);
  function keyIntercept() {
    let clientName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GLOBALS.selfClientName;
    return new Promise((resolve, reject) => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercepts', {
        "intercepts": [{
          "client": clientName,
          "keys": [{
            "keyCode": keyMap.Home,
            "modifiers": []
          }, {
            "keyCode": keyMap.AudioVolumeDown,
            "modifiers": []
          }, {
            "keyCode": keyMap.AudioVolumeUp,
            "modifiers": []
          }, {
            "keyCode": keyMap.AudioVolumeMute,
            "modifiers": []
          }, {
            "keyCode": keyMap.Inputs_Shortcut,
            "modifiers": []
          }, {
            "keyCode": keyMap.Picture_Setting_Shortcut,
            "modifiers": []
          }, {
            "keyCode": keyMap.Youtube,
            "modifiers": []
          }, {
            "keyCode": keyMap.Power,
            "modifiers": []
          }, {
            "keyCode": keyMap.Amazon,
            "modifiers": []
          }, {
            "keyCode": keyMap.Netflix,
            "modifiers": []
          }, {
            "keyCode": keyMap.Settings_Shortcut,
            "modifiers": []
          }, {
            "keyCode": keyMap.Guide_Shortcut,
            "modifiers": []
          }, {
            "keyCode": keyMap.AppCarousel,
            "modifiers": []
          }]
        }]
      }).then(result => {
        if (result.success) resolve(result.success);
        reject(result);
      }).catch(err => {
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "KeyInterceptError", "Thunder RDKShell addKeyIntercepts error " + JSON.stringify(err), false, null);
        reject(err);
      });
    });
  }

  class Volume extends lng$1.Component {
    constructor() {
      super(...arguments);
      _defineProperty$1(this, "setVolume", async val => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            await this.appApi.setVolumeLevel(audioport[i], val);
          }
        }
        return true;
      });
      _defineProperty$1(this, "setMute", async val => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.audio_mute(audioport[i], val);
          }
        }
        return true;
      });
      _defineProperty$1(this, "getMuteStatus", async () => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.getMuted(audioport[i]).then(result => {
              if (result.success) {
                this.mute = result.muted;
              }
            });
          }
        }
        return true;
      });
    }
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 320,
        color: 0xFF000000,
        y: -320,
        alpha: 0.9,
        transitions: {
          y: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          },
          h: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          }
        },
        Overlay: {
          Line: {
            y: 317,
            h: 3,
            w: 1920,
            rect: true,
            color: 0xffffffff
          }
        },
        VolumeInfo: {
          alpha: 1,
          zIndex: 2,
          y: 160,
          x: 960,
          mountX: 0.5,
          mountY: 0.5,
          h: 100,
          w: 100,
          src: Utils.asset('/images/volume/Volume.png'),
          Text: {
            x: 100,
            y: 0,
            text: {
              text: 0,
              fontSize: 80,
              fontFace: CONFIG.language.font
            }
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.volTimeout = null;
      this.volume = 0;
      this.getMuteStatus();
      console.log("_firstEnable this.mute-", this.mute);
    }
    async onVolumeKeyDown() {
      this.volume = await this.getVolume();
      this.focus();
      console.log("onVolumeKeyDown this.mute-", this.mute);
      this._updateIcon(this.mute);
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.volume > 0) {
        this.volume -= 5;
        if (this.setVolume(this.volume)) {
          this._updateText(this.volume);
        }
      }
    }
    async onVolumeKeyUp() {
      this.volume = await this.getVolume();
      this.focus();
      this._updateIcon(this.mute);
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.volume < 100) {
        this.volume += 5;
        if (this.setVolume(this.volume)) {
          if (this.mute) {
            this._updateIcon(!this.mute);
            this.setMute(!this.mute);
          }
          this._updateText(this.volume);
        }
      }
    }
    async onVolumeMute() {
      let requestedState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.volume = await this.getVolume();
      await this.getMuteStatus(); // to update this.mute
      this.focus();
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.setMute(requestedState != undefined ? requestedState : !this.mute)) {
        this._updateIcon(requestedState != undefined ? requestedState : !this.mute);
      }
    }
    async onVolumeChanged() {
      let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.volume = await this.getVolume();
      this.getMuteStatus();
      this.focus();
      if (v) {
        this._updateIcon(!v);
        this.setMute(!v);
      }
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      this._updateText(this.volume);
    }
    _updateText(val) {
      this.tag('Text').text.text = val;
    }
    _updateIcon(check) {
      if (check) {
        this.tag('VolumeInfo').src = Utils.asset('images/volume/Volume_Mute.png');
      } else {
        this.tag('VolumeInfo').src = Utils.asset('/images/volume/Volume.png');
      }
    }
    focus() {
      //the volume widget would never be actually focused
      this.patch({
        smooth: {
          y: -30
        }
      });
    }
    unfocus() {
      //the volume widget would never be actually focused
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.patch({
        smooth: {
          y: -320
        }
      });
    }
    getAudioPorts() {
      return new Promise((resolve, reject) => {
        this.appApi.getConnectedAudioPorts().then(res => {
          resolve(res.connectedAudioPorts);
        }).catch(err => {
          console.error('Volume getConnectedAudioPorts error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    updateIcon(audioport) {
      return new Promise((resolve, reject) => {
        this.appApi.getMuted(audioport).then(result => {
          this.mute = result.muted;
          this._updateIcon(this.mute);
          resolve(true);
        }).catch(err => {
          console.error('Volume updateIcon error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    getVolume() {
      return new Promise(async (resolve, reject) => {
        let audioport = await this.getAudioPorts();
        /* Returns an array. */
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.getVolumeLevel(audioport[i]).then(async res1 => {
              await this.updateIcon(audioport[i]);
              if (res1) {
                resolve(parseInt(res1.volumeLevel));
              }
            }).catch(err => {
              console.error('Volume getVolumeLevel error:', JSON.stringify(err, 3, null));
              reject(false);
            });
          }
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$3 = new AppApi();
  class HdmiOutputScreen extends lng$1.Component {
    static _template() {
      return {
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      appApi$3.getSoundMode().then(result => {
        appApi$3.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          console.log('focusedHDMI');
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**s
   * Class for Audio screen.
   */

  class AudioScreen extends lng$1.Component {
    static _template() {
      return {
        AudioScreenOverlay: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        HdmiOutputScreen: {
          type: HdmiOutputScreen,
          visible: false
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState('OutputMode');
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language$1.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('AudioScreenOverlay').visible = false;
    }
    show() {
      this.tag('AudioScreenOverlay').visible = true;
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          this._setState('HdmiOutputScreen');
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          console.log("hdmioutputscreen");
          this._setState('HdmiOutputScreen');
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4-
           *
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(() => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0", 100).then(() => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(() => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(() => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(() => {
            this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(() => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(() => {
            this.appApi.getZoomSetting().then(() => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }, class HdmiOutputScreen extends this {
        $enter() {
          this.hide();
          console.log("hdmioutputscreenEnter");
          this.tag('HdmiOutputScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Audio  Output Mode');
        }
        $exit() {
          this.tag("HdmiOutputScreen").visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', 'Settings  Audio');
        }
        _getFocused() {
          console.log("hdmioutputscreenfocused");
          return this.tag('HdmiOutputScreen');
        }
        _handleBack() {
          console.log("hdmioutputscreenbackHDMI");
          this._setState("OutputMode");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$6 = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen extends lng$1.Component {
    static _template() {
      return {
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$6.on('org.rdk.DisplaySettings', 'resolutionPreChange', () => {
        console.log(new Date().toISOString() + " ResolutionOverlay got resolutionPreChange");
        Storage$1.set("ResolutionChangeInProgress", true);
      });
      thunder$6.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        console.log(new Date().toISOString() + " ResolutionOverlay got resolutionChanged");
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
        Storage$1.set("ResolutionChangeInProgress", false);
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      let sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            let bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen extends lng$1.Component {
    static _template() {
      return {
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        },
        ResolutionOverlay: {
          type: ResolutionScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        FireBoltApi.get().deviceinfo.getscreenresolution().then(resolution => {
          this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + "".concat(JSON.stringify(resolution[0]), " , ").concat(JSON.stringify(resolution[1]));
        });
        FireBoltApi.get().deviceinfo.gethdcp().then(res => {
          let hdcp = "";
          for (let key in res) {
            hdcp += "\t\t".concat(key, " : ").concat(res[key], " ");
            hdcp += ",";
          }
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), " ").concat(hdcp.substring(0, hdcp.length - 1));
        });
        FireBoltApi.get().deviceinfo.gethdr().then(res => {
          let hdr = "";
          for (let key in res) {
            hdr += "\t\t".concat(key, " : ").concat(res[key]);
            hdr += ",";
          }
          this.tag("HDR.Title").text.text = "".concat(Language$1.translate('High Dynamic Range: ')).concat(hdr.substring(0, hdr.length - 1));
        });
      } else {
        this._appApi.getResolution().then(resolution => {
          this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + resolution;
        }).catch(err => {
          console.log("Error fetching the Resolution" + JSON.stringify(err));
        });
        this._appApi.getHDCPStatus().then(result => {
          if (result.isHDCPCompliant && result.isHDCPEnabled) {
            this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
          } else {
            this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Not Supported ");
          }
        });
        this._appApi.getHDRSetting().then(result => {
          const availableHDROptions = {
            "HdrOff": "Off",
            "Hdr10": "HDR 10",
            "Hdr10Plus": "HDR 10+",
            "HdrHlg": "HLG",
            "HdrDolbyvision": "Dolby Vision",
            "HdrTechnicolor": "Technicolor HDR"
          };
          this.tag("HDR.Title").text.text = Language$1.translate('High Dynamic Range: ') + availableHDROptions[result];
        });
      }
      this._setState('Resolution');
    }
    hide() {
      this.tag('VideoScreenContents').visible = false;
    }
    show() {
      this.tag('VideoScreenContents').visible = true;
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          this._setState("ResolutionOverlay");
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
        _handleEnter() {
          //
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP')
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }, class ResolutionOverlay extends this {
        $enter() {
          this.hide();
          this.tag('ResolutionOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', "Settings  Video  Resolution");
        }
        $exit() {
          this.tag('ResolutionOverlay').visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', "Settings  Video");
        }
        _getFocused() {
          return this.tag('ResolutionOverlay');
        }
        _handleBack() {
          this._setState('Resolution');
        }
        // $updateResolution(value) {
        //   this.tag('Resolution.Title').text.text = 'Resolution: ' + value;
        // }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var currentInterface = [];
  class NetworkInfo extends lng$1.Component {
    static _template() {
      return {
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    _active() {
      this.onInterfaceStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onInterfaceStatusChanged', () => {
        this.refreshDetails();
      });
      this.onConnectionStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onConnectionStatusChanged', () => {
        this.refreshDetails();
      });
      this.onIPAddressStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onIPAddressStatusChanged', () => {
        this.refreshDetails();
      });
      this.onDefaultInterfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', () => {
        this.refreshDetails();
      });
    }
    _inactive() {
      this.onInterfaceStatusChangedCB.dispose();
      this.onConnectionStatusChangedCB.dispose();
      this.onIPAddressStatusChangedCB.dispose();
      this.onDefaultInterfaceChangedCB.dispose();
    }
    _disable() {
      if (this.NWPluginSelfActivated) Network.get().deactivate();
      if (this.WiFiPluginSelfActivated) Wifi.get().deactivate();
    }
    async refreshDetails() {
      this.tag("ConnectionType.Value").text.text = "NA";
      this.tag("Status.Value").text.text = Language$1.translate('Disconnected');
      this.tag("IPAddress.Value").text.text = "NA";
      this.tag("Gateway.Value").text.text = "NA";
      this.tag("MACAddress.Value").text.text = "NA";
      await Network.get().getDefaultInterface().then(defaultInterface => {
        Network.get().getIPSettings(defaultInterface).then(result => {
          if (result.interface === "WIFI") {
            this.tag("ConnectionType.Value").text.text = Language$1.translate("Wireless");
            this.tag("SSID").alpha = 1;
            this.tag("SignalStrength").alpha = 1;
            Wifi.get().getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
          } else if (result.interface === "ETHERNET") {
            this.tag("ConnectionType.Value").text.text = 'Ethernet';
            this.tag("SSID").alpha = 0;
            this.tag("SignalStrength").alpha = 0;
          }
          this.tag('InternetProtocol.Value').text.text = result.ipversion;
          this.tag('IPAddress.Value').text.text = result.ipaddr;
          this.tag("Gateway.Value").text.text = result.gateway;
        }).catch(err => console.error(err));
        Network.get().getInterfaces().then(interfaces => {
          currentInterface = interfaces.filter(data => data.interface === defaultInterface);
          if (currentInterface[0].connected) {
            this.tag("Status.Value").text.text = Language$1.translate('Connected');
          } else {
            this.tag('Status.Value').text.text = Language$1.translate('Disconnected');
          }
          this.tag('MACAddress.Value').text.text = currentInterface[0].macAddress;
        }).catch(error => console.log(error));
      }).catch(error => console.log(error));
    }
    _focus() {
      this.refreshDetails();
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class JoinAnotherNetworkComponent extends lng$1.Component {
    handleDone() {
      this.tag("Keyboard").visible = false;
      let securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14 || securityCode === 0 && !this.scode) {
        this.scode = true;
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        let self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }
    startConnectForAnotherNetwork(device, passphrase) {
      Wifi.get().connect(false, device, passphrase).then(() => {
        Wifi.get().saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            PersistentStoreApi.get().setValue('wifi', 'SSID', this._item.ssid);
          } else if (response.result !== 0) {
            Wifi.get().clearSSID();
            PersistentStoreApi.get().deleteNamespace('wifi');
          }
        });
      });
      this.fireAncestors("$navigateBack");
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xCC000000
        },
        Text: {
          x: 758,
          y: 70,
          text: {
            text: Language$1.translate("Find and join a WiFi network"),
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: Language$1.translate("Network Name") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: Language$1.translate("Security") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: Language$1.translate("Password") + ":",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard,
          visible: false,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 330,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: true
        },
        ShowPassword: {
          x: 1405,
          y: 312,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: Language$1.translate('Show Password'),
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: true
        }
      };
    }
    _focus() {
      this.scode = false;
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = Language$1.translate("Press OK to enter Password");
      this.tag("NetworkText").text.text = Language$1.translate("Press OK to enter SSID");
      this.tag('NetworkText').text.textColor = 0xff808080;
      this.tag('Pwd').text.textColor = 0xff808080;
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    encrypt() {
      if (this.prevState === "EnterPassword" && this.hidePasswd) return true;else return false;
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
          this.tag('NetworkText').text.text = this.textCollection['EnterSSID'];
          this.tag('NetworkText').text.textColor = 0xffffffff;
          this.tag("Keyboard").visible = true;
        }
        $exit() {
          this.tag('NetworkBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleRight() {
          this._setState("PasswordSwitchState");
        }
        _handleEnter() {
          this.tag("Keyboard").visible = true;
          this._setState('Keyboard');
          this.tag('Pwd').text.text = this.hidePasswd ? this.star : this.textCollection['EnterPassword'];
          this.tag('Pwd').text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag('PasswordBox').texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
          this.tag('ShowPassword').text.textColor = CONFIG.theme.hex;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleLeft() {
          this._setState("EnterPassword");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['EnterPassword']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
          this.tag('ShowPassword').text.textColor = 0xffffffff;
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (this.prevState === 'PasswordSwitchState') {
            this.prevState = "EnterPassword";
          }
          console.log("Prev state:", this.prevState);
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.star = this.prevState === "EnterPassword" ? this.star.substring(0, this.star.length - 1) : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.star = this.prevState === "EnterPassword" ? '' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          }
        }
        _handleUp() {
          this._setState(this.prevState);
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _active() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.star = "";
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
      this.hidePasswd = true;
      this.tag("Keyboard").visible = false;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen extends lng$1.Component {
    static _template() {
      return {
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate("Password") + ": ",
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1390,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Show Password'),
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: lng$1.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      let options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
      this.item(this.fireAncestors("$PairingnetworkParams"));
    }
    _unfocus() {
      // Nothing to do here.
    }
    _active() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this.fireAncestors("$navigateBack");
      } else if (option === 'Connect') {
        if (this._item) {
          console.log('trying to connect wifi');
          this.startConnect(this.passwd);
        }
      } else if (option === 'Disconnect') {
        Wifi.get().disconnect().then(() => {
          this.fireAncestors("$navigateBack");
        });
      }
    }
    startConnect() {
      let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      Wifi.get().connect(false, this._item, password).then(() => {
        Wifi.get().saveSSID(this._item.ssid, password, this._item.security).then(() => {
          console.log('Started connect and saved SSID; going back now.');
          this.fireAncestors("$navigateBack");
        });
      }).catch(err => {
        console.log('Not able to connect to wifi', JSON.stringify(err));
        this.fireAncestors("$navigateBack");
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = lng$1.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle = 'Error Title';
  const errorMsg = 'Error Message';
  class FailComponent extends lng$1.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailComponent.Title').text.text = args.title;
        this.tag('FailComponent.Message').text.text = Language$1.translate(args.msg);
      }
      if (args.count) {
        this.timeout = args.count;
      } else {
        this.timeout = 5;
      }
    }
    _unfocus() {
      this.tag('FailComponent.Title').text.text = errorTitle;
      this.tag('FailComponent.Message').text.text = errorMsg;
    }
    _active() {
      this.tag('Timer').text.text = "";
      this.initTimer();
    }
    initTimer() {
      this.timeInterval = Registry.setInterval(() => {
        this.tag('Timer').text.text = this.timeout >= 10 ? "0:".concat(this.timeout) : "0:0".concat(this.timeout);
        if (this.timeout > 0) {
          --this.timeout;
        } else {
          Router.focusPage();
        }
      }, 1000);
    }
    _inactive() {
      if (this.timeInterval) {
        Registry.clearInterval(this.timeInterval);
      }
    }
    static _template() {
      return {
        FailComponent: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: 0x000000,
            Timer: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for WiFi screen.
  */
  class WiFiScreen extends lng$1.Component {
    static _template() {
      return {
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        JoinAnotherNetworkOverlay: {
          type: JoinAnotherNetworkComponent,
          visible: false
        },
        WifiPairingScreen: {
          type: WifiPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }
    _init() {
      Network.get().activate();
      Wifi.get().activate();
    }
    async _active() {
      this.ssids = this.renderSSIDS = [];
      this.onAvailableSSIDsCB = Wifi.get().thunder.on(Wifi.get().callsign, 'onAvailableSSIDs', params => {
        console.log("WiFiOverlay onAvailableSSIDs length: ", params.ssids.length);
        this.ssids = [...this.ssids, ...params.ssids];
        if (!params.moreData) {
          this.renderSSIDS = this.ssids;
          this.ssids = [];
          this.tag('Switch.Loader').visible = false;
          this.wifiLoading.stop();
          this.renderDeviceList(this.renderSSIDS);
        }
        if (!params.ssids.length) {
          console.log("onAvailableSSIDs length is ZERO; scanning again.");
          if (this.wifiStatus) {
            Wifi.get().startScan();
            this.wifiLoading.play();
            this.tag('Switch.Loader').visible = true;
          }
        }
      });
      this.onWIFIStateChangedHandler = Wifi.get().thunder.on(Wifi.get().callsign, 'onWIFIStateChanged', notification => {
        if (notification.state > WiFiState.DISABLED && notification.state !== WiFiState.FAILED) {
          if (this.wifiStatus) {
            console.log("onWIFIStateChanged: startScan()");
            Wifi.get().startScan();
          }
        }
        if (notification.state === WiFiState.CONNECTED) {
          Network.get().setDefaultInterface("WIFI").then(() => {
            console.log("Successfully set WIFI as default interface.");
          }).catch(err => {
            console.error("Could not set WIFI as default interface." + JSON.stringify(err));
          });
          Wifi.get().getConnectedSSID().then(result => {
            PersistentStoreApi.get().setValue('wifi', 'SSID', result.ssid).then(response => {
              console.log(response);
            });
          });
          if (this.renderSSIDS.length) this.renderDeviceList(this.renderSSIDS);
        }
      });
      this.onErrorHandler = Wifi.get().thunder.on(Wifi.get().callsign, 'onError', notification => {
        if (notification.code === WiFiError.INVALID_CREDENTIALS || notification.code === WiFiError.SSID_CHANGED) {
          Wifi.get().clearSSID().then(() => {
            console.log("INVALID_CREDENTIALS; deleting WiFi Persistence data.");
            PersistentStoreApi.get().deleteNamespace('wifi');
          });
        }
        this.tag("FailScreen").notify({
          title: 'WiFi Error',
          msg: Language$1.translate(WiFiErrorMessages[notification.code])
        });
        this._setState('FailScreen');
      });
    }
    async _focus() {
      await Network.get().isInterfaceEnabled("WIFI").then(enabled => {
        this.wifiStatus = enabled;
        this._setState('Switch');
        if (this.wifiStatus) {
          this.wifiLoading.play();
          this.tag('Switch.Loader').visible = true;
          this.tag('Networks').visible = true;
          this.tag('JoinAnotherNetwork').visible = true;
          Wifi.get().startScan();
        } else {
          this.wifiLoading.stop();
          this.tag('Switch.Loader').visible = false;
          this.tag('Networks').visible = false;
          this.tag('JoinAnotherNetwork').visible = false;
        }
      });
    }
    changeStateBack(state) {
      this._setState(state);
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.ssids = [];
      this.renderSSIDS = [];
    }
    _inactive() {
      if (this.wifiStatus) {
        Wifi.get().stopScan();
      } else {
        console.log("check - not calling stopScan since this.wifiStatus is FALSE.");
      }
      if (this.onWIFIStateChangedHandler) this.onWIFIStateChangedHandler.dispose();
      if (this.onErrorHandler) this.onErrorHandler.dispose();
      if (this.onAvailableSSIDsCB) this.onAvailableSSIDsCB.dispose();
    }
    renderDeviceList(ssids) {
      console.log("WIFI Overlay renderDeviceList ssids.length:", ssids.length);
      this._pairedList = [];
      this.tag('Networks.PairedNetworks').h = 0;
      this.tag('Networks.AvailableNetworks').tag('List').rollMax = ssids.length * 90;
      this.tag('Networks.PairedNetworks').tag('List').items = [];
      this.tag('Networks.PairedNetworks').tag('List').h = 0;
      Wifi.get().getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
          this.tag('Networks').visible = true;
          this.tag('Networks.PairedNetworks').h = this._pairedList.length * 90;
          this.tag('Networks.PairedNetworks').tag('List').h = this._pairedList.length * 90;
          this.tag('Networks.PairedNetworks').tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          //console.log("SSID filter", device)
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else {
            return device;
          }
        });
        this.tag('Networks.AvailableNetworks').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').h = this._otherList.length * 90;
        this.tag('Networks.AvailableNetworks').tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    hide() {
      this.tag('WifiContents').visible = false;
    }
    show() {
      this.tag('WifiContents').visible = true;
    }
    $PairingnetworkParams() {
      return this.ListItem;
    }
    $navigateBack() {
      this._setState('Switch');
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          } else {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {}
        _getFocused() {
          return this.tag('Networks.PairedNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.ListItem = this.tag('Networks.PairedNetworks').tag('List').element._item;
          this._setState("WifiPairingScreen");
        }
      }, class AvailableDevices extends this {
        $enter() {}
        _getFocused() {
          return this.tag('Networks.AvailableNetworks').tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        async _handleEnter() {
          console.log("SSID check" + JSON.stringify(this.tag('Networks.AvailableNetworks').tag('List').element._item));
          this.ListItem = this.tag('Networks.AvailableNetworks').tag('List').element._item;
          await Wifi.get().isPaired().then(ispaired => {
            if (!ispaired) {
              // ispaired.result == 0 means saved SSID.
              Wifi.get().getPairedSSID().then(pairedssid => {
                if (pairedssid === this.ListItem.ssid) {
                  console.log("WiFiScreen getPairedSSID matched with current selection; try auto connect.");
                  Wifi.get().connect(true).then(() => {
                    Wifi.get().thunder.on('onError', notification => {
                      if (notification.code === WiFiError.SSID_CHANGED || notification.code === WiFiError.INVALID_CREDENTIALS) {
                        Wifi.get().clearSSID().then(() => {
                          this._setState("WifiPairingScreen");
                        });
                      }
                    });
                    Wifi.get().thunder.on('onWIFIStateChanged', notification => {
                      if (notification.state === WiFiState.CONNECTED) {
                        Network.get().setDefaultInterface("WIFI").then(() => {
                          console.log("Successfully set WIFI as default interface.");
                        }).catch(err => {
                          console.error("Could not set WIFI as default interface." + JSON.stringify(err));
                        });
                      }
                    });
                  }).catch(err => {
                    console.error("WiFiScreen auto-connect error:", JSON.stringify(err));
                    PersistentStoreApi.get().deleteKey('wifi', 'SSID').then(() => {
                      this._setState("WifiPairingScreen");
                    });
                  });
                } else {
                  console.log("WiFiScreen getPairedSSID differs with current selection.");
                  this._setState("WifiPairingScreen");
                }
              }).catch(err => {
                console.error("WiFi.getPairedSSID() error: ", JSON.stringify(err));
                this._setState("WifiPairingScreen");
              });
            } else {
              console.log("WiFi.isPaired() is false; attempting regular connect.");
              this._setState("WifiPairingScreen");
            }
          }).catch(err => {
            console.error("WiFi.isPaired() error: ", JSON.stringify(err));
            PersistentStoreApi.get().deleteKey('wifi', 'SSID').then(() => {
              this._setState("WifiPairingScreen");
            });
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState("JoinAnotherNetworkOverlay");
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this.tag('Networks.PairedNetworks').tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this.tag('Networks.AvailableNetworks').tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }, class JoinAnotherNetworkOverlay extends this {
        $enter() {
          console.log("wifiscreen JoinAnotherNetworkOverlay");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = false;
        }
        _getFocused() {
          return this.tag('JoinAnotherNetworkOverlay');
        }
        _handleBack() {
          this._setState('Switch');
        }
      }, class WifiPairingScreen extends this {
        $enter() {
          console.log("wifiscreen WifiPairingScreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('WifiPairingScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('WifiPairingScreen').visible = false;
        }
        _getFocused() {
          return this.tag('WifiPairingScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
      }, class FailScreen extends this {
        $enter() {
          console.log("wifiscreen FailScreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState('Switch');
        }
      }];
    }
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this.tag('Networks.PairedNetworks').tag('List');else if (listname === 'AvailableDevices') list = this.tag('Networks.AvailableNetworks').tag('List');
      if (!list) return;
      if (dir === 'down') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          //WiFi.get().startScan()
          if (listname === 'MyDevices' && this.tag('Networks.AvailableNetworks').tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this.tag('Networks.PairedNetworks').tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }
    async switch() {
      if (this.wifiStatus) {
        console.log("Disabling WIFI interface and plugin.");
        this.wifiLoading.start();
        this.tag('Switch.Loader').visible = true;
        await Network.get().setInterfaceEnabled("WIFI", false).then(() => {
          this.wifiStatus = false;
          this.tag('Networks').visible = false;
          this.tag('JoinAnotherNetwork').visible = false;
          this.tag('Switch.Loader').visible = false;
          this.wifiLoading.stop();
          this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        });
      } else {
        console.log("Enabling WIFI interface and plugin.");
        this.tag('JoinAnotherNetwork').visible = true;
        this.tag('Networks.PairedNetworks').tag('List').items = [];
        this.tag('Networks.AvailableNetworks').tag('List').items = [];
        this.tag('Switch.Loader').visible = true;
        this.wifiLoading.start();
        await Network.get().setInterfaceEnabled("WIFI", true).then(resp => {
          console.log("setInterfaceEnabled WIFI return: ", resp);
          Wifi.get().setEnabled().then(() => {
            this.wifiStatus = true;
            this.tag('Networks').visible = true;
            this.tag('JoinAnotherNetwork').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            Wifi.get().isPaired().then(ispaired => {
              if (!ispaired.result) {
                Wifi.get().connect(true);
              } else {
                Wifi.get().startScan();
                this.tag('Networks.PairedNetworks').tag('List').items = [];
                this.tag('Networks.AvailableNetworks').tag('List').items = [];
              }
            });
          });
        });
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkInterfaceScreen extends lng$1.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 175,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        },
        WifiScreen: {
          type: WiFiScreen,
          visible: false
        }
      };
    }
    _focus() {
      this._setState('WiFi');
    }
    _active() {
      this.onDefaultInterfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate("Connected");
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate('Error') + ', ' + Language$1.translate('Retry') + '!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
      });
      this.onConnectionStatusChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onConnectionStatusChanged', notification => {
        console.log('onConnectionStatusChanged notification from networkInterfaceScreen: ', notification);
        if (notification.interface === "ETHERNET") {
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate(notification.status.toLowerCase());
        }
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _inactive() {
      this.onDefaultInterfaceChangedCB.dispose();
      this.onConnectionStatusChangedCB.dispose();
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _getFocused() {
          return this.tag('WiFi');
        }
        _handleEnter() {
          this._setState("WifiScreen");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        async _handleEnter() {
          this.tag('Ethernet.Title').text.text = 'Ethernet :' + Language$1.translate('Configuring as default');
          this.tag('Ethernet.Loader').visible = true;
          this.loadingAnimation.start();
          await Network.get().isInterfaceEnabled("ETHERNET").then(enabled => {
            if (!enabled) {
              Network.get().setInterfaceEnabled("ETHERNET").then(() => {
                Network.get().setDefaultInterface("ETHERNET").then(result => {
                  if (result) {
                    this.loadingAnimation.stop();
                    this.tag('Ethernet.Title').text.text = 'Ethernet';
                    this.tag('Ethernet.Loader').visible = false;
                  }
                });
              });
            } else {
              Network.get().setDefaultInterface("ETHERNET").then(result => {
                if (result) {
                  this.loadingAnimation.stop();
                  this.tag('Ethernet.Title').text.text = 'Ethernet';
                  this.tag('Ethernet.Loader').visible = false;
                }
              });
            }
          });
        }
        _handleDown() {
          //  this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class WifiScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.tag('WifiScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface  WiFi');
        }
        $exit() {
          this.show();
          this.tag('WifiScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        _getFocused() {
          return this.tag('WifiScreen');
        }
        _handleBack() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class NetworkConfigurationScreen extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        color: 0x00000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        NetworkInfoScreen: {
          type: NetworkInfo,
          visible: false
        },
        NetworkInterfaceOverlay: {
          type: NetworkInterfaceScreen,
          visible: false
        }
      };
    }
    _active() {
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      Network.get().getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
      this.onDefaultIfaceChangedCB = Network.get()._thunder.on(Network.get().callsign, 'onDefaultInterfaceChanged', data => {
        this.$NetworkInterfaceText(data.newInterfaceName);
        this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6";

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _inactive() {
      this.onDefaultIfaceChangedCB.dispose();
    }
    _focus() {
      this._setState('NetworkInfo');
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language$1.translate('Network Interface: ') + text;
    }
    hide() {
      this.tag('NetworkConfigurationScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkConfigurationScreenContents').visible = true;
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          this._setState("NetworkInfoScreen");
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          this._setState("NetworkInterfaceOverlay");
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          //  this._setState('NetworkInfo')
        }
        _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          Network.get().isConnectedToInternet().then(result => {
            let connectionStatus = Language$1.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language$1.translate("Connected");
            } else {
              connectionStatus += Language$1.translate("Not Connected");
            }
            setTimeout(() => {
              this.tag('TestInternetAccess.Loader').visible = false;
              this.tag('TestInternetAccess.Title').text.text = connectionStatus;
              this.loadingAnimation.stop();
            }, 2000);
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {}
      }, class NetworkInfoScreen extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInfoScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Info');
        }
        $exit() {
          this.show();
          this.tag('NetworkInfoScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings / Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInfoScreen');
        }
        _handleBack() {
          this._setState('NetworkInfo');
        }
      }, class NetworkInterfaceOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInterfaceOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        $exit() {
          this.show();
          this.tag('NetworkInterfaceOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInterfaceOverlay');
        }
        _handleBack() {
          this._setState('NetworkInterface');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen extends lng$1.Component {
    static _template() {
      return {
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    getData(item) {
      console.log("setting pairing screen item: ", item);
      _item = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Disconnect');
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Connect');
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    _focus() {
      this._setState('ConnectDisconnect');
      this.item(this.fireAncestors("$BluetoothParams"));
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item.connected) {
            this.fireAncestors('$triggerBluetoothAction', 'Disconnect');
          } else {
            this.fireAncestors('$triggerBluetoothAction', 'Connect');
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Unpair');
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Cancel');
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen extends lng$1.Component {
    static _template() {
      return {
        Bluetooth: {
          y: 275,
          x: 200,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: lng$1.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: lng$1.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        BluetoothPairingScreen: {
          type: BluetoothPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }

    //  $navigateBack() {
    //   this._setState('AddADevice')
    // }

    $triggerBluetoothAction(option) {
      this.pressEnter(option);
      this._setState('AddADevice');
    }
    hide() {
      this.tag('Bluetooth').visible = false;
    }
    show() {
      this.tag('Bluetooth').visible = true;
    }
    _unfocus() {
      this._disable();
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      this.switch(); //so that switch will be enabled by default
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }

    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      Registry.clearInterval(this.scanTimer);
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }
    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.tag('List').rollMax = this._otherList.length * 90;
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('AddADevice');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Pairing Successful')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Pairing Failed')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            this._setState('FailScreen');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Failed to Disconnect')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Disconnected')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Unpaired')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Unpairing Failed')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      }
    }
    $BluetoothParams() {
      return this._pairedNetworks.tag('List').element._item;
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.tag('BluetoothPairingScreen').getData(this._pairedNetworks.tag('List').element._item);
          this._setState('BluetoothPairingScreen');
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
        }
        _handleBack() {
          this.hideAvailableDevices();
          this._setState('AddADevice');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class BluetoothPairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('BluetoothPairingScreen').visible = true;
        }
        _getFocused() {
          return this.tag('BluetoothPairingScreen');
        }
        $exit() {
          this._enable();
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('BluetoothPairingScreen').visible = false;
        }
        _handleBack() {
          this._setState('AddADevice');
        }
      }, class FailScreen extends this {
        $enter() {
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this._setState('AddADevice');
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (!list) return;
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            this._setState('FailScreen');
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          this.tag("FailScreen").notify({
            title: notification.name,
            msg: notification.newStatus
          });
          this._setState('FailScreen');
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$1 = new DTVApi();
  const thunder$5 = thunderJS$1(CONFIG.thunderConfig);

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan extends lng$1.Component {
    static _template() {
      return {
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language$1.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language$1.translate("Please wait scan in progress"),
            0.3: Language$1.translate("Please wait scan in progress") + ".",
            0.6: Language$1.translate("Please wait scan in progress") + "..",
            0.9: Language$1.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }
    _firstActive() {
      thunder$5.on("DTV", "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$1.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$1.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$1.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$1.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$1.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$1.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      return false; //so that handleBack of parent is also executed.
    }
    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }
    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }
    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }
    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }
    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }
    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language$1.translate("Select a") + " " + Language$1.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language$1.translate("Select a") + " " + Language$1.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language$1.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language$1.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language$1.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language$1.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language$1.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language$1.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language$1.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language$1.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language$1.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language$1.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language$1.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
          this.tag("Scroller").y = 2; //to reset the scroll to show the first item.
        }
        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$1.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Satellite"), true);
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Satellite.Title").text.text = Language$1.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language$1.translate("Select a") + " " + Language$1.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });
          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Frequency"), true);
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Polarity"), true);
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Polarity.Title").text.text = Language$1.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });
          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Symbol Rate"), true);
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("FEC"), true);
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("FEC.Title").text.text = Language$1.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Modulation"), true);
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Modulation.Title").text.text = Language$1.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Search Mode"), true);
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$1.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan extends lng$1.Component {
    static _template() {
      return {
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DvbSScan: {
          type: DvbSScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    hide() {
      this.tag("LiveTVScanScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVScanScreenContents").visible = true;
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          this._setState("DvbSScan");
        }
      }, class DvbSScan extends this {
        $enter() {
          this.hide();
          this.tag('DvbSScan').visible = true;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan / DVB-S Scan'));
        }
        $exit() {
          this.show();
          this.tag('DvbSScan').visible = false;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan'));
        }
        _getFocused() {
          return this.tag('DvbSScan');
        }
        _handleBack() {
          this._setState('SScan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings extends lng$1.Component {
    static _template() {
      return {
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        },
        LiveTvScanOverlay: {
          type: LiveTVScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState("Activate");
      if (active) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    hide() {
      this.tag("LiveTVSettingsScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVSettingsScreenContents").visible = true;
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (Storage.get("deviceType") != "IpStb") {
            if (active) {
              this.dtvApi.deactivate().then(res => {
                console.log(res);
                active = false;
                this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
              });
            } else {
              this.dtvApi.activate().then(res => {
                console.log(res);
                active = true;
                this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
              });
            }
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          this._setState("LiveTvScanOverlay");
        }
      }, class LiveTvScanOverlay extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvScanOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan'));
        }
        $exit() {
          this.show();
          this.tag('LiveTvScanOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV'));
        }
        _getFocused() {
          return this.tag('LiveTvScanOverlay');
        }
        _handleBack() {
          this._setState('Scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen extends lng$1.Component {
    static _template() {
      return {
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: lng$1.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(() => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error("error while registering the inactivity monitoring event" + JSON.stringify(err));
      });
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });
          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen extends lng$1.Component {
    static _template() {
      return {
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }
    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language$1.translate("Deep Sleep"), Language$1.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language$1.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language$1.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$2 = new AppApi();
  thunderJS$1(CONFIG.thunderConfig);
  const loader = 'Loader';
  class LanguageScreen extends lng$1.Component {
    static _template() {
      return {
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: lng$1.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _active() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      rdkShellApisInstance.destroy(loader).catch(err => {
        console.log("LanguageScreenOverlay: Error destroy loader: " + JSON.stringify(err));
      });
      rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
      rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
      rdkShellApisInstance.setFocus(GLOBALS.selfClientName).then(() => {
        console.log('LanguageScreenOverlay: ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('LanguageScreenOverlay: Error', err);
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder RDKShell Failed to moveToFront " + JSON.stringify(err), false, null);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          //need to verify
          if (Language$1.get() !== availableLanguages[this._Languages.tag('List').index]) {
            let updatedLanguage = availableLanguageCodes[availableLanguages[this._Languages.tag('List').index]];
            if ("ResidentApp" !== GLOBALS.selfClientName) {
              FireBoltApi.get().localization.setlanguage(availableLanguages[this._Languages.tag('List').index]).then(res => console.log("language set successfully"));
            } else {
              appApi$2.setUILanguage(updatedLanguage);
            }
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$2.launchResident(notification_url, loader).catch(err => {
              console.log("Error launchResident: " + JSON.stringify(err));
            });
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy = "Privacy\n  Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n\n  the categories of personally identifiable information about you that may be collected and how that information is used;\n  how we collect and use non-personally identifiable information about your use of the website;\n  the categories of persons or entities with whom the information may be shared;\n  the choices that are available to you regarding collection, use, and distribution of the information;\n  how you can opt out of RDK-related promotional e-mail;\n  the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n  how you can review and request changes to the information; and\n  how we notify users of this website of changes to this privacy policy.\n  Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n\n\n  What categories of information do we collect?\n  The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n\n  To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n\n  The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n\n  Does RDK Management analyze my interaction with this website?\n  Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n\n  We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n\n  You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n\n  What categories of persons or entities do we share personally identifiable information with?\n  We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n\n  What do we do to personalize your use of this website?\n  We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n\n  To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n\n  RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n\n  The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n\n  In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n\n  We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n\n  Your Access to and Control over your information?\n  You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n\n  Request to see all the information stored in the system\n  Accuracy of your data can be checked or corrected.\n  Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n  Express any concern you have about our use of your data\n  Opt out from receiving emails by clicking unsubscribe.\n  How do users opt out of RDK-related promotional e-mail?\n  You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n\n  Other Websites\n\n  To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n\n  Security\n\n  All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n\n  Changes to this Privacy Policy\n\n  We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n\n  A Special Note About Children\n\n  This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n\n  Contacting us:\n\n  If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n\n  Data Protection Officer:  Herman-Jan Smith\n\n  Email us at: hj.smith@rdkcentral.com\n\n  Contacting the appropriate authority:\n\n  Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n\n  Email: compliance_team@rdkcentral.com\n\n  Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen extends lng$1.Component {
    static _template() {
      return {
        PrivacyPolicyScreenContents: {
          h: 810,
          w: 1720,
          x: 200,
          y: 270,
          clipping: true,
          PrivacyPolicy: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontStyle: "bold",
                fontSize: 40
              }
            },
            Content: {
              x: 10,
              y: 100,
              text: {
                text: _privacyPolicy,
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 20,
                wordWrapWidth: 1500,
                wordWrap: true
              }
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 3) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Privacy Screen.
   */

  const xcastApi$1 = new XcastApi();
  class PrivacyScreen extends lng$1.Component {
    static _template() {
      return {
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        PrivacyPolicyScreen: {
          type: PrivacyPolicyScreen,
          visible: false
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    checkUSBDeviceStatus() {
      if (!Storage$1.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage$1.set('UsbMedia', 'ON');
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi$1.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        console.log('xcastApi getEnabled error:' + JSON.stringify(err));
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi$1.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi$1.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi$1.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active' + JSON.stringify(err));
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    hide() {
      this.tag('PrivacyScreenContents').visible = false;
    }
    show() {
      this.tag('PrivacyScreenContents').visible = true;
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          //  this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage$1.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(() => {
              Storage$1.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(() => {
              Storage$1.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          //
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          //  this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          this._setState("PrivacyPolicyScreen");
        }
      }, class PrivacyPolicyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyPolicyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy  Policy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyPolicyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyPolicyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('PrivacyPolicy');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen extends lng$1.Component {
    static _template() {
      return {
        DeviceInfoWrapper: {
          w: 1720,
          h: 810,
          x: 200,
          y: 275,
          clipping: true,
          DeviceInfoContents: {
            y: 3,
            Line1: {
              y: 0,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            ChipSet: {
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Chipset"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 45,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line2: {
              y: 90,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SerialNumber: {
              Title: {
                x: 10,
                y: 135,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Serial Number"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 135,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line3: {
              y: 180,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            Location: {
              Title: {
                x: 10,
                y: 225,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Location"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 225,
                mountY: 0.5,
                text: {
                  text: "CountryCode:",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line4: {
              y: 270,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SupportedDRM: {
              Title: {
                x: 10,
                y: 360,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Supported DRM & Key-System"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1600,
                  wordWrap: true,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 360,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1200,
                  wordWrap: true,
                  fontSize: 25
                }
              }
            },
            Line5: {
              y: 450,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            FirmwareVersions: {
              Title: {
                x: 10,
                y: 540,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Firmware version"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 540,
                mountY: 0.5,
                text: {
                  text: "UI Version: ".concat(Settings$2.get('platform', 'version'), ", Build Version: , Firebolt API Version: "),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line6: {
              y: 630,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            AppVersions: {
              Title: {
                x: 10,
                y: 720,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("App Info"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 720,
                mountY: 0.5,
                text: {
                  text: "YouTube:\nAmazon Prime:\nNetflix ESN:",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line7: {
              y: 810,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            }
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result);
      });
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.appApi.getSystemVersions().then(res => {
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
        }).catch(err => {
          console.error("error while getting the system versions" + JSON.stringify(err));
        });
        this._network.isConnectedToInternet().then(result => {
          if (result === true) {
            this.appApi.getLocation().then(result => {
              console.log("getLocation from device info " + JSON.stringify(result));
              let locationInfo = "";
              if (result.city.length !== 0) {
                locationInfo = "City: " + result.city;
              } else {
                locationInfo = "City: N/A ";
              }
              if (result.country.length !== 0) {
                locationInfo += ", Country: " + result.country;
              } else {
                locationInfo += ", Country: N/A ";
              }
              this.tag('Location.Value').text.text = "".concat(locationInfo);
            });
          } else {
            this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
          }
        });
      } else {
        FireBoltApi.get().deviceinfo.getversion().then(res => {
          console.log("build verion".concat(res.firmware.readable, " Firebolt API Version - ").concat(res.api.readable));
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.firmware.readable, " \nFirebolt API Version - ").concat(res.api.readable, " ");
        }).catch(err => {
          console.error("error while getting the system versions from Firebolt.getversion API" + JSON.stringify(err));
        });
        FireBoltApi.get().localization.countryCode().then(res => {
          this.tag('Location.Value').text.text = "CountryCode: ".concat(res);
        });
      }
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        let drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });
      let self = this;
      if (Storage$1.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage$1.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage$1.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "YouTube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "YouTube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > -200) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 3) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeOverlayItems extends lng$1.Component {
    static _template() {
      return {
        TimeItemsContents: {
          y: 3,
          List: {
            type: lng$1.components.ListComponent,
            h: 810,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          }
        }
      };
    }

    /**
     * Function refresh the list.
     */
    refreshList(item) {
      console.log("item from refreshList", item);
      this._item = item;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    _init() {
      if ("ResidentApp" !== GLOBALS.selfClientName) {
        FireBoltApi.get().localization.listen("timeZoneChanged", value => {
          console.log('timezone changed successfully to ', JSON.stringify(value));
        });
      }
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.fireAncestors("$updateTimeZone", "".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      //  this.widgets.menu.updateTimeZone(`${this._item.zone}/${this.tag('List').element._item[0]}`)
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      } else {
        FireBoltApi.get().localization.setTimeZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      }
      //  Router.navigate('settings/advanced/device/timezone', { refresh: true })
      return false; //to execute handle enter in parent component
    }
    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneOverlayItem extends lng$1.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: lng$1.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      this.fireAncestors("$navigateAndRefreshItems", {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
      // Router.navigate('settings/advanced/device/timezone/item', { time_region: this._item[1], zone: this._item[0], isActive: this.zone })
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone extends lng$1.Component {
    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    static _template() {
      return {
        TimeZoneOverlayScreenContents: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          List: {
            y: 3,
            type: lng$1.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: Language$1.translate('Not supported'),
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        },
        TimeOverlayItems: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          type: TimeOverlayItems,
          visible: false
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      if ("ResidentApp" === GLOBALS.selfClientName) {
        this.zone = await this.appApi.getZone();
      } else {
        this.zone = await FireBoltApi.get().localization.getTimeZone();
      }
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneOverlayItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
      this._setState('List');
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    hide() {
      this.tag('TimeZoneOverlayScreenContents').visible = false;
    }
    show() {
      this.tag('TimeZoneOverlayScreenContents').visible = true;
    }
    $navigateAndRefreshItems(params) {
      this.tag("TimeOverlayItems").refreshList(params);
      this._setState('TimeOverlayItems');
    }
    static _states() {
      return [class TimeOverlayItems extends this {
        $enter() {
          this.hide();
          this.tag('TimeOverlayItems').visible = true;
        }
        $exit() {
          this.show();
          this.tag('TimeOverlayItems').visible = false;
          this._firstEnable(); // so that the list will be refreshed when exiting from child screen.
        }
        _getFocused() {
          return this.tag('TimeOverlayItems');
        }
        _handleEnter() {
          this._setState('List');
        }
        _handleBack() {
          this._setState('List');
        }
      }, class List extends this {
        $enter() {
          this.show();
        }
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Firmware screen.
   */
  const thunder$4 = thunderJS$1(CONFIG.thunderConfig);
  class FirmwareScreen extends lng$1.Component {
    static _template() {
      return {
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _firstEnable() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      thunder$4.Controller.activate({
        callsign: "org.rdk.System"
      }).then(() => {
        thunder$4.on("org.rdk.System", "onFirmwareUpdateStateChange", notification => {
          console.log("FirmwareOverlay: on Firmware update state changed notifcation = ".concat(JSON.stringify(notification)));
          if (state[notification.firmwareUpdateStateChange] == "Downloading") {
            this.downloadInterval = setInterval(() => {
              console.log("Downloading...");
              this.getDownloadPercent();
            }, 1000);
          } else if (state[notification.firmwareUpdateStateChange] != "Downloading" && this.downloadInterval) {
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }, err => {
          console.error("FirmwareOverlay: error while fetching notification ie. ".concat(err));
          Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder system error while fetching onFirmwareUpdateStateChange notification " + JSON.stringify(err), false, null);
        });
      }).catch(err => {
        console.error("FirmwareOverlay: error while activating the system plugin" + JSON.stringify(err));
        Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder Controller.activate system error " + JSON.stringify(err), false, null);
      });
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _active() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      this.onFirmwareUpdateStateChangeCB = thunder$4.on('org.rdk.System', 'onFirmwareUpdateStateChange', notification => {
        this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + state[notification.firmwareUpdateStateChange];
        console.log('onFirmwareUpdateStateChange:' + JSON.stringify(notification));
        if (state[notification.firmwareUpdateStateChange] === "Downloading") {
          this.downloadInterval = setInterval(() => {
            console.log("Downloading...");
            this.getDownloadPercent();
          }, 1000);
        } else if (state[notification.firmwareUpdateStateChange] != "Downloading") {
          this.tag('DownloadedPercent.Title').visible = false;
          if (this.downloadInterval) {
            console.log("");
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }
      });
      this.getDownloadPercent();
    }
    showDownloadPercentage() {
      this.downloadInterval = setInterval(() => {
        console.log("showDownloadPercentage Downloading...");
        this.getDownloadPercent();
      }, 1000);
    }
    _disable() {
      if (this.onFirmwareUpdateStateChangeCB) this.onFirmwareUpdateStateChangeCB.dispose();
    }
    async _focus() {
      this.downloadInterval = null;
      this._appApi = new AppApi();
      const downloadState = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      await this._appApi.getFirmwareUpdateState().then(res => {
        console.log("FirmwareOverlay: getFirmwareUpdateState " + JSON.stringify(res));
        this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + downloadState[res.firmwareUpdateState];
        if (res.firmwareUpdateState === "Downloading") {
          this.showDownloadPercentage();
        }
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("FirmwareOverlay: getDownloadFirmwareInfo " + JSON.stringify(res));
        this.tag('Version.Title').text.text = Language$1.translate("Firmware Versions: ") + res.currentFWVersion;
      });
      this._setState('FirmwareUpdate');
    }
    getDownloadPercent() {
      this._appApi = new AppApi();
      this._appApi.getFirmwareDownloadPercent().then(res => {
        console.log("FirmwareOverlay: getFirmwareDownloadPercent ".concat(JSON.stringify(res)));
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').visible = false;
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').visible = true;
          this.tag('DownloadedPercent.Title').text.text = Language$1.translate("Download Progress: ") + res.downloadPercent + "%";
          if (this.downloadInterval === null) {
            this.downloadInterval = setInterval(() => {
              this.getDownloadPercent();
            }, 1000);
          }
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi = new AppApi();
      this._appApi.updateFirmware().then(() => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("FirmwareOverlay: getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language$1.translate('Downloaded Firmware Version: ') + "".concat(result.downloadFWVersion ? result.downloadFWVersion : 'NA');
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$1 = new AppApi();
  /**
   * Class for Reboot Confirmation Component.
   */
  class RebootConfirmation extends lng$1.Component {
    static _template() {
      return {
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xffffffff,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xff7d7d7d,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState("Confirm");
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        stopDelay: 0.2,
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$1.reboot().then(result => {
            console.log("device rebooting" + JSON.stringify(result));
            this._setState("Rebooting");
          });
        }
        _handleRight() {
          this._setState("Cancel");
        }
        _focus() {
          this.tag("Confirm").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Confirm").patch({
            color: 0xffffffff
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        //handleEnter is not required, default behaviour from parent is to exit this screen
        $enter() {
          this._focus();
        }
        _handleLeft() {
          this._setState("Confirm");
        }
        _focus() {
          this.tag("Cancel").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Cancel").patch({
            color: 0xff7d7d7d
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag("Buttons").visible = false;
          this.tag("Info").visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class DeviceScreen extends lng$1.Component {
    static _template() {
      return {
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            //  alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceInformationScreen: {
          type: DeviceInformationScreen,
          visible: false
        },
        TimeZoneOverlay: {
          type: TimeZone,
          visible: false
        },
        FirmwareScreen: {
          type: FirmwareScreen,
          visible: false
        },
        RebootConfirmationScreen: {
          type: RebootConfirmation,
          visible: false
        }
      };
    }
    _active() {
      this._setState('Info');
    }
    _focus() {
      this._setState('Info');
    }
    hide() {
      this.tag('DeviceScreenContents').visible = false;
    }
    show() {
      this.tag('DeviceScreenContents').visible = true;
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          //  this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          this._setState("DeviceInformationScreen");
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          this._setState("TimeZoneOverlay");
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          this._setState("FirmwareScreen");
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          //  this._setState('Reset')
        }
        _handleEnter() {
          this._setState("RebootConfirmation");
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          //this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {
          // Nothing to do here
        }
      }, class DeviceInformationScreen extends this {
        $enter() {
          this.hide();
          this.tag('DeviceInformationScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Info');
        }
        _getFocused() {
          return this.tag('DeviceInformationScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceInformationScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Device ');
        }
        _handleBack() {
          this._setState('Info');
        }
      },
      //TimeZoneOverlay
      class TimeZoneOverlay extends this {
        $enter() {
          this.hide();
          this.tag('TimeZoneOverlay').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Time');
        }
        _getFocused() {
          return this.tag('TimeZoneOverlay');
        }
        $exit() {
          this.show();
          this.tag('TimeZoneOverlay').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('TimeZone');
        }
      }, class FirmwareScreen extends this {
        $enter() {
          this.hide();
          this.tag('FirmwareScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Firmware Update');
        }
        _getFocused() {
          return this.tag('FirmwareScreen');
        }
        $exit() {
          this.show();
          this.tag('FirmwareScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('Firmware');
        }
      }, class RebootConfirmation extends this {
        $enter() {
          this.hide();
          this.tag("RebootConfirmationScreen").visible = true;
          this.fireAncestors('$hideBreadCrum');
        }
        _getFocused() {
          return this.tag("RebootConfirmationScreen");
        }
        $exit() {
          this.show();
          this.tag("RebootConfirmationScreen").visible = false;
          this.fireAncestors('$showBreadCrum');
        }
        _handleBack() {
          this._setState('Reboot');
        }
        _handleEnter() {
          //default behaviour, confirm will override this
          this._setState('Reboot');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for AdvancedSettings screen.
  */

  class AdvanceSettingsScreen extends lng$1.Component {
    static _template() {
      return {
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceScreen: {
          type: DeviceScreen,
          visible: false
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState('CECControl');
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    hide() {
      this.tag('AdvanceScreenContents').visible = false;
    }
    show() {
      this.tag('AdvanceScreenContents').visible = true;
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          this._setState("DeviceScreen");
        }
      }, class DeviceScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('DeviceScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('DeviceScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('Device');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen extends lng$1.Component {
    static _template() {
      return {
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            alpha: 0.3,
            // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        SleepTimerScreen: {
          type: SleepTimerScreen,
          visible: false
        },
        EnergySavingsScreen: {
          type: EnergySavingsScreen,
          visible: false
        },
        LanguageScreen: {
          type: LanguageScreen,
          visible: false
        },
        PrivacyScreen: {
          type: PrivacyScreen,
          visible: false
        },
        AdvanceSettingsScreen: {
          type: AdvanceSettingsScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + standbyMode;
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + text;
    }
    _focus() {
      this._setState('SleepTimer');
      if (Storage$1.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + Storage$1.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        let currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + currentStandbyMode;
      });
      if (Storage$1.get('ScreenSaverTimeoutInterval')) {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + Storage$1.get('ScreenSaverTimeoutInterval') + ' min';
      } else {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + 'Off';
      }
    }
    hide() {
      this.tag('OtherSettingsScreenContents').visible = false;
    }
    show() {
      this.tag('OtherSettingsScreenContents').visible = true;
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          //  this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('EnergySaver');
        }
        _handleEnter() {
          this._setState("SleepTimerScreen");
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('RemoteControl');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          //
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          this._setState("EnergySavingsScreen");
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          // this._setState("LanguageScreen")
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          this._setState("PrivacyScreen");
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          //  this._setState('SleepTimer')
        }
        _handleEnter() {
          this._setState("AdvanceSettingsScreen");
        }
      }, class SleepTimerScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('SleepTimerScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Sleep Timer');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('SleepTimerScreen');
        }
        $exit() {
          this.show();
          this.tag('SleepTimerScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('SleepTimer');
        }
      }, class EnergySavingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('EnergySavingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Energy Saver');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('EnergySavingsScreen');
        }
        $exit() {
          this.show();
          this.tag('EnergySavingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('EnergySaver');
        }
      },
      //LanguageScreen
      class LanguageScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('LanguageScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Language');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('LanguageScreen');
        }
        $exit() {
          this.show();
          this.tag('LanguageScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Language');
        }
      },
      //PrivacyScreen
      class PrivacyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Privacy');
        }
      }, class AdvanceSettingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('AdvanceSettingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('AdvanceSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('AdvanceSettingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('AdvancedSettings');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var thunder$3 = thunderJS$1(CONFIG.thunderConfig);
  /**
   * Class for settings screen.
   */
  class SettingsOverlay extends lng$1.Component {
    static _template() {
      return {
        Wrapper: {
          rect: true,
          color: 0xcc000000,
          w: 1920,
          h: 1080,
          visible: false,
          BreadCrumbs: {
            x: 200,
            y: 184,
            text: {
              fontSize: 40,
              text: Language$1.translate("settings"),
              textColor: CONFIG.theme.hex,
              fontStyle: "bolder",
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          SettingsScreenContents: {
            x: 200,
            y: 275,
            NetworkConfiguration: {
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Network Configuration"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Bluetooth: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Pair Remote Control"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Video: {
              y: 180,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Video"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Audio: {
              y: 270,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Audio"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            OtherSettings: {
              y: 360,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Other Settings"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            NFRStatus: {
              y: 450,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('Native Frame Rate'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 67,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset('images/settings/ToggleOffWhite.png')
              }
            },
            DTVSettings: {
              alpha: 0.3,
              y: 540,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Live TV"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            }
          },
          AudioScreenOverlay: {
            type: AudioScreen,
            visible: false
          },
          NetworkConfigurationOverlay: {
            type: NetworkConfigurationScreen,
            visible: false
          },
          BluetoothScreenOverlay: {
            type: BluetoothScreen,
            visible: false
          },
          LiveTvSettings: {
            type: LiveTVSettings,
            visible: false
          },
          VideoScreenOverlay: {
            type: VideoScreen,
            visible: false
          },
          OtherSettingsScreen: {
            type: OtherSettingsScreen,
            visible: false
          }
        }
      };
    }
    _focus() {
      this.tag("Wrapper").visible = true;
      this._setState("NetworkConfiguration");
      this.$updatePageTitle("settings"); //use this method as fireancestor from child components to change the page title
    }
    _unfocus() {
      this.tag("Wrapper").visible = false;
    }
    _firstActive() {
      if (Storage$1.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.appApi = new AppApi();
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      if (Storage$1.get("deviceType") != "IpStb") {
        this.dtvApi.activate().then(() => {
          this.dtvPlugin = true;
          this.tag("DTVSettings").alpha = 1;
        });
      }
    }
    _handleBack() {
      console.log("application Type = ", GLOBALS.topmostApp);
      if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
        if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
          Router.focusPage();
        } else {
          Router.focusPage();
          Router.navigate("menu");
        }
      } else {
        Router.focusPage();
        rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
        rdkShellApisInstance.setFocus(GLOBALS.topmostApp);
      }
    }
    _handleLeft() {
      //do nothing
    }
    _handleRight() {
      //do nothing
    }
    _handleUp() {
      //do nothing
    }
    _handleDown() {
      //do nothing
    }
    $updatePageTitle(title, alreadyTranslated) {
      console.log("title", title);
      if (alreadyTranslated) {
        this.tag("BreadCrumbs").text.text = title;
      } else {
        this.tag("BreadCrumbs").text.text = Language$1.translate(title);
      }
    }
    hide() {
      this.tag('SettingsScreenContents').visible = false;
    }
    show() {
      this.tag('SettingsScreenContents').visible = true;
    }
    $hideBreadCrum() {
      this.tag("BreadCrumbs").visible = false;
    }
    $showBreadCrum() {
      this.tag("BreadCrumbs").visible = true;
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag("NetworkConfiguration")._focus();
        }
        $exit() {
          this.tag("NetworkConfiguration")._unfocus();
        }
        _handleDown() {
          this._setState("Bluetooth");
        }
        _handleEnter() {
          this._setState('NetworkConfigurationOverlay');
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag("Bluetooth")._focus();
        }
        $exit() {
          this.tag("Bluetooth")._unfocus();
        }
        _handleUp() {
          this._setState("NetworkConfiguration");
        }
        _handleDown() {
          this._setState("Video");
        }
        _handleLeft() {}
        _handleEnter() {
          this._setState("BluetoothScreenOverlay");
        }
      }, class Video extends this {
        $enter() {
          this.tag("Video")._focus();
        }
        $exit() {
          this.tag("Video")._unfocus();
        }
        _handleUp() {
          this._setState("Bluetooth");
        }
        _handleDown() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState('VideoScreenOverlay');
        }
      }, class Audio extends this {
        $enter() {
          this.tag("Audio")._focus();
        }
        $exit() {
          this.tag("Audio")._unfocus();
        }
        _handleUp() {
          this._setState("Video");
        }
        _handleEnter() {
          this._setState('AudioScreenOverlay');
        }
        _handleDown() {
          this._setState("OtherSettings");
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag("OtherSettings")._focus();
        }
        $exit() {
          this.tag("OtherSettings")._unfocus();
        }
        _handleUp() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState("OtherSettingsScreen");
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage$1.get("NFRStatus")) {
            thunder$3.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage$1.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder Netflix.1 error disabling nfrstatus " + JSON.stringify(nerr), false, null);
              console.error(nerr);
            });
          } else {
            thunder$3.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage$1.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder Netflix.1 error enabling nfrstatus " + JSON.stringify(nerr), false, null);
              console.error(nerr);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag("DTVSettings")._focus();
        }
        $exit() {
          this.tag("DTVSettings")._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            this._setState("LiveTvSettings");
          }
          DTVApi.activate().then(res => {
            this.tag('DTVSettings.Title').text.text = 'DTV Settings: Activtion' + res;
          });
        }
      }, class AudioScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('AudioScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Audio');
        }
        _getFocused() {
          return this.tag('AudioScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('AudioScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("Audio");
        }
      }, class VideoScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('VideoScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Video');
        }
        _getFocused() {
          return this.tag('VideoScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('VideoScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Video');
        }
      }, class NetworkConfigurationOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkConfigurationOverlay').visible = true;
          this.$updatePageTitle("Settings  Network Configuration");
        }
        _getFocused() {
          return this.tag('NetworkConfigurationOverlay');
        }
        $exit() {
          this.show();
          this.tag('NetworkConfigurationOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("NetworkConfiguration");
        }
      }, class BluetoothScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('BluetoothScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Bluetooth On/Off');
        }
        _getFocused() {
          return this.tag('BluetoothScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('BluetoothScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Bluetooth');
        }
      }, class OtherSettingsScreen extends this {
        $enter() {
          this.hide();
          this.tag('OtherSettingsScreen').visible = true;
          this.$updatePageTitle('Settings  Other Settings');
        }
        _getFocused() {
          return this.tag('OtherSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('OtherSettingsScreen').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('OtherSettings');
        }
      }, class LiveTvSettings extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvSettings').visible = true;
          this.$updatePageTitle("Settings / Live TV");
        }
        _getFocused() {
          return this.tag('LiveTvSettings');
        }
        $exit() {
          this.show();
          this.tag('LiveTvSettings').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('DTVSettings');
        }
      }];
    }
  }

  class AppCarousel extends lng$1.Component {
    static _template() {
      return {
        rect: true,
        y: -340,
        w: 1920,
        h: 340,
        clipping: true,
        colorTop: 0xAA000000,
        colorBottom: 0xDD000000,
        AppList: {
          y: 24,
          x: 0,
          type: List,
          h: 400,
          scroll: {
            after: 2
          },
          spacing: 20
        }
      };
    }
    set appItems(items) {
      // items.shift();
      this.currentItems = items;
      this.tag('AppList').clear();
      this.tag('AppList').add(items.map((info, idx) => {
        return {
          w: 454,
          h: 220,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    _init() {
      this.homeApi = new HomeApi();
      this.appApi = new AppApi();
      this.metroApps = [];
      this.premiumApps = [];
      this.showcaseApps = [];
    }
    async _focus() {
      let self = this;
      console.log("self.homeApi.getAppListInfo()", self.homeApi.getAppListInfo());
      self.metroApps = self.homeApi.getOnlineMetroApps();
      self.premiumApps = self.homeApi.getAppListInfo();
      self.showcaseApps = self.homeApi.getShowCaseApps();
      let order = Storage$1.get("appCarouselOrder");
      console.log("order", order);
      let apps = [];
      if (order) {
        let storedApps = order.split(",");
        storedApps.map(appIdentifier => {
          let index;
          if (appIdentifier.startsWith("s")) {
            // showcase apps
            index = appIdentifier.split(":")[1];
            apps.push(self.showcaseApps[index]);
            self.showcaseApps[index] = -1;
          } else if (appIdentifier.startsWith("n")) {
            // native apps
            index = appIdentifier.split(":")[1];
            apps.push(self.premiumApps[index]);
            self.premiumApps[index] = -1;
          } else if (appIdentifier.startsWith("m")) {
            // metro apps
            index = appIdentifier.split(":")[1];
            apps.push(self.metroApps[index]);
            self.metroApps[index] = -1;
          }
        });
        console.log("APPS ARRAY: ", apps);
        self.premiumApps.map(papp => {
          if (papp !== -1 && papp.uri != "USB") {
            apps.push(papp);
          }
        });
        self.metroApps.map(mapp => {
          if (mapp !== -1) {
            apps.push(mapp);
          }
        });
        self.showcaseApps.map(sapp => {
          if (sapp !== -1) {
            apps.push(sapp);
          }
        });
      } else {
        self.premiumApps = self.premiumApps.filter(e => {
          if (e.uri == "USB") {
            return 0;
          } else {
            return e;
          }
        });
        apps = [...self.premiumApps, ...self.showcaseApps, ...self.metroApps];
      }
      await this.homeApi.checkAppCompatability(apps).then(res => {
        apps = res;
      });
      this.appItems = apps;
      self._setState("AppList.0");
      this.patch({
        smooth: {
          y: 0
        }
      });
    }
    close() {
      this.patch({
        smooth: {
          y: -340
        }
      });
    }
    _unfocus() {
      console.log("unfocus");
      this.close();
    }
    _handleBack() {
      if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
        // if a non-resident app is on focus
        rdkShellApisInstance.moveToFront(GLOBALS.topmostApp);
        rdkShellApisInstance.setFocus(GLOBALS.topmostApp);
        rdkShellApisInstance.setVisibility(GLOBALS.topmostApp, true);
      }
      Router.focusPage();
    }
    static _states() {
      return [class AppList extends this {
        $enter() {
          this.indexVal = 0;
        }
        _getFocused() {
          if (this.tag('AppList').length) {
            return this.tag('AppList');
          }
        }
        _handleLeft() {
          console.log("H left");
        }
        async _handleEnter() {
          let applicationType = this.tag('AppList').items[this.tag('AppList').index].data.applicationType;
          let uri = this.tag('AppList').items[this.tag('AppList').index].data.uri;
          let appIdentifier = this.tag('AppList').items[this.tag('AppList').index].data.appIdentifier;
          let params = {
            url: uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          this.appApi.launchApp(applicationType, params).then(() => {
            Router.focusPage();
          }).catch(err => {
            console.log("ApplaunchError: ", err);
          });
        }
      }];
    }
  }

  class Splash extends lng$1.Component {
    static _template() {
      return {};
    }
    _active() {
      console.log("Activevideo");
      VideoPlayer.playPause();
      VideoPlayer.consumer(this);
      VideoPlayer.size(1920, 1080);
      VideoPlayer.position(0, 0);
      VideoPlayer.open(Utils.asset("images/Screensaver.mp4"));
      VideoPlayer.loop();
    }
    _inactive() {
      VideoPlayer.close();
    }
    _init() {
      // VideoPlayer.playPause()
      // VideoPlayer.consumer(this);
      // VideoPlayer.size(1920, 1080);
      // VideoPlayer.position(0, 0);
      //VideoPlayer.mute();
    }
  }

  class VideoInfoChange extends lng$1.Component {
    static _template() {
      return {
        w: 1920,
        h: 340,
        y: -340,
        Background: {
          rect: true,
          y: 0,
          //-340,
          w: 1920,
          h: 340,
          clipping: true,
          colorTop: 0xAA000000,
          colorBottom: 0xDD000000
        },
        Title: {
          zIndex: 1,
          x: w => w / 2,
          y: h => h / 2,
          mountY: 0.5,
          mountX: 0.5,
          text: {
            text: "ZZZZ",
            //Language.translate('New Video Format : '),
            textColor: COLORS.titleColor,
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        }
      };
    }
    clear() {
      this.patch({
        smooth: {
          y: -340
        }
      });
      this.tag("Title").text.text = "YYYY";
      Router.focusPage();
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
    update(data) {
      let append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (append) {
        let txt = this.tag("Title").text.text;
        txt += "\n" + data;
        this.tag("Title").text.text = txt;
        console.log("write request recieved with data ", data);
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          Router.focusPage();
          self.clear();
        }, 3000);
      } else {
        console.log("update request recieved with the data ", data);
        this.tag("Title").text.text = data;
      }
    }
    _focus() {
      this.patch({
        smooth: {
          y: 0
        }
      });
      let self = this;
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        Router.focusPage();
        self.clear();
      }, 3000);
    }
    _handleKey() {
      clearTimeout(this.timer);
      this.timer = null;
      this.clear();
      console.log("Widget handle kEy Trigger");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let thunder$2 = thunderJS$1(CONFIG.thunderConfig);
  class PinChallengeProvider {
    challenge(challenge, session) {
      if (!challenge) return;
      console.log('Got challenge ' + JSON.stringify(challenge), "challenge");
      return new Promise(resolve => {
        this.showChallengeUi(challenge, resolve);
        session.focus();
      });
    }
    showChallengeUi(challenge, responder) {
      console.log("Displaying showChallengeUi with: " + GLOBALS.selfClientName);
      new Promise(async resolve => {
        let message = challenge.requestor.name + ' is requesting that you enter your ' + challenge.pinSpace + ' pin.';
        let params = {
          message: message,
          challenge: challenge,
          responder
        };
        thunder$2.call('org.rdk.RDKShell', 'setVisibility', {
          client: GLOBALS.selfClientName,
          visible: true
        }).then(() => {
          Router.navigate('settings/other/SecurityPinScreen', params);
        }).catch(err => Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Thunder RDKShell set visibility error " + err, true, null));
        resolve(true);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AckChallengeProvider {
    challenge(challenge, session) {
      if (!challenge) return;
      console.log("Got challenge req:" + JSON.stringify(challenge) + "challenge");
      return new Promise(resolve => {
        this.showChallengeUi(challenge, resolve);
        session.focus();
      });
    }
    showChallengeUi(challenge, responder) {
      new Promise(async resolve => {
        let message = 'Do you give access to ' + challenge.requestor.name + ' to ' + challenge.capability + '?';
        let params = {
          message: message,
          responder
        };
        Router.navigate('settings/other/AcknowledgeScreen', params);
        resolve(true);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let thunder$1 = thunderJS$1(CONFIG.thunderConfig);
  class KeyboardUIProvider {
    constructor(app) {
      this._app = app;
      this.INFO = function () {};
      this.LOG = console.log;
      this.ERR = console.error;
    }
    standard(keyboardSession, providerSession) {
      this.LOG("Inside standard call");
      if (!keyboardSession) return;
      return new Promise(resolve => {
        this.showKeyboardUi(keyboardSession, false, resolve);
        providerSession.focus();
      });
    }
    email(keyboardSession, providerSession) {
      this.LOG("Inside email call");
      if (!keyboardSession) return;
      return new Promise(resolve => {
        this.showKeyboardUi(keyboardSession, false, resolve);
        providerSession.focus();
      });
    }
    password(keyboardSession, providerSession) {
      this.LOG("Inside password call");
      if (!keyboardSession) return;
      return new Promise(resolve => {
        this.showKeyboardUi(keyboardSession, true, resolve);
        providerSession.focus();
      });
    }
    async showKeyboardUi(session, mask, responder) {
      if (!session) return;
      this.LOG('Got session ' + JSON.stringify(session), "showKeyboardUi");
      this.LOG("Displaying Keyboard overlay with: " + GLOBALS.selfClientName);
      let params = {
        message: session.message,
        type: session.type,
        responder
      };
      thunder$1.call('org.rdk.RDKShell', 'setVisibility', {
        client: GLOBALS.selfClientName,
        visible: true
      }).then(() => {
        Router.navigate("settings/other/KeyboardScreen", params);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var powerState = 'ON';
  var AlexaAudioplayerActive = false;
  var thunder = thunderJS$1(CONFIG.thunderConfig);
  var appApi = new AppApi();
  var dtvApi = new DTVApi();
  var cecApi = new CECApi();
  var xcastApi = new XcastApi();
  var voiceApi = new VoiceApi();
  class App extends Router.App {
    _handleAppClose() {
      console.error("_handleAppClose triggered.");
      this.toggleExitDialog().then(confirmed => {
        console.error("_handleAppClose triggered should not reach here.");
        // RefUI is not supposed to exit. Prevent that control.
        if (confirmed) {
          console.error("_handleAppClose calling closeApp; should not reach here.");
          this.application.closeApp();
        }
      });
    }
    static getFonts() {
      return [{
        family: 'Play',
        url: Utils.asset('fonts/Play/Play-Regular.ttf')
      }];
    }
    _setup() {
      console.log("accelerator-home-ui version: " + Settings$2.get("platform", "version"));
      console.log("UI setup selfClientName:" + GLOBALS.selfClientName + ", current topmostApp:", GLOBALS.topmostApp);
      Storage$1.set("ResolutionChangeInProgress", false);
      Router.startRouter(routes, this);
      document.onkeydown = e => {
        if (e.keyCode == keyMap.Backspace) {
          e.preventDefault();
        }
      };
      function updateAddress() {
        if (window.navigator.onLine) {
          console.log("is online");
        } else {
          Storage$1.set("ipAddress", null);
          console.log("is offline");
        }
      }
      window.addEventListener("offline", updateAddress);
    }
    static _template() {
      return {
        Pages: {
          // this hosts all the pages
          forceZIndexContext: true
        },
        Widgets: {
          VideoInfoChange: {
            type: VideoInfoChange
          },
          Menu: {
            type: Menu
          },
          Fail: {
            type: Failscreen
          },
          Volume: {
            type: Volume
          },
          TvOverlays: {
            type: TvOverlayScreen
          },
          ChannelOverlay: {
            type: ChannelOverlay
          },
          SettingsOverlay: {
            type: SettingsOverlay
          },
          AppCarousel: {
            type: AppCarousel
          }
        },
        VideoScreen: {
          alpha: 0,
          w: 2000,
          h: 1500,
          zIndex: 999,
          type: Splash
        },
        Failscreen1: {
          alpha: 0,
          type: Failscreen
        },
        AAMPVideoPlayer: {
          type: AAMPVideoPlayer
        },
        ScreenSaver: {
          alpha: 0,
          w: 2000,
          h: 1500,
          zIndex: 999,
          src: Utils.asset('images/tvShows/fantasy-island.jpg')
        }
      };
    }
    static language() {
      return {
        file: Utils.asset('language/language-file.json'),
        language: ("ResidentApp" === GLOBALS.selfClientName ? CONFIG.language : Localization$1.language()) || 'en'
      };
    }
    $updateTimeZone(timezone) {
      this.tag('Menu').updateTimeZone(timezone);
    }
    _captureKey(key) {
      console.log("Got keycode : " + JSON.stringify(key.keyCode));
      console.log("powerState ===>", GLOBALS.powerState);
      if (GLOBALS.powerState !== "ON") {
        appApi.setPowerState("ON").then(res => {
          res.success ? console.log("successfully set the power state to ON from ", GLOBALS.powerState) : console.log("Failure while turning ON the device");
        });
        return true;
      }
      let self = this;
      this.$hideImage(0);
      if (key.keyCode == keyMap.Home && !Router.isNavigating()) {
        if (GLOBALS.topmostApp.includes("dac.native")) {
          this.jumpToRoute("apps");
        } else {
          this.jumpToRoute("menu"); //method to exit the current app(if any) and route to home screen
        }
        return true;
      } else if (key.keyCode == keyMap.Inputs_Shortcut && !Router.isNavigating()) {
        //for inputs overlay
        if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
          if (Router.getActiveHash() === "tv-overlay/inputs") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/inputs", false);
          }
          // appApi.setVisibility('ResidentApp', true);
          rdkShellApisInstance.moveToFront(GLOBALS.selfClientName).then(() => {
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            console.log('App: ResidentApp moveToFront Success');
            rdkShellApisInstance.setFocus(GLOBALS.selfClientName).then(() => {
              console.log("App: residentApp setFocus Success");
            }).catch(err => {
              console.log("App: Error", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'APPError', "RDKShell setFocus error" + err, false, null);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlayInputScreen");
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Picture_Setting_Shortcut && !Router.isNavigating()) {
        //for video settings overlay
        if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
          if (Router.getActiveHash() === "tv-overlay/settings") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/settings", false);
          }
          rdkShellApisInstance.moveToFront(GLOBALS.selfClientName).then(() => {
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            console.log('App: ResidentApp moveToFront Success');
            rdkShellApisInstance.setFocus(GLOBALS.selfClientName).then(() => {
              console.log("App: Resident App setFocus Success");
            }).catch(err => {
              console.log("App: Error", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, 'AppError', "RDKShell setFocus error" + err, false, null);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlaySettingsScreen");
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Settings_Shortcut && !Router.isNavigating()) {
        console.log("settings shortcut");
        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
          //launch settings overlay/page depending on the current route.
          if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
            //player supports settings overlay, so launch it as overlay
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
            } else {
              //launch the settings overlay
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //navigate to settings page for all other routes
            Router.navigate("settings");
          }
        } else {
          //currently on some application
          if (Router.getActiveHash() === "applauncher") {
            //if route is applauncher just focus the overlay widget
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
              let currentApp = GLOBALS.topmostApp;
              rdkShellApisInstance.moveToFront(currentApp);
              rdkShellApisInstance.setFocus(currentApp);
              rdkShellApisInstance.setVisibility(currentApp, true);
            } else {
              //launch the settings overlay
              rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
              rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
              rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //if on some other route while on an application, route to applauncher before launching the settings overlay
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            Router.navigate("applauncher");
            Router.focusWidget('SettingsOverlay');
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Guide_Shortcut && !Router.isNavigating()) {
        this.jumpToRoute("epg"); //method to exit the current app(if any) and route to home screen
        return true;
      } else if (key.keyCode == keyMap.Amazon && !Router.isNavigating()) {
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["Amazon"]
        };
        appApi.launchApp("Amazon", params).catch(err => {
          console.error("Error in launching Amazon via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.Youtube && !Router.isNavigating()) {
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["YouTube"]
        };
        appApi.launchApp("YouTube", params).catch(err => {
          console.error("Error in launching Youtube via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.Netflix && !Router.isNavigating()) {
        //launchLocation mapping is in launchApp method in AppApi.js
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["Netflix"]
        };
        appApi.launchApp("Netflix", params).catch(err => {
          console.error("Error in launching Netflix via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.AppCarousel && !Router.isNavigating()) {
        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
          // if resident app is on focus
          if (Router.getActiveHash() === "menu") {
            return true;
          } else if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "AppCarousel") {
            //currently focused on appcarousel, so hide it
            Router.focusPage();
          } else {
            //launch the app carousel
            Router.focusWidget("AppCarousel");
          }
        } else {
          //currently on some application
          if (Router.getActiveHash() === "applauncher") {
            //if route is applauncher just focus the overlay widget
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "AppCarousel") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
              rdkShellApisInstance.moveToFront(GLOBALS.topmostApp);
              rdkShellApisInstance.setFocus(GLOBALS.topmostApp);
              rdkShellApisInstance.setVisibility(GLOBALS.topmostApp, true);
            } else {
              //launch the settings overlay
              rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
              rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
              rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
              Router.focusWidget('AppCarousel');
            }
          } else {
            //if on some other route while on an application, route to applauncher before launching the settings overlay
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            Router.navigate("applauncher");
            Router.focusWidget('AppCarousel');
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Power) {
        // Remote power key and keyboard F1 key used for STANDBY and POWER_ON
        appApi.getPowerState().then(res => {
          console.log("getPowerState: ", res);
          if (res.success) {
            if (res.powerState === "ON") {
              console.log("current powerState is ON so setting power state to LIGHT_SLEEP/DEEP_SLEEP depending of preferred option");
              appApi.getPreferredStandbyMode().then(res => {
                console.log("getPreferredStandbyMode: ", res.preferredStandbyMode);
                appApi.setPowerState(res.preferredStandbyMode).then(result => {
                  if (result.success) {
                    console.log("successfully set powerstate to: " + res.preferredStandbyMode);
                  }
                });
              });
            } else {
              console.log("current powerState is " + res.powerState + " so setting power state to ON");
              appApi.setPowerState("ON").then(res => {
                if (res.success) {
                  console.log("successfully set powerstate to: ON");
                }
              });
            }
          }
        });
      } else if (key.keyCode == 228) {
        console.log("___________DEEP_SLEEP_______________________F12");
        appApi.setPowerState("DEEP_SLEEP").then(() => {
          powerState = 'DEEP_SLEEP';
        });
        return true;
      } else if (key.keyCode === keyMap.AudioVolumeMute && !Router.isNavigating()) {
        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
          this.tag("Volume").onVolumeMute();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            this.tag("Volume").onVolumeMute();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeMute();
          }
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeUp && !Router.isNavigating()) {
        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
          this.tag("Volume").onVolumeKeyUp();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            this.tag("Volume").onVolumeKeyUp();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeKeyUp();
          }
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeDown && !Router.isNavigating()) {
        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
          this.tag("Volume").onVolumeKeyDown();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            this.tag("Volume").onVolumeKeyDown();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeKeyDown();
          }
        }
        return true;
      } else {
        return false;
      }
    }
    AvDecodernotificationcall() {
      thunder.on('org.rdk.DeviceDiagnostics', 'onAVDecoderStatusChanged', notification => {
        console.log(new Date().toISOString() + "AvDecoderStatusNotification: ", JSON.stringify(notification));
      });
    }
    async userInactivity() {
      PersistentStoreApi.get().activate().then(() => {
        PersistentStoreApi.get().getValue('ScreenSaverTime', 'timerValue').then(result => {
          // check if result has value property and if it is not undefined^M
          if (result && result.value && result.value !== undefined && result.value !== "Off") {
            console.log("App PersistentStoreApi screensaver timer value is: " + result.value);
            rdkShellApisInstance.enableInactivityReporting(true).then(() => {
              rdkShellApisInstance.setInactivityInterval(result.value).then(() => {
                this.userInactivity = thunder.on('org.rdk.RDKShell', 'onUserInactivity', notification => {
                  console.log("UserInactivityStatusNotification: ", JSON.stringify(notification));
                  appApi.getAvCodeStatus().then(result => {
                    console.log("Avdecoder", result.avDecoderStatus);
                    if ((result.avDecoderStatus === "IDLE" || result.avDecoderStatus === "PAUSE") && GLOBALS.topmostApp === "") {
                      this.$hideImage(1);
                    }
                  });
                });
              });
            });
          } else {
            console.warn("App PersistentStoreApi screensaver timer value is not set or is Off.");
            rdkShellApisInstance.enableInactivityReporting(false).then(() => {
              this.userInactivity.dispose();
            });
          }
        }).catch(err => {
          console.error("App PersistentStoreApi getValue error: " + JSON.stringify(err));
          rdkShellApisInstance.enableInactivityReporting(false).then(() => {
            this.userInactivity.dispose();
          });
        });
      }).catch(err => {
        console.error("App PersistentStoreApi activation error: " + JSON.stringify(err));
        reject(err);
      });
    }
    $hideImage(alpha) {
      if (alpha === 1) {
        this.tag("Widgets").visible = false;
        this.tag("Pages").visible = false;
      } else {
        this.tag("Widgets").visible = true;
        this.tag("Pages").visible = true;
      }
      this.tag("VideoScreen").alpha = alpha;
      // this.tag("ScreenSaver").alpha = alpha;
    }
    _init() {
      let self = this;
      self.appIdentifiers = {
        "YouTubeTV": "n:4",
        "YouTube": "n:3",
        "Netflix": "n:1",
        "Amazon Prime": "n:2",
        "Amazon": "n:2",
        "Prime": "n:2"
      };
      appApi.getPowerState().then(res => {
        GLOBALS.powerState = res.success ? res.powerState : "ON";
      });
      keyIntercept(GLOBALS.selfClientName).catch(err => {
        console.error("App _init keyIntercept err:", JSON.stringify(err));
      });
      this.userInactivity();
      FireBoltApi.get().deviceinfo.gettype();
      FireBoltApi.get().lifecycle.ready();
      FireBoltApi.get().lifecycle.registerEvent('foreground', value => {
        console.log("FireBoltApi[foreground] value:" + JSON.stringify(value) + ", launchResidentApp with:" + JSON.stringify(GLOBALS.selfClientName));
        // Ripple launches refui with this rdkshell client name.
        GLOBALS.topmostApp = GLOBALS.selfClientName;
        FireBoltApi.get().discovery.launch("refui", {
          "action": "home",
          "context": {
            "source": "device"
          }
        }).then(() => {
          AlexaApi.get().reportApplicationState("menu", true);
        });
      });
      FireBoltApi.get().lifecycle.registerEvent('background', value => {
        // Ripple changed app states; it will be a 'FireboltApp'
        GLOBALS.topmostApp = "FireboltApp";
        console.log("FireBoltApi[foreground] value:" + JSON.stringify(value) + ", Updating top app as:" + GLOBALS.topmostApp);
      });
      FireBoltApi.get().lifecycle.state().then(res => {
        console.log("Lifecycle.state result:" + res);
      });
      Keyboard$1.provide('xrn:firebolt:capability:input:keyboard', new KeyboardUIProvider(this));
      console.log("Keyboard provider registered");
      PinChallenge.provide('xrn:firebolt:capability:usergrant:pinchallenge', new PinChallengeProvider(this));
      console.log("PinChallenge provider registered");
      AcknowledgeChallenge.provide('xrn:firebolt:capability:usergrant:acknowledgechallenge', new AckChallengeProvider(this));
      console.log("Acknowledge challenge provider registered");
      appApi.deviceType().then(result => {
        console.log("App detected deviceType as:", result.devicetype != null ? result.devicetype : "tv");
        Storage$1.set("deviceType", result.devicetype != null ? result.devicetype : "tv");
      });
      thunder.Controller.activate({
        callsign: 'org.rdk.UserPreferences'
      }).then(result => {
        console.log("App UserPreferences plugin activation result: " + result);
      }).catch(err => {
        console.error("App UserPreferences plugin activation error: " + JSON.stringify(err));
        Metrics$3.error(Metrics$3.ErrorType.OTHER, 'PluginError', "Thunder Controller Activate error " + JSON.stringify(err), false, null);
      });
      thunder.Controller.activate({
        callsign: 'org.rdk.System'
      }).then(result => {
        console.log("App System plugin activation result: " + result);
        let rfc = "Device.DeviceInfo.X_RDKCENTRAL-COM_RFC.Feature.XDial.WolWakeEnable";
        let rfcList = {
          rfcList: [rfc]
        };
        appApi.getRFCConfig(rfcList).then(rfcStatus => {
          if ("success" in rfcStatus && rfcStatus.success) {
            if (rfc in rfcStatus.RFCConfig && rfcStatus.RFCConfig[rfc] === "true") {
              appApi.setNetworkStandbyMode().then(result => {
                if (!result.success) {
                  console.warn("App RFC setNetworkStandbyMode returned false; trying updated API.");
                  let param = {
                    wakeupSources: [{
                      "WAKEUPSRC_WIFI": true,
                      "WAKEUPSRC_IR": true,
                      "WAKEUPSRC_POWER_KEY": true,
                      "WAKEUPSRC_CEC": true,
                      "WAKEUPSRC_LAN": true
                    }]
                  };
                  appApi.setWakeupSrcConfiguration(param);
                }
              });
            } else {
              console.error("App RFC WolWakeEnable response:", JSON.stringify(rfcStatus));
              console.error("App RFC check of WolWakeEnable failed.");
            }
          }
        });
      }).catch(err => {
        console.error("App System plugin activation error: " + JSON.stringify(err));
      });
      appApi.getPluginStatus("org.rdk.DeviceDiagnostics").then(res => {
        console.log("App DeviceDiagnostics state:", res[0].state);
        if (res[0].state === "deactivated") {
          thunder.Controller.activate({
            callsign: 'org.rdk.DeviceDiagnostics'
          }).then(() => {
            this.AvDecodernotificationcall();
          }).catch(err => {
            console.error("App DeviceDiagnostics plugin activation error: " + JSON.stringify(err));
          });
        } else {
          this.AvDecodernotificationcall();
        }
      });
      appApi.getHDCPStatus().then(result => {
        Storage$1.set("UICacheonDisplayConnectionChanged", result.isConnected);
      });
      if (GLOBALS.topmostApp !== "HDMI") {
        //to default to hdmi, if previous input was hdmi
        GLOBALS.topmostApp = GLOBALS.selfClientName; //to set the application type to none
      }
      Storage$1.set("lastVisitedRoute", "menu"); //setting to menu so that it will be always defaulted to #menu
      appApi.enableDisplaySettings().then(res => {
        console.log("results : ".concat(JSON.stringify(res)));
      }).catch(err => {
        console.error("error while enabling displaysettings:" + JSON.stringify(err));
      });
      appApi.cobaltStateChangeEvent();
      this.xcastApi = new XcastApi();
      this.xcastApi.activate().then(result => {
        let serialNumber;
        try {
          appApi.getSerialNumber().then(res => {
            serialNumber = res;
            console.log("App getSerialNumber result:", serialNumber);
            appApi.getModelName().then(modelName => {
              let friendlyName = modelName + "_" + serialNumber;
              this.xcastApi.setFriendlyName(friendlyName).then(result => {
                console.log("App XCAST setFriendlyName result:", result);
              }).catch(error => {
                console.error("App Error setting friendlyName:", error);
              });
            }).catch(error => {
              console.error("App Error retrieving modelName:", error);
            });
          }).catch(error => {
            console.error("App Error getSerialNumber:", error);
          });
        } catch (error) {
          console.log(error);
        }
        if (result) {
          this.registerXcastListeners();
        }
      });
      thunder.on('Controller.1', 'all', noti => {
        console.log("App controller notification:", noti);
        if (noti.data.url && noti.data.url.slice(-5) === "#boot" || noti.data.httpstatus && noti.data.httpstatus != 200 && noti.data.httpstatus != -1) {
          // to exit metro apps by pressing back key & to auto exit webapp if httpstatus is not 200
          appApi.exitApp(GLOBALS.topmostApp);
        }
        // TODO: make the check based on XcastApi.supportedApps() list
        if (Object.prototype.hasOwnProperty.call(noti, "callsign") && (noti.callsign.startsWith("YouYube") || noti.callsign.startsWith("Amazon") || noti.callsign.startsWith("Netflix"))) {
          let params = {
            applicationName: noti.callsign,
            state: 'stopped'
          };
          switch (noti.data.state) {
            case "activated":
            case "resumed":
              params.state = 'running';
              break;
            case "Activation":
            case "deactivated":
            case "Deactivation":
              params.state = 'stopped';
              break;
            case "hibernated":
            case "suspended":
              params.state = 'suspended';
              break;
          }
          if (noti.callsign.startsWith("Amazon")) {
            params.applicationName = "AmazonInstantVideo";
          }
          console.log("App Controller state change to xcast: ", JSON.stringify(params));
          this.xcastApi.onApplicationStateChanged(params);
          params = null;
        }
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationActivated', data => {
        console.warn("[RDKSHELLEVT] onApplicationActivated:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationConnected', data => {
        console.warn("[RDKSHELLEVT] onApplicationConnected:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationDisconnected', data => {
        console.warn("[RDKSHELLEVT] onApplicationDisconnected:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationFirstFrame', data => {
        console.warn("[RDKSHELLEVT] onApplicationFirstFrame:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationLaunched', data => {
        console.warn("[RDKSHELLEVT] onApplicationLaunched:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationResumed', data => {
        console.warn("[RDKSHELLEVT] onApplicationResumed:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationSuspended', data => {
        console.warn("[RDKSHELLEVT] onApplicationSuspended:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationTerminated', data => {
        console.warn("[RDKSHELLEVT] onApplicationTerminated:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onHibernated', data => {
        console.warn("[RDKSHELLEVT] onHibernated:", data);
        if (data.success) {
          if (GLOBALS.topmostApp === data.client && (GLOBALS.selfClientName === "ResidentApp" || GLOBALS.selfClientName === "FireboltMainApp-refui")) {
            appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
              AlexaApi.get().reportApplicationState("menu", true);
            });
          }
        }
      });
      thunder.on('org.rdk.RDKShell', 'onRestored', data => {
        console.warn("[RDKSHELLEVT] onRestored:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onDestroyed', data => {
        console.warn("[RDKSHELLEVT] onDestroyed:", data);
        // No need to handle this when UI is in Firebolt compatible mode.
        if (GLOBALS.topmostApp === data.client && (GLOBALS.selfClientName === "ResidentApp" || GLOBALS.selfClientName === "FireboltMainApp-refui")) {
          appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
            AlexaApi.get().reportApplicationState("menu", true);
          });
        }
      });
      thunder.on('org.rdk.RDKShell', 'onLaunched', data => {
        console.warn("[RDKSHELLEVT] onLaunched:", data);
        if (data.launchType === "activate" || data.launchType === "resume") {
          // Change (Tracked TopMost) UI's visibility to false only for other apps.
          if (data.client != GLOBALS.selfClientName && (GLOBALS.topmostApp === "ResidentApp" || GLOBALS.topmostApp === GLOBALS.selfClientName)) {
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
          }
          if ((GLOBALS.topmostApp != "ResidentApp" || GLOBALS.topmostApp != GLOBALS.selfClientName) && GLOBALS.topmostApp != data.client) {
            appApi.suspendPremiumApp(GLOBALS.topmostApp);
          }
          // Assuming launch is followed by moveToFront & setFocus
          GLOBALS.topmostApp = data.client;
          AlexaApi.get().reportApplicationState(data.client);
        } else if (data.launchType === "suspend") {
          // No need to handle this here when UI is in Firebolt compatible mode.
          // It will be done at RefUI's 'foreground' event handler.
          if (GLOBALS.topmostApp === data.client && GLOBALS.selfClientName === "ResidentApp") {
            appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
              AlexaApi.get().reportApplicationState("menu", true);
            });
          }
        }
      });
      thunder.on('org.rdk.RDKShell', 'onSuspended', data => {
        console.warn("[RDKSHELLEVT] onSuspended:", data);
        // No need to handle this here when UI is in Firebolt compatible mode.
        if (GLOBALS.topmostApp === data.client && (GLOBALS.selfClientName === "ResidentApp" || GLOBALS.selfClientName === "FireboltMainApp-refui")) {
          appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
            AlexaApi.get().reportApplicationState("menu", true);
          });
        }
      });
      thunder.on('org.rdk.RDKShell', 'onWillDestroy', data => {
        console.warn("[RDKSHELLEVT] onWillDestroy:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onPluginSuspended', data => {
        console.warn("[RDKSHELLEVT] onPluginSuspended:", data);
        if (GLOBALS.topmostApp === data.client && (GLOBALS.selfClientName === "ResidentApp" || GLOBALS.selfClientName === "FireboltMainApp-refui")) {
          appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
            AlexaApi.get().reportApplicationState("menu", true);
          });
        }
      });
      thunder.on('org.rdk.RDKShell', 'onBlur', data => {
        console.warn("[RDKSHELLEVT] onBlur:", data);
      });
      thunder.on('org.rdk.RDKShell', 'onFocus', data => {
        console.warn("[RDKSHELLEVT] onFocus:", data);
      });
      appApi.getPluginStatus("Cobalt").then(() => {
        /* Loop through YouTube variants and set respective urls. */
        JSON.parse(JSON.stringify(appListInfo)).forEach(appInfo => {
          if (Object.prototype.hasOwnProperty.call(appInfo, "applicationType") && appInfo.applicationType.startsWith("YouTube") && Object.prototype.hasOwnProperty.call(appInfo, "uri") && appInfo.uri.length) {
            thunder.Controller.clone({
              callsign: "Cobalt",
              newcallsign: appInfo.applicationType
            }).then(result => {
              console.log("App Controller.clone Cobalt as " + appInfo.applicationType + " done.", result);
            }).catch(err => {
              console.error("App Controller clone Cobalt for " + appInfo.applicationType + " failed: ", err);
              Metrics$3.error(Metrics$3.ErrorType.OTHER, "PluginError", "Controller clone Cobalt for ".concat(appInfo.applicationType, " failed: ").concat(err), false, null);
              // TODO: hide YouTube Icon and listing from Menu, AppCarousel, Channel overlay and EPG page.
            });
            appApi.getPluginStatus(appInfo.applicationType).then(res => {
              if (res[0].state !== "deactivated") {
                thunder.Controller.deactivate({
                  callsign: appInfo.applicationType
                }).catch(err => {
                  console.error("App Controller.deactivate " + appInfo.applicationType + " failed. It may not work.", err);
                  Metrics$3.error(Metrics$3.ErrorType.OTHER, "pluginError", "App Controller.deactivate failed for ".concat(appInfo.applicationType, " with ").concat(err), false, null);
                });
              }
              /* Do not change YouTube's configuration as Page-visibility test runs on that. */
              if (res[0].callsign !== "YouTube") {
                thunder.call('Controller', "configuration@".concat(appInfo.applicationType)).then(result => {
                  /* Ensure appending '?' so that later params can be directly appended. */
                  result.url = appInfo.uri + "?"; // Make sure that appListInfo.js has only base url.
                  thunder.call('Controller', "configuration@".concat(appInfo.applicationType), result).then(() => {
                    Storage$1.set(appInfo.applicationType + "DefaultURL", appInfo.uri + "?"); // Make sure that appListInfo.js has only base url.
                  }).catch(err => {
                    console.error("App Controller.configuration@" + appInfo.applicationType + " set failed. It may not work." + JSON.stringify(err));
                    Metrics$3.error(Metrics$3.ErrorType.OTHER, "pluginError", "App Controller.configuration for ".concat(appInfo.applicationType, " set failed. It may not work. ").concat(JSON.stringify(err)), false, null);
                  });
                }).catch(err => {
                  console.error("App Controller.configuration@" + appInfo.applicationType + " get failed. It may not work." + JSON.stringify(err));
                  Metrics$3.error(Metrics$3.ErrorType.OTHER, "pluginError", "App Controller.configuration@ for ".concat(appInfo.applicationType, " failed with ").concat(JSON.stringify(err)), false, null);
                });
              } else {
                /* Just store the plugin configured url as default url and ensure '?' is appended. */
                Storage$1.set(appInfo.applicationType + "DefaultURL", res[0].configuration.url.includes('?') ? res[0].configuration.url : res[0].configuration.url + "?");
              }
            }).catch(err => {
              console.error("App getPluginStatus " + appInfo.applicationType + " Error: " + JSON.stringify(err));
            });
          }
        });
      }).catch(err => {
        console.error("App getPluginStatus Cobalt error: ", err);
      });
      //video info change events begin here---------------------

      thunder.on('org.rdk.tv.ControlSettings.1', 'videoFormatChanged', notification => {
        console.log("videoFormatChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New videoFormat :  " + notification.currentVideoFormat, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New videoFormat :  " + notification.currentVideoFormat);
        }
      });
      thunder.on('org.rdk.tv.ControlSettings.1', 'videoFrameRateChanged', notification => {
        console.log("videoFrameRateChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New videoFrameRate :  " + notification.currentVideoFrameRate, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New videoFrameRate :  " + notification.currentVideoFrameRate);
        }
      });
      thunder.on('org.rdk.tv.ControlSettings.1', 'videoResolutionChanged', notification => {
        console.log("videoResolutionChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New video resolution :  " + notification.currentVideoFormat, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New video resolution :  " + notification.currentVideoFormat);
        }
      });
      thunder.on('Controller', 'statechange', notification => {
        // get plugin status
        console.log("Controller statechange Notification : " + JSON.stringify(notification));
        if (notification && (notification.callsign.startsWith("YouTube") || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && (notification.state == 'Deactivation' || notification.state == 'Deactivated')) {
          console.log("".concat(notification.callsign, " status = ").concat(notification.state));
          console.log(">>notification.callsign: ", notification.callsign, " applicationType: ", GLOBALS.topmostApp);
          if (Router.getActiveHash().startsWith("tv-overlay") || Router.getActiveHash().startsWith("overlay") || Router.getActiveHash().startsWith("applauncher")) {
            //navigate to last visited route when exiting from any app
            console.log("navigating to lastVisitedRoute");
            Router.navigate(Storage$1.get("lastVisitedRoute"));
          }
          if (notification.callsign === GLOBALS.topmostApp) {
            //only launch residentApp iff notification is from currentApp
            console.log(notification.callsign + " is in: " + notification.state + " state, and application type in Storage is still: " + GLOBALS.topmostApp + " calling launchResidentApp");
            appApi.launchResidentApp(GLOBALS.selfClientName, GLOBALS.selfClientName).then(() => {
              AlexaApi.get().reportApplicationState("menu", true);
            });
          }
        }
        if (notification && notification.callsign === 'org.rdk.HdmiCecSource' && notification.state === 'Activated') {
          this.advanceScreen = Router.activePage();
          if (typeof this.advanceScreen.performOTPAction === 'function') {
            console.log('otp action');
            this.advanceScreen.performOTPAction();
          }
        }
        if (notification && (notification.callsign.startsWith("YouTube") || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && notification.state == 'Activated') {
          GLOBALS.topmostApp = notification.callsign; //required in case app launch happens using curl command.
          if (notification.callsign === 'Netflix') {
            appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
            });
            thunder.on('Netflix', 'notifyeventchange', notification => {
              console.log("NETFLIX : notifyEventChange notification = ", JSON.stringify(notification));
              if (notification.EventName === "rendered") {
                Router.navigate('menu');
                if (Storage$1.get("NFRStatus")) {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "enable"
                  }).then(nr => {
                    console.log("Netflix : nfr enable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                } else {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "disable"
                  }).then(nr => {
                    console.log("Netflix : nfr disable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                }
                rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
              }
              if (notification.EventName === "requestsuspend") {
                this.deactivateChildApp('Netflix');
              }
              if (notification.EventName === "updated") {
                console.log("Netflix : xxxxxxxxxxxxxxxxxx Updated Event Trigger xxxxxxxxxxxxxxxxxxxx");
                appApi.getNetflixESN().then(res => {
                  Storage$1.set('Netflix_ESN', res);
                });
              }
            });
          } else {
            rdkShellApisInstance.setFocus(notification.callsign); //required in case app launch happens using curl command.
          }
        }
      });

      /********************   RDKUI-341 CHANGES - DEEP SLEEP/LIGHT SLEEP **************************/

      let cachedPowerState = Storage$1.get('SLEEPING');
      console.log('cached power state', cachedPowerState);
      console.log(typeof cachedPowerState);
      if (cachedPowerState) {
        appApi.getWakeupReason().then(result => {
          if (result.result.wakeupReason !== 'WAKEUP_REASON_UNKNOWN') {
            cachedPowerState = 'ON';
          }
        });
        appApi.setPowerState(cachedPowerState).then(result => {
          if (result.success) {
            console.log("successfully set powerstate to: " + cachedPowerState);
          }
        });
      }

      /********************   RDKUI-303 - PAGE VISIBILITY API **************************/

      //ACTIVATING HDMI CEC PLUGIN
      cecApi.activate().then(() => {
        let getfriendlyname, getosdname;
        setTimeout(() => {
          xcastApi.getFriendlyName().then(res => {
            getfriendlyname = res.friendlyname;
            console.log("XcastApi getFriendlyName :" + getfriendlyname);
          }).catch(err => {
            console.error('XcastApi getFriendlyName Error: ', err);
          });
          cecApi.getOSDName().then(result => {
            getosdname = result.name;
            console.log("CECApi getOSDName :" + getosdname);
            if (getfriendlyname !== getosdname) {
              cecApi.setOSDName(getfriendlyname);
            }
          }).catch(err => {
            console.error('CECApi getOSDName Error :', err);
          });
        }, 5000);
        cecApi.getActiveSourceStatus().then(res => {
          Storage$1.set("UICacheCECActiveSourceStatus", res);
          console.log("App getActiveSourceStatus: " + res + " UICacheCECActiveSourceStatus:" + Storage$1.get("UICacheCECActiveSourceStatus"));
        });
      }).catch(err => console.log(err));

      //UNPLUG/PLUG HDMI

      thunder.on("org.rdk.HdcpProfile", "onDisplayConnectionChanged", notification => {
        console.log(new Date().toISOString() + " onDisplayConnectionChanged ", notification.HDCPStatus);
        let temp = notification.HDCPStatus;
        if (!Storage$1.get("ResolutionChangeInProgress") && temp.isConnected != Storage$1.get("UICacheonDisplayConnectionChanged")) {
          if (temp.isConnected) {
            let currentApp = GLOBALS.topmostApp;
            let launchLocation = Storage$1.get(currentApp + "LaunchLocation");
            console.log("App HdcpProfile onDisplayConnectionChanged current app is:", currentApp);
            let params = {
              launchLocation: launchLocation,
              appIdentifier: self.appIdentifiers[currentApp]
            };
            if (currentApp.startsWith("YouTube")) {
              params["url"] = Storage$1.get(currentApp + "DefaultURL");
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state === (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.launchApp(currentApp, params).catch(err => {
                    console.error("Error in launching ".concat(currentApp, " : ") + JSON.stringify(err));
                  });
                } else {
                  console.log("App HdcpProfile onDisplayConnectionChanged skipping; " + currentApp + " is already: ", JSON.stringify(result[0].state));
                }
              });
            }
          } else {
            let currentApp = GLOBALS.topmostApp;
            if (currentApp.startsWith("YouTube")) {
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state !== (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.exitApp(currentApp, true);
                } else {
                  console.log("App HdcpProfile onDisplayConnectionChanged skipping; " + currentApp + " is already: ", JSON.stringify(result[0].state));
                }
              });
            }
          }
          Storage$1.set("UICacheonDisplayConnectionChanged", temp.isConnected);
        } else {
          console.warn("App HdcpProfile onDisplayConnectionChanged discarding.");
          console.log("App HdcpProfile ResolutionChangeInProgress: " + Storage$1.get("ResolutionChangeInProgress") + " UICacheonDisplayConnectionChanged: " + Storage$1.get("UICacheonDisplayConnectionChanged"));
        }
      });

      //CHANGING HDMI INPUT PORT

      thunder.on("org.rdk.HdmiCecSource", "onActiveSourceStatusUpdated", notification => {
        console.log(new Date().toISOString() + " onActiveSourceStatusUpdated ", notification);
        if (notification.status != Storage$1.get("UICacheCECActiveSourceStatus")) {
          if (notification.status) {
            let currentApp = GLOBALS.topmostApp;
            let launchLocation = Storage$1.get(currentApp + "LaunchLocation");
            console.log("current app is ", currentApp);
            let params = {
              launchLocation: launchLocation,
              appIdentifier: self.appIdentifiers[currentApp]
            };
            if (currentApp.startsWith("YouTube")) {
              params["url"] = Storage$1.get(currentApp + "DefaultURL");
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state === (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.launchApp(currentApp, params).catch(err => {
                    console.error("Error in launching ".concat(currentApp, " : ") + JSON.stringify(err));
                  });
                } else {
                  console.log("App HdmiCecSource onActiveSourceStatusUpdated skipping; " + currentApp + " is already:", JSON.stringify(result[0].state));
                }
              });
            }
          } else {
            let currentApp = GLOBALS.topmostApp;
            if (currentApp.startsWith("YouTube")) {
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state !== (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.exitApp(currentApp, true);
                } else {
                  console.log("App HdmiCecSource onActiveSourceStatusUpdated skipping; " + currentApp + " is already:", JSON.stringify(result[0].state));
                }
              });
            }
          }
          Storage$1.set("UICacheCECActiveSourceStatus", notification.status);
          console.log("App HdmiCecSource onActiveSourceStatusUpdated UICacheCECActiveSourceStatus:", Storage$1.get("UICacheCECActiveSourceStatus"));
        } else {
          console.warn("App HdmiCecSource onActiveSourceStatusUpdated discarding.");
        }
      });
      //need to verify
      if ("ResidentApp" === GLOBALS.selfClientName) {
        if (Language$1.get().length) {
          appApi.setUILanguage(availableLanguageCodes[Language$1.get()]);
          localStorage.setItem('Language', Language$1.get());
        }
      } else {
        FireBoltApi.get().localization.language().then(lang => {
          if (lang) {
            FireBoltApi.get().localization.language(lang).then(res => console.log("language ".concat(lang, " set succesfully")));
            localStorage.setItem('Language', lang);
          }
        });
      }
    }
    _firstEnable() {
      thunder.on("org.rdk.System", "onSystemPowerStateChanged", notification => {
        console.log(new Date().toISOString() + " onSystemPowerStateChanged Notification: ", notification);
        appApi.getPowerState().then(res => {
          GLOBALS.powerState = res.success ? res.powerState : notification.powerState;
        }).catch(e => GLOBALS.powerState = notification.powerState);
        if (notification.powerState !== "ON" && notification.currentPowerState === "ON") {
          console.log("onSystemPowerStateChanged Notification: power state was changed from ON to " + notification.powerState);

          //TURNING OFF THE DEVICE
          Storage$1.set('SLEEPING', notification.powerState);
          let currentApp = GLOBALS.topmostApp;
          if (currentApp !== "") {
            appApi.exitApp(currentApp); //will suspend/destroy the app depending on the setting.
          }
          Router.navigate('menu');
        } else if (notification.powerState === "ON" && notification.currentPowerState !== "ON") {
          //TURNING ON THE DEVICE
          Storage$1.remove('SLEEPING');
        }
      });
      console.log("App Calling listenToVoiceControl method to activate VoiceControl Plugin");
      this.listenToVoiceControl();
      // need to verify
      if ("ResidentApp" === GLOBALS.selfClientName) {
        if (availableLanguageCodes[Language$1.get()].length) {
          appApi.setUILanguage(availableLanguageCodes[Language$1.get()]);
          localStorage.setItem('Language', Language$1.get());
        }
      } else {
        FireBoltApi.get().localization.language().then(lang => {
          if (lang) {
            FireBoltApi.get().localization.language(lang).then("language ".concat(lang, " set succesfully"));
          }
        });
      }
      /* Subscribe to Volume status events to report to Alexa. */
      thunder.on('org.rdk.DisplaySettings', 'connectedAudioPortUpdated', notification => {
        console.log("App got connectedAudioPortUpdated: ", notification);
        // TODO: future -> can be used for volume adjustments ?
      });
      thunder.on('org.rdk.DisplaySettings', 'muteStatusChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().reportVolumeState(undefined, notification.muted);
        }
      });
      thunder.on('org.rdk.DisplaySettings', 'volumeLevelChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().reportVolumeState(notification.volumeLevel, undefined);
        }
      });
      thunder.on('org.rdk.System', 'onTimeZoneDSTChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().updateDeviceTimeZoneInAlexa(notification.newTimeZone);
        }
      });
    }
    async listenToVoiceControl() {
      let self = this;
      console.log("App listenToVoiceControl method got called, configuring VoiceControl Plugin");
      await voiceApi.activate().then(() => {
        voiceApi.voiceStatus().then(voiceStatusResp => {
          if (voiceStatusResp.ptt.status != "ready" || !voiceStatusResp.urlPtt.includes("avs://")) {
            console.error("App voiceStatus says PTT/AVS not ready, enabling it.");
            // TODO: Future -> add option for user to select which Voice service provider.
            // Then configure VoiceControl plugin for that end point.
            // TODO: voiceApi.configureVoice()
            if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
              AlexaApi.get().setAlexaAuthStatus("");
              voiceApi.configureVoice({
                "enable": true
              }).then(() => {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
              });
            }
          }
        });
        if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaAuthPending") {
          /* AVS SDK might be awaiting a ping packet to start. */
          AlexaApi.get().pingAlexaSDK();
        } else if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError") {
          console.log("App checkAlexaAuthStatus is AlexaHandleError; enableSmartScreen.");
          AlexaApi.get().enableSmartScreen();
          AlexaApi.get().getAlexaDeviceSettings();
          /* Alexa device volume state report. */
          appApi.getConnectedAudioPorts().then(audioport => {
            for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
              if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                appApi.getMuted(audioport.connectedAudioPorts[i]).then(muteRes => {
                  appApi.getVolumeLevel(audioport.connectedAudioPorts[i]).then(volres => {
                    AlexaApi.get().reportVolumeState(volres.success ? Number.isInteger(volres.volumeLevel) ? volres.volumeLevel : parseInt(volres.volumeLevel) : undefined, muteRes.success ? muteRes.muted : undefined);
                  });
                });
              }
            }
          });

          /* Report device language */
          if (availableLanguageCodes[Language$1.get()].length) {
            AlexaApi.get().updateDeviceLanguageInAlexa(availableLanguageCodes[Language$1.get()]);
          }
          /* Report device timeZone */
          if ("ResidentApp" === GLOBALS.selfClientName) {
            appApi.getZone().then(timezone => {
              this.updateAlexaTimeZone(timezone);
            });
          } else {
            FireBoltApi.get().localization.getTimeZone().then(timezone => {
              this.updateAlexaTimeZone(timezone);
            });
          }
        }
        console.log("App VoiceControl check if user has denied ALEXA:" + JSON.stringify(AlexaApi.get().checkAlexaAuthStatus()));

        /* Handle VoiceControl Notifications */
        voiceApi.registerEvent('onServerMessage', notification => {
          console.log('App onServerMessage: ' + JSON.stringify(notification));
          if (Storage$1.get("appSwitchingInProgress")) {
            console.warn("App is appSwitchingInProgress? " + Storage$1.get("appSwitchingInProgress") + ", dropping processing the server notification.");
            return;
          }
          if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
            if (notification.xr_speech_avs.state_reporter === "authorization_req" || notification.xr_speech_avs.code) {
              console.log("Alexa Auth URL is ", notification.xr_speech_avs.url);
              if (!Router.isNavigating() && !AlexaApi.get().isSmartScreenActiavated() && Router.getActiveHash() === "menu") {
                console.log("App enableSmartScreen");
                AlexaApi.get().enableSmartScreen();
              }
              if (Router.getActiveHash() === "menu" && GLOBALS.topmostApp === GLOBALS.selfClientName) {
                if (Router.getActiveHash() != "AlexaLoginScreen" && Router.getActiveHash() != "CodeScreen" && !Router.isNavigating()) {
                  console.log("Routing to Alexa login page");
                  Router.navigate("AlexaLoginScreen");
                }
              }
              console.log("Alexa Auth OTP is ", notification.xr_speech_avs.code);
            } else if (notification.xr_speech_avs.state_reporter === "authendication") {
              console.log("Alexa Auth State is now at ", notification.xr_speech_avs.state);
              if (notification.xr_speech_avs.state === "refreshed") {
                AlexaApi.get().setAlexaAuthStatus("AlexaHandleError");
                Router.navigate("SuccessScreen");
              } else if (notification.xr_speech_avs.state === "uninitialized" || notification.xr_speech_avs.state === "authorizing") {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
              } else if (notification.xr_speech_avs.state === "unrecoverable error" && GLOBALS.topmostApp === GLOBALS.selfClientName) {
                // Could be AUTH token Timeout; refresh it.
                if (Storage$1.get("setup") === true) {
                  Router.navigate("FailureScreen");
                } else {
                  Storage$1.set("alexaOTPReset", true);
                }
              }
            } else if (notification.xr_speech_avs.state_reporter === "login" && notification.xr_speech_avs.state === "User request to disable Alexa") {
              // https://jira.rdkcentral.com/jira/browse/RDKDEV-746: SDK abstraction layer sends on SKIP button event.
              AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied");
            }
          }
          if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError" && (notification.xr_speech_avs.state === "CONNECTING" || notification.xr_speech_avs.state === "DISCONNECTED")) {
            // || notification.xr_speech_avs.state === "CONNECTED"
            this.tag("Failscreen1").alpha = 1;
            this.tag("Widgets").visible = false;
            this.tag("Pages").visible = false;
            this.tag("Failscreen1").notify({
              title: 'Alexa State',
              msg: notification.xr_speech_avs.state
            });
            setTimeout(() => {
              this.tag("Failscreen1").alpha = 0;
              this.tag("Widgets").visible = true;
              this.tag("Pages").visible = true;
            }, 5000);
          }
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied" && notification.xr_speech_avs.state) {
            if (notification.xr_speech_avs.state.guiAPL === "ACTIVATED") {
              AlexaApi.get().displaySmartScreenOverlay();
              rdkShellApisInstance.setFocus(GLOBALS.topmostApp === "" ? GLOBALS.selfClientName : GLOBALS.topmostApp);
            }
            if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio === "stopped") {
              console.log("App current AlexaAudioplayerActive state:" + AlexaAudioplayerActive);
              if (AlexaAudioplayerActive && notification.xr_speech_avs.state.guiManager === "DEACTIVATED" || !AlexaAudioplayerActive) {
                AlexaAudioplayerActive = false;
                rdkShellApisInstance.setFocus(GLOBALS.topmostApp === "" ? GLOBALS.selfClientName : GLOBALS.topmostApp);
              }
            }
            if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio === "playing") {
              AlexaApi.get().displaySmartScreenOverlay(true);
            } else if (notification.xr_speech_avs.state.dialogUX === "listening") {
              AlexaApi.get().displaySmartScreenOverlay();
            } else if (notification.xr_speech_avs.state.dialogUX === "speaking") {
              AlexaApi.get().displaySmartScreenOverlay(true);
            }
            if (notification.xr_speech_avs.state_reporter === "dialog") {
              // Smartscreen playback state reports
              if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio) {
                AlexaApi.get().setAlexaSmartscreenAudioPlaybackState(notification.xr_speech_avs.state.audio);
              }
            }
          }
          if (notification.xr_speech_avs.directive && AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
            const header = notification.xr_speech_avs.directive.header;
            const payload = notification.xr_speech_avs.directive.payload;
            /////////Alexa.Launcher START
            if (header.namespace === "Alexa.Launcher") {
              //Alexa.launcher will handle launching a particular app(exiting might also be there)
              if (header.name === "LaunchTarget") {
                //Alexa payload will be to "launch" an app
                if (AlexaLauncherKeyMap[payload.identifier]) {
                  let appCallsign = AlexaLauncherKeyMap[payload.identifier].callsign;
                  let appUrl = AlexaLauncherKeyMap[payload.identifier].url; //keymap url will be default, if alexa can give a url, it can be used istead
                  let targetRoute = AlexaLauncherKeyMap[payload.identifier].route;
                  let params = {
                    url: appUrl,
                    launchLocation: "alexa",
                    appIdentifier: self.appIdentifiers[appCallsign]
                  };
                  // Send AVS State report: STOP request if "playing" to end the Smartscreen App instance.
                  if (AlexaApi.get().checkAlexaSmartscreenAudioPlaybackState() == "playing") {
                    console.log("Sending playbackstatereport to Pause:", PlaybackStateReport);
                    AlexaApi.get().reportPlaybackState("PAUSED");
                  }
                  console.log("Alexa is trying to launch " + appCallsign + " using params: " + JSON.stringify(params));
                  if (appCallsign) {
                    //appCallsign is valid means target is an app and it needs to be launched
                    appApi.launchApp(appCallsign, params).catch(err => {
                      console.log("Alexa.Launcher LaunchTarget checkerrstatusAlexa", err);
                      if (err.includes("Netflix")) {
                        AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive, "INVALID_VALUE", "Unsupported AppID");
                      } else {
                        AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive);
                      }
                      console.error("Alexa.Launcher LaunchTarget Error in launching " + appCallsign + " via Alexa: " + JSON.stringify(err));
                    });
                  } else if (targetRoute) {
                    console.log("Alexa.Launcher is trying to route to ", JSON.stringify(targetRoute));
                    // exits the app if any and navigates to the specific route.
                    Storage$1.set("appSwitchingInProgress", true);
                    this.jumpToRoute(targetRoute);
                    GLOBALS.topmostApp = GLOBALS.selfClientName;
                    Storage$1.set("appSwitchingInProgress", false);
                  }
                } else {
                  console.log("Alexa.Launcher is trying to launch an unsupported app : " + JSON.stringify(payload));
                  AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive);
                }
              }
            } /////////Alexa.Launcher END
            else if (header.namespace === "Alexa.RemoteVideoPlayer") {
              //alexa remote video player will search on youtube for now
              console.log("Alexa.RemoteVideoPlayer: " + JSON.stringify(header));
              if (header.name === "SearchAndDisplayResults" || header.name === "SearchAndPlay") {
                console.log("Alexa.RemoteVideoPlayer: SearchAndDisplayResults || SearchAndPlay: " + JSON.stringify(header));
                /* Find if payload contains Destination App */
                if (Object.prototype.hasOwnProperty.call(payload, "entities")) {
                  let entityId = payload.entities.filter(obj => Object.keys(obj).some(key => Object.prototype.hasOwnProperty.call(obj[key], "ENTITY_ID")));
                  if (entityId.length && AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID]) {
                    /* ENTITY_ID or vsk key found; meaning Target App is there in response. */
                    let replacedText = payload.searchText.transcribed.replace(entityId[0].value.toLowerCase(), "").trim();
                    let appCallsign = AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID].callsign;
                    //let appUrl = AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID].url
                    let launchParams = {
                      url: "",
                      launchLocation: "alexa",
                      appIdentifier: self.appIdentifiers[appCallsign]
                    };
                    if ("Netflix" === appCallsign) {
                      launchParams.url = encodeURI(replacedText);
                    } else if (appCallsign.startsWith("YouTube")) {
                      launchParams.url = Storage$1.get(appCallsign + "DefaultURL") + "&va=" + (header.name === "SearchAndPlay" ? "play" : "search") + "&vq=" + encodeURI(replacedText);
                    }
                    console.log("Alexa.RemoteVideoPlayer: launchApp " + appCallsign + " with params " + launchParams);
                    appApi.launchApp(appCallsign, launchParams).then(res => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launched successfully using alexa search: " + JSON.stringify(res));
                    }).catch(err => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launch FAILED using alexa search: " + JSON.stringify(err));
                    });
                    replacedText = null;
                    appCallsign = null;
                    launchParams = null;
                  } else if (!entityId.length && GLOBALS.topmostApp != GLOBALS.selfClientName) {
                    /* give it to current focused app */
                    console.warn("Alexa.RemoteVideoPlayer: " + GLOBALS.topmostApp + " is the focued app; need Voice search integration support to it.");
                  } else if (!entityId.length && GLOBALS.topmostApp == GLOBALS.selfClientName) {
                    /* Generic global search without a target app; redirect to Youtube as of now. */
                    let replacedText = payload.searchText.transcribed.trim();
                    let appCallsign = AlexaLauncherKeyMap["amzn1.alexa-ask-target.app.70045"].callsign;
                    let launchParams = {
                      url: "",
                      launchLocation: "alexa",
                      appIdentifier: self.appIdentifiers[appCallsign]
                    };
                    launchParams.url = Storage$1.get(appCallsign + "DefaultURL") + "&va=" + (header.name === "SearchAndPlay" ? "play" : "search") + "&vq=" + encodeURI(replacedText);
                    console.log("Alexa.RemoteVideoPlayer: global search launchApp " + appCallsign + " with params " + launchParams);
                    appApi.launchApp(appCallsign, launchParams).then(res => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launched successfully using alexa search: " + JSON.stringify(res));
                    }).catch(err => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launch FAILED using alexa search: " + JSON.stringify(err));
                    });
                    replacedText = null;
                    appCallsign = null;
                    launchParams = null;
                  } else {
                    /* Possibly an unsupported App. */
                    console.warn("Alexa.RemoteVideoPlayer: got ENTITY_ID " + entityId[0].externalIds.ENTITY_ID + "but no match in AlexaLauncherKeyMap.");
                  }
                } else {
                  console.warn("Alexa.RemoteVideoPlayer: payload does not have entities; may not work.");
                }
              }
            } else if (header.namespace === "Alexa.PlaybackController") {
              appApi.deeplinkToApp(GLOBALS.topmostApp, header.name, "alexa", header.namespace);
              AlexaApi.get().reportPlaybackState(header.name);
            } else if (header.namespace === "Alexa.SeekController") {
              if (Router.getActiveHash() === "player" || Router.getActiveHash() === "usb/player") {
                let time = notification.xr_speech_avs.directive.payload.deltaPositionMilliseconds / 1000;
                this.tag("AAMPVideoPlayer").voiceSeek(time);
              } else {
                appApi.deeplinkToApp(GLOBALS.topmostApp, payload, "alexa", header.namespace);
              }
            } else if (header.namespace === "AudioPlayer") {
              if (header.name === "Play") {
                AlexaApi.get().displaySmartScreenOverlay(true);
                AlexaAudioplayerActive = true;
                console.log("App AudioPlayer: Suspending the current app:'" + GLOBALS.topmostApp + "'");
                if (GLOBALS.topmostApp != GLOBALS.selfClientName) {
                  appApi.exitApp(GLOBALS.topmostApp);
                }
              }
            } else if (header.namespace === "TemplateRuntime") {
              if (header.name === "RenderPlayerInfo") {
                AlexaApi.get().displaySmartScreenOverlay(true);
                AlexaAudioplayerActive = true;
              }
            } else if (header.namespace === "Speaker") {
              console.log("Speaker");
              if (header.name === "AdjustVolume") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                appApi.getConnectedAudioPorts().then(audioport => {
                  for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
                    if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                      appApi.getVolumeLevel(audioport.connectedAudioPorts[i]).then(volres => {
                        console.log("getVolumeLevel[" + audioport.connectedAudioPorts[i] + "] is:" + parseInt(volres.volumeLevel));
                        if (parseInt(volres.volumeLevel) >= 0 || parseInt(volres.volumeLevel) <= 100) {
                          VolumePayload.msgPayload.event.payload.volume = parseInt(volres.volumeLevel) + payload.volume;
                          console.log("volumepayload", VolumePayload.msgPayload.event.payload.volume);
                          if (VolumePayload.msgPayload.event.payload.volume < 0) {
                            VolumePayload.msgPayload.event.payload.volume = 0;
                          } else if (VolumePayload.msgPayload.event.payload.volume > 100) {
                            VolumePayload.msgPayload.event.payload.volume = 100;
                          }
                        }
                        appApi.setVolumeLevel(audioport.connectedAudioPorts[i], VolumePayload.msgPayload.event.payload.volume).then(() => {
                          let volumeIncremented = parseInt(volres.volumeLevel) < VolumePayload.msgPayload.event.payload.volume ? true : false;
                          if (volumeIncremented && VolumePayload.msgPayload.event.payload.muted) {
                            VolumePayload.msgPayload.event.payload.muted = false;
                          }
                          if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
                            this.tag("Volume").onVolumeChanged(volumeIncremented);
                          } else {
                            if (Router.getActiveHash() === "applauncher") {
                              rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                              rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                              this.tag("Volume").onVolumeChanged(volumeIncremented);
                            } else {
                              rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                              rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                              Router.navigate("applauncher");
                              this.tag("Volume").onVolumeChanged(volumeIncremented);
                            }
                          }
                        });
                      });
                    }
                  }
                });
              }
              if (header.name === "SetVolume") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                VolumePayload.msgPayload.event.payload.volume = payload.volume;
                console.log("adjust volume", VolumePayload);
                console.log("checkvolume", VolumePayload.msgPayload.event.payload.volume);
                if (VolumePayload.msgPayload.event.payload.volume > 100) {
                  VolumePayload.msgPayload.event.payload.volume = 100;
                } else if (VolumePayload.msgPayload.event.payload.volume < 0) {
                  VolumePayload.msgPayload.event.payload.volume = 0;
                }
                appApi.getConnectedAudioPorts().then(audioport => {
                  for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
                    if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                      let volumeIncremented;
                      appApi.getVolumeLevel(audioport.connectedAudioPorts[i]).then(volres => {
                        volumeIncremented = parseInt(volres.volumeLevel) < VolumePayload.msgPayload.event.payload.volume ? true : false;
                        if (volumeIncremented && VolumePayload.msgPayload.event.payload.muted) {
                          VolumePayload.msgPayload.event.payload.muted = false;
                        }
                      });
                      appApi.setVolumeLevel(audioport.connectedAudioPorts[i], VolumePayload.msgPayload.event.payload.volume).then(() => {
                        if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
                          this.tag("Volume").onVolumeChanged(volumeIncremented);
                        } else {
                          if (Router.getActiveHash() === "applauncher") {
                            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                            this.tag("Volume").onVolumeChanged(volumeIncremented);
                          } else {
                            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                            Router.navigate("applauncher");
                            this.tag("Volume").onVolumeChanged(volumeIncremented);
                          }
                        }
                      });
                    }
                  }
                });
              }
              if (header.name === "SetMute") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                VolumePayload.msgPayload.event.payload.volume = payload.volume;
                VolumePayload.msgPayload.event.payload.muted = payload.mute;
                if (GLOBALS.topmostApp === GLOBALS.selfClientName) {
                  this.tag("Volume").onVolumeMute(payload.mute);
                } else {
                  if (Router.getActiveHash() === "applauncher") {
                    rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                    rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                    this.tag("Volume").onVolumeMute(payload.mute);
                  } else {
                    rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
                    rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
                    Router.navigate("applauncher");
                    this.tag("Volume").onVolumeMute(payload.mute);
                  }
                }
              }
            } else if (header.namespace === "ExternalMediaPlayer") {
              appApi.deeplinkToApp(GLOBALS.topmostApp, payload, "alexa", header.namespace);
            }
          }
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied" && notification.xr_speech_avs.deviceSettings) {
            let updatedLanguage = availableLanguageCodes[Language$1.get()];
            if (notification.xr_speech_avs.deviceSettings.currentLocale.toString() != updatedLanguage) {
              /* Get Alexa matching Locale String */
              for (let i = 0; i < notification.xr_speech_avs.deviceSettings.supportedLocales.length; i++) {
                if (updatedLanguage === notification.xr_speech_avs.deviceSettings.supportedLocales[i].toString()) {
                  AlexaApi.get().updateDeviceLanguageInAlexa(updatedLanguage);
                }
              }
            }
          }
        });
        voiceApi.registerEvent('onSessionBegin', () => {
          this.$hideImage(0);
        });
        voiceApi.registerEvent('onSessionEnd', notification => {
          if (notification.result === "success" && notification.success.transcription === "User request to disable Alexa") {
            console.warn("App VoiceControl.onSessionEnd got disable Alexa.");
            AlexaApi.get().resetAVSCredentials(); // To avoid Audio Feedback
            AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied"); // Reset back to disabled as resetAVSCredentials() sets to ErrorHandling.
          }
        });
      }).catch(err => {
        console.error("App VoiceControl Plugin activation error:", err);
      });
    }
    updateAlexaTimeZone(updatedTimeZone) {
      if (updatedTimeZone.length) {
        console.log("App updateDeviceTimeZoneInAlexa with zone:", updatedTimeZone);
        AlexaApi.get().updateDeviceTimeZoneInAlexa(updatedTimeZone);
      } else {
        console.error("App getTimezoneDST returned:", updatedTimeZone);
      }
    }
    deactivateChildApp(plugin) {
      //#needToBeRemoved
      switch (plugin) {
        case 'WebApp':
          appApi.deactivateWeb();
          break;
        case 'YouTube':
          appApi.suspendPremiumApp("YouTube").then(() => {
            console.log("YouTube : suspend YouTube request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'YouTubeTV':
          appApi.suspendPremiumApp("YouTubeTV").then(() => {
            console.log("YouTubeTV : suspend YouTubeTV request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'Lightning':
          appApi.deactivateLightning();
          break;
        case 'Native':
          appApi.killNative();
          break;
        case 'Amazon':
          appApi.suspendPremiumApp('Amazon').then(res => {
            if (res) {
              let params = {
                applicationName: "AmazonInstantVideo",
                state: 'suspended'
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case "Netflix":
          appApi.suspendPremiumApp("Netflix").then(res => {
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            rdkShellApisInstance.setFocus(GLOBALS.selfClientName);
            rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, true);
            rdkShellApisInstance.moveToFront(GLOBALS.selfClientName);
            if (res) {
              let params = {
                applicationName: "NetflixApp",
                state: "suspended"
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case 'HDMI':
          new HDMIApi().stopHDMIInput();
          Storage$1.set("_currentInputMode", {});
          break;
      }
    }
    $initLaunchPad(url) {
      return new Promise((resolve, reject) => {
        appApi.getPluginStatus('Netflix').then(result => {
          console.log("netflix plugin status is :", JSON.stringify(result));
          console.log("netflix plugin status is :", result);
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            Router.navigate('image', {
              src: Utils.asset('images/apps/App_Netflix_Splash.png')
            });
            if (url) {
              appApi.configureApplication('Netflix', url).then(() => {
                appApi.launchPremiumApp("Netflix").then(() => {
                  rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
                  resolve(true);
                }).catch(() => {
                  reject(false);
                }); // ie. org.rdk.RDKShell.launch
              }).catch(err => {
                console.error("Netflix : error while fetching configuration data : ", JSON.stringify(err));
                reject(err);
              }); // gets configuration object and sets configuration
            } else {
              appApi.launchPremiumApp("Netflix").then(() => {
                rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
                resolve(true);
              }).catch(() => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            }
          } else {
            /* Not in deactivated; could be suspended */
            if (url) {
              appApi.launchPremiumApp("Netflix").then(() => {
                thunder.call("Netflix", "systemcommand", {
                  "command": url
                }).then(() => {}).catch(err => {
                  console.error("Netflix : error while sending systemcommand : ", JSON.stringify(err));
                  Metrics$3.error(Metrics$3.ErrorType.OTHER, 'AppError', "Netflix : error while sending systemcommand : ".concat(JSON.stringify(err)), false, null);
                  reject(false);
                });
                rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
                resolve(true);
              }).catch(() => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            } else {
              appApi.launchPremiumApp("Netflix").then(res => {
                console.log("Netflix : launch premium app resulted in ", JSON.stringify(res));
                rdkShellApisInstance.setVisibility(GLOBALS.selfClientName, false);
                resolve(true);
              });
            }
          }
        }).catch(err => {
          console.log('Netflix plugin error', err);
          GLOBALS.topmostApp = GLOBALS.selfClientName;
          reject(false);
        });
      });
    }

    /**
     * Function to register event listeners for Xcast plugin.
     */
    registerXcastListeners() {
      let self = this;
      this.xcastApi.registerEvent('onApplicationLaunchRequest', notification => {
        console.log('App onApplicationLaunchRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let params = {
            url: applicationName.startsWith("YouTube") ? notification.parameters.url : notification.parameters.pluginUrl,
            launchLocation: "dial",
            appIdentifier: self.appIdentifiers[applicationName]
          };
          appApi.launchApp(applicationName, params).then(res => {
            console.log("App onApplicationLaunchRequest: launched " + applicationName + " : ", res);
            GLOBALS.topmostApp = applicationName;
            // TODO: move to Controller.statuschange event
            let params = {
              applicationName: notification.applicationName,
              state: 'running'
            };
            this.xcastApi.onApplicationStateChanged(params);
          }).catch(err => {
            console.log("App onApplicationLaunchRequest: error ", err);
          });
        } else {
          console.log("App onApplicationLaunchRequest: " + notification.applicationName + " is not supported.");
        }
      });
      this.xcastApi.registerEvent('onApplicationHideRequest', notification => {
        console.log('App onApplicationHideRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          console.log('App onApplicationHideRequest: ' + this.xcastApps(notification.applicationName));
          //second argument true means resident app won't be launched the required app will be exited in the background.
          //only bring up the resident app when the notification is from the current app(ie app in focus)
          console.log("App onApplicationHideRequest: exitApp as " + applicationName + "!==" + GLOBALS.topmostApp);
          appApi.exitApp(applicationName, applicationName !== GLOBALS.topmostApp);
        } else {
          console.log("App onApplicationHideRequest: " + notification.applicationName + " is not supported.");
        }
      });
      this.xcastApi.registerEvent('onApplicationResumeRequest', notification => {
        console.log('App onApplicationResumeRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let params = {
            url: notification.parameters.url,
            launchLocation: "dial",
            appIdentifier: self.appIdentifiers[applicationName]
          };
          console.log('App onApplicationResumeRequest: launchApp ', applicationName, " with params: ", params);
          appApi.launchApp(applicationName, params).then(res => {
            GLOBALS.topmostApp = applicationName;
            console.log("App onApplicationResumeRequest: launched ", applicationName, " result: ", res);
          }).catch(err => {
            console.log("Error in launching ", applicationName, " on casting resume request: ", err);
          });
        } else {
          console.log("App onApplicationResumeRequest: " + notification.applicationName + " is not supported.");
        }
      });
      this.xcastApi.registerEvent('onApplicationStopRequest', notification => {
        console.log('App onApplicationStopRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          appApi.exitApp(applicationName, true, true);
        } else {
          console.log("App onApplicationStopRequest: " + notification.applicationName + " is not supported.");
        }
      });
      this.xcastApi.registerEvent('onApplicationStateRequest', notification => {
        //console.log("App onApplicationStateRequest: " + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let appState = {
            "applicationName": notification.applicationName,
            "state": "stopped"
          };
          appApi.checkStatus(applicationName).then(result => {
            console.log("result of xcast app status", result[0].state);
            switch (result[0].state) {
              case "activated":
              case "resumed":
                appState.state = "running";
                break;
              case "Activation":
              case "deactivated":
              case "Deactivation":
              case "Precondition":
                appState.state = "stopped";
                break;
              case "hibernated":
              case "suspended":
                appState.state = "suspended";
                break;
            }
            this.xcastApi.onApplicationStateChanged(appState);
          }).catch(error => {
            console.error("App onApplicationStateRequest: checkStatus error ", error);
          });
        } else {
          console.log("App onApplicationStateRequest: " + notification.applicationName + " is not supported.");
        }
      });
    }

    /**
     * Function to get the plugin name for the application name.
     * @param {string} app App instance.
     */
    xcastApps(app) {
      if (Object.keys(XcastApi.supportedApps()).includes(app)) {
        return XcastApi.supportedApps()[app];
      } else return false;
    }
    $mountEventConstructor(fun) {
      this.ListenerConstructor = fun;
      console.log("MountEventConstructor was initialized");
      // console.log(`listener constructor was set t0 = ${this.ListenerConstructor}`);
    }
    $registerUsbMount() {
      this.disposableListener = this.ListenerConstructor();
      console.log("Successfully registered the usb Mount");
    }
    $deRegisterUsbMount() {
      console.log("the current usbListener = ".concat(this.disposableListener));
      this.disposableListener.dispose();
      console.log("successfully deregistered usb listener");
    }
    standby(value) {
      console.log("standby call");
      if (value == 'Back') ; else {
        if (powerState == 'ON') {
          console.log("Power state was on trying to set it to standby");
          appApi.setPowerState(value).then(res => {
            if (res.success) {
              console.log("successfully set to standby");
              powerState = 'STANDBY';
              if (GLOBALS.topmostApp !== GLOBALS.selfClientName) {
                appApi.exitApp(GLOBALS.topmostApp);
              } else {
                if (!Router.isNavigating()) {
                  Router.navigate('menu');
                }
              }
            }
          });
          return true;
        }
      }
    }
    $registerInactivityMonitoringEvents() {
      return new Promise((resolve, reject) => {
        console.log("registered inactivity listener");
        appApi.setPowerState('ON').then(res => {
          if (res.success) {
            powerState = 'ON';
          }
        });
        thunder.Controller.activate({
          callsign: 'org.rdk.RDKShell.1'
        }).then(res => {
          console.log("activated the rdk shell plugin trying to set the inactivity listener; res = ".concat(JSON.stringify(res)));
          thunder.on("org.rdk.RDKShell.1", "onUserInactivity", notification => {
            console.log('onUserInactivity: ' + JSON.stringify(notification));
            if (powerState === "ON" && GLOBALS.topmostApp === GLOBALS.selfClientName) {
              this.standby("STANDBY");
            }
          }, err => {
            console.error("error while inactivity monitoring , ".concat(err));
          });
          resolve(res);
        }).catch(err => {
          Metrics$3.error(Metrics$3.ErrorType.OTHER, 'AppError', "Controller.activate error with ".concat(err), false, null);
          reject(err);
          console.error("error while activating the displaysettings plugin; err = ".concat(err));
        });
      });
    }
    $resetSleepTimer(t) {
      console.log("reset sleep timer call ".concat(t));
      var arr = t.split(" ");
      function setTimer() {
        console.log('Timer ', arr);
        var temp = arr[1].substring(0, 1);
        if (temp === 'H') {
          let temp1 = parseFloat(arr[0]) * 60;
          rdkShellApisInstance.setInactivityInterval(temp1).then(() => {
            Storage$1.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " hours"));
          }).catch(err => {
            console.error('error while setting the timer' + JSON.stringify(err));
          });
        } else if (temp === 'M') {
          console.log("minutes");
          let temp1 = parseFloat(arr[0]);
          rdkShellApisInstance.setInactivityInterval(temp1).then(() => {
            Storage$1.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " minutes"));
          }).catch(err => {
            console.error('error while setting the timer' + JSON.stringify(err));
          });
        }
      }
      if (arr.length < 2) {
        rdkShellApisInstance.enableInactivityReporting(false).then(res => {
          if (res === true) {
            Storage$1.set('TimeoutInterval', false);
            console.log("Disabled inactivity reporting");
            // this.timerIsOff = true;
          }
        }).catch(err => {
          console.error("error : unable to set the reset; error = ".concat(err));
        });
      } else {
        rdkShellApisInstance.enableInactivityReporting(true).then(res => {
          if (res === true) {
            console.log("Enabled inactivity reporting; trying to set the timer to ".concat(t));
            // this.timerIsOff = false;
            setTimer();
          }
        }).catch(err => {
          console.error('error while enabling inactivity reporting' + JSON.stringify(err));
        });
      }
    }
    jumpToRoute(route) {
      if (GLOBALS.topmostApp != GLOBALS.selfClientName) {
        appApi.exitApp(GLOBALS.topmostApp).catch(err => {
          console.log("jumpToRoute err: " + err);
        });
        Storage$1.set("lastVisitedRoute", route); // incase any state change event tries to navigate, it need to be navigated to alexa requested route
        Router.navigate(route);
      } else {
        if (!Router.isNavigating()) {
          if (Router.getActiveHash() === "dtvplayer") {
            //exit scenario for dtv player
            dtvApi.exitChannel().then(res => {
              console.log("exit channel: ", JSON.stringify(res));
            }).catch(err => {
              console.log("failed to exit channel: ", JSON.stringify(err));
            });
            if (Router.getActiveWidget()) {
              Router.getActiveWidget()._setState("IdleState");
            }
          }
          Storage$1.set("lastVisitedRoute", route);
          Router.navigate(route);
        }
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  function index () {
    console.time('PerformanceTest');
    console.log('Timer Start - ', new Date().toUTCString());
    return Launch(App, ...arguments);
  }

  return index;

})();
//# sourceMappingURL=appBundle.js.map
